var areaJSON='{"columns":["", "ALUTs", "FFs", "RAMs", "DSPs", "Details"], "debug_enabled":"true", "type":"module", "total_percent":[8.07184, 5.19293, 3.36309, 1.55642, 18.75], "total":[5690, 7370, 8, 21], "name":"System", "max_resources":[109572, 219144, 514, 112], "children":[{"name":"resize", "compute_units":1, "type":"function", "total_percent":[8.07184, 5.19293, 3.36309, 1.55642, 18.75], "total_kernel_resources":[5690, 7370, 8, 20.5], "details":[{"type":"text", "text":"Number of compute units: 1"}], "children":[{"name":"Component call", "type":"resource", "data":[0, 0, 0, 0], "details":[{"type":"text", "text":"Stream implemented 96 bits wide with a buffer size of 0 elements."}]}, {"name":"Component return", "type":"resource", "data":[0, 0, 0, 0], "details":[{"type":"text", "text":"Stream implemented 1 bit wide with a buffer size of 0 elements."}]}, {"name":"Stream \'original_image\'", "type":"resource", "data":[0, 0, 0, 0], "details":[{"type":"text", "text":"Stream implemented 32 bits wide with a buffer size of 0 elements."}]}, {"name":"Stream \'resized_image\'", "type":"resource", "data":[0, 0, 0, 0], "details":[{"type":"text", "text":"Stream implemented 32 bits wide with a buffer size of 0 elements."}]}, {"name":"Variable: \\n - \'accumColumn\' (resize.cpp:59)", "type":"resource", "data":[24, 101, 0, 0], "debug":[[{"filename":"resize.cpp", "line":59}]], "details":[{"type":"text", "text":"Type: Register"}, {"type":"text", "text":"1 register of width 32 and depth 1"}]}, {"name":"Variable: \\n - \'accumRow\' (resize.cpp:59)", "type":"resource", "data":[24, 101, 0, 0], "debug":[[{"filename":"resize.cpp", "line":59}]], "details":[{"type":"text", "text":"Type: Register"}, {"type":"text", "text":"1 register of width 32 and depth 1"}]}, {"name":"Variable: \\n - \'buf\' (resize.cpp:58)", "type":"resource", "data":[40, 996, 4, 0], "debug":[[{"filename":"resize.cpp", "line":58}]], "details":[{"type":"text", "text":"Type: Shift Register (9 or fewer tap points)"}, {"type":"text", "text":"4 registers of width 8 and depth 1"}, {"type":"text", "text":"2 registers of width 8 and depth 727"}, {"type":"text", "text":"2 registers of width 8 and depth 728"}, {"type":"text", "text":"1 register of width 11 and depth 1"}]}, {"name":"Variable: \\n - \'col\' (resize.cpp:60)", "type":"resource", "data":[24, 101, 0, 0], "debug":[[{"filename":"resize.cpp", "line":60}]], "details":[{"type":"text", "text":"Type: Register"}, {"type":"text", "text":"1 register of width 32 and depth 1"}]}, {"name":"Variable: \\n - \'i\' (resize.cpp:64)", "type":"resource", "data":[24, 101, 0, 0], "debug":[[{"filename":"resize.cpp", "line":64}]], "details":[{"type":"text", "text":"Type: Register"}, {"type":"text", "text":"1 register of width 32 and depth 1"}]}, {"name":"Variable: \\n - \'row\' (resize.cpp:60)", "type":"resource", "data":[24, 101, 0, 0], "debug":[[{"filename":"resize.cpp", "line":60}]], "details":[{"type":"text", "text":"Type: Register"}, {"type":"text", "text":"1 register of width 32 and depth 1"}]}, {"name":"Variable: \\n - \'write_y\' (resize.cpp:61)", "type":"resource", "data":[7, 12, 0, 0], "debug":[[{"filename":"resize.cpp", "line":61}]], "details":[{"type":"text", "text":"Type: Register"}, {"type":"text", "text":"1 register of width 8 and depth 1"}]}, {"name":"resize.B1.start", "type":"basicblock", "children":[{"name":"State", "type":"resource", "data":[47, 251, 0, 0], "details":[{"type":"text", "text":"Resources for live values and control logic. To reduce this area:", "details":[{"type":"text", "text":"reduce size of local variables"}, {"type":"text", "text":"reduce scope of local variables, localizing them as much as possible"}, {"type":"text", "text":"reduce number of nested loops"}]}], "children":[{"name":"No Source Line", "type":"resource", "data":[47, 188, 0, 0]}, {"name":"resize.cpp:59", "type":"resource", "data":[0, 32, 0, 0], "debug":[[{"filename":"resize.cpp", "line":59}]]}, {"name":"resize.cpp:64", "type":"resource", "data":[0, 31, 0, 0], "debug":[[{"filename":"resize.cpp", "line":64}]]}]}, {"name":"Feedback", "type":"resource", "data":[5, 2, 0, 0], "details":[{"type":"text", "text":"Resources for loop-carried dependencies. To reduce this area:", "details":[{"type":"text", "text":"reduce number and size of loop-carried variables"}]}], "children":[{"name":"No Source Line", "type":"resource", "data":[5, 2, 0, 0]}]}, {"name":"Cluster logic", "type":"resource", "data":[2, 0, 0, 0], "details":[{"type":"text", "text":"Logic required to efficiently support sets of operations that do not stall. This area cannot be affected directly."}]}, {"name":"Computation", "type":"resource", "children":[{"name":"No Source Line", "type":"resource", "data":[1, 0, 0, 0], "debug":[[{"filename":"", "line":0}]], "children":[{"name":"Channel Read", "type":"resource", "count":1, "data":[1, 0, 0, 0]}]}, {"name":"resize.cpp:59", "type":"resource", "data":[33, 0, 0, 0], "debug":[[{"filename":"resize.cpp", "line":59}]], "children":[{"name":"32-bit Integer Subtract", "type":"resource", "count":1, "data":[33, 0, 0, 0]}], "replace_name":"true"}, {"name":"resize.cpp:64", "type":"resource", "data":[304, 129, 0, 0], "debug":[[{"filename":"resize.cpp", "line":64}]], "children":[{"name":"32-bit Integer Add", "type":"resource", "count":2, "data":[66, 0, 0, 0]}, {"name":"32-bit Integer Multiply", "type":"resource", "count":1, "data":[169, 128, 0, 0]}, {"name":"33-bit Integer Add", "type":"resource", "count":1, "data":[34, 0, 0, 0]}, {"name":"Integer Compare", "type":"resource", "count":1, "data":[35, 1, 0, 0]}], "replace_name":"true"}]}]}, {"name":"resize.B2", "type":"basicblock", "children":[{"name":"State", "type":"resource", "data":[1797, 3127, 0, 0], "details":[{"type":"text", "text":"Resources for live values and control logic. To reduce this area:", "details":[{"type":"text", "text":"reduce size of local variables"}, {"type":"text", "text":"reduce scope of local variables, localizing them as much as possible"}, {"type":"text", "text":"reduce number of nested loops"}]}], "children":[{"name":"No Source Line", "type":"resource", "data":[1797, 3127, 0, 0]}]}, {"name":"Feedback", "type":"resource", "data":[351, 1673, 4, 0], "details":[{"type":"text", "text":"Resources for loop-carried dependencies. To reduce this area:", "details":[{"type":"text", "text":"reduce number and size of loop-carried variables"}]}], "children":[{"name":"No Source Line", "type":"resource", "data":[1, 0, 0, 0]}, {"name":"resize.cpp:113", "type":"resource", "data":[12.1111, 9.33333, 0, 0], "debug":[[{"filename":"resize.cpp", "line":113}]]}, {"name":"resize.cpp:114", "type":"resource", "data":[11.7778, 9.33333, 0, 0], "debug":[[{"filename":"resize.cpp", "line":114}]]}, {"name":"resize.cpp:115", "type":"resource", "data":[11.7778, 9.33333, 0, 0], "debug":[[{"filename":"resize.cpp", "line":115}]]}, {"name":"resize.cpp:116", "type":"resource", "data":[11.7778, 9.33333, 0, 0], "debug":[[{"filename":"resize.cpp", "line":116}]]}, {"name":"resize.cpp:118", "type":"resource", "data":[34.5, 118, 0, 0], "debug":[[{"filename":"resize.cpp", "line":118}]]}, {"name":"resize.cpp:119", "type":"resource", "data":[34.5, 118, 0, 0], "debug":[[{"filename":"resize.cpp", "line":119}]]}, {"name":"resize.cpp:58", "type":"resource", "data":[63.6111, 522.833, 2, 0], "debug":[[{"filename":"resize.cpp", "line":58}]]}, {"name":"resize.cpp:59", "type":"resource", "data":[8.66667, 33.6667, 0, 0], "debug":[[{"filename":"resize.cpp", "line":59}]]}, {"name":"resize.cpp:60", "type":"resource", "data":[1, 0, 0, 0], "debug":[[{"filename":"resize.cpp", "line":60}]]}, {"name":"resize.cpp:61", "type":"resource", "data":[2.08333, 3, 0, 0], "debug":[[{"filename":"resize.cpp", "line":61}]]}, {"name":"resize.cpp:64", "type":"resource", "data":[45, 135, 0, 0], "debug":[[{"filename":"resize.cpp", "line":64}]]}, {"name":"resize.cpp:67", "type":"resource", "data":[18.6111, 138.333, 0.5, 0], "debug":[[{"filename":"resize.cpp", "line":67}]]}, {"name":"resize.cpp:68", "type":"resource", "data":[15.7778, 129.833, 0.5, 0], "debug":[[{"filename":"resize.cpp", "line":68}]]}, {"name":"resize.cpp:69", "type":"resource", "data":[15.7778, 129.833, 0.5, 0], "debug":[[{"filename":"resize.cpp", "line":69}]]}, {"name":"resize.cpp:70", "type":"resource", "data":[15.7778, 129.833, 0.5, 0], "debug":[[{"filename":"resize.cpp", "line":70}]]}, {"name":"resize.cpp:78", "type":"resource", "data":[2.08333, 3, 0, 0], "debug":[[{"filename":"resize.cpp", "line":78}]]}, {"name":"resize.cpp:79", "type":"resource", "data":[8.33333, 33.6667, 0, 0], "debug":[[{"filename":"resize.cpp", "line":79}]]}, {"name":"resize.cpp:80", "type":"resource", "data":[1.75, 3, 0, 0], "debug":[[{"filename":"resize.cpp", "line":80}]]}, {"name":"resize.cpp:81", "type":"resource", "data":[8.33333, 33.6667, 0, 0], "debug":[[{"filename":"resize.cpp", "line":81}]]}, {"name":"resize.cpp:82", "type":"resource", "data":[2.08333, 3, 0, 0], "debug":[[{"filename":"resize.cpp", "line":82}]]}, {"name":"resize.cpp:85", "type":"resource", "data":[0.333333, 0, 0, 0], "debug":[[{"filename":"resize.cpp", "line":85}]]}, {"name":"resize.cpp:87", "type":"resource", "data":[24, 101, 0, 0], "debug":[[{"filename":"resize.cpp", "line":87}]]}, {"name":"resize.cpp:88", "type":"resource", "data":[0.333333, 0, 0, 0], "debug":[[{"filename":"resize.cpp", "line":88}]]}]}, {"name":"Cluster logic", "type":"resource", "data":[250, 118, 0, 0], "details":[{"type":"text", "text":"Logic required to efficiently support sets of operations that do not stall. This area cannot be affected directly."}]}, {"name":"Computation", "type":"resource", "children":[{"name":"No Source Line", "type":"resource", "data":[159, 0, 0, 0], "debug":[[{"filename":"", "line":0}]], "children":[{"name":"32-bit Integer Add", "type":"resource", "count":4, "data":[132, 0, 0, 0]}, {"name":"Select", "type":"resource", "count":1, "data":[27, 0, 0, 0]}]}, {"name":"resize.cpp:58", "type":"resource", "data":[19.4444, 4.33333, 0, 0], "debug":[[{"filename":"resize.cpp", "line":58}]], "children":[{"name":"11-bit Integer Subtract", "type":"resource", "count":1, "data":[1.33333, 0, 0, 0]}, {"name":"Integer Compare", "type":"resource", "count":1, "data":[4.66667, 0.333333, 0, 0]}, {"name":"Select", "type":"resource", "count":4, "data":[13, 4, 0, 0]}, {"name":"Xor", "type":"resource", "count":1, "data":[0.444444, 0, 0, 0]}], "replace_name":"true"}, {"name":"resize.cpp:59", "type":"resource", "data":[36.6667, 10.6667, 0, 0], "debug":[[{"filename":"resize.cpp", "line":59}]], "children":[{"name":"Select", "type":"resource", "count":4, "data":[36.6667, 10.6667, 0, 0]}], "replace_name":"true"}, {"name":"resize.cpp:60", "type":"resource", "data":[3.33333, 0.666667, 0, 0], "debug":[[{"filename":"resize.cpp", "line":60}]], "children":[{"name":"Integer Compare", "type":"resource", "count":1, "data":[3.33333, 0.666667, 0, 0]}], "replace_name":"true"}, {"name":"resize.cpp:61", "type":"resource", "data":[1.75, 0, 0, 0], "debug":[[{"filename":"resize.cpp", "line":61}]], "children":[{"name":"Select", "type":"resource", "count":1, "data":[1.75, 0, 0, 0]}], "replace_name":"true"}, {"name":"resize.cpp:64", "type":"resource", "data":[52.5, 1, 0, 0], "debug":[[{"filename":"resize.cpp", "line":64}]], "children":[{"name":"32-bit Integer Add", "type":"resource", "count":1, "data":[33, 0, 0, 0]}, {"name":"33-bit Integer Add", "type":"resource", "count":2, "data":[17, 0, 0, 0]}, {"name":"And", "type":"resource", "count":8, "data":[1.5, 1, 0, 0]}, {"name":"Integer Compare", "type":"resource", "count":6, "data":[1, 0, 0, 0]}], "replace_name":"true"}, {"name":"resize.cpp:65", "type":"resource", "data":[71, 3, 0, 0], "debug":[[{"filename":"resize.cpp", "line":65}]], "children":[{"name":"And", "type":"resource", "count":1, "data":[1, 1, 0, 0]}, {"name":"Integer Compare", "type":"resource", "count":2, "data":[70, 2, 0, 0]}], "replace_name":"true"}, {"name":"resize.cpp:66", "type":"resource", "data":[1, 0, 0, 0], "debug":[[{"filename":"resize.cpp", "line":66}]], "children":[{"name":"Channel Read", "type":"resource", "count":1, "data":[1, 0, 0, 0]}], "replace_name":"true"}, {"name":"resize.cpp:67", "type":"resource", "data":[10.4444, 4.33333, 0, 0], "debug":[[{"filename":"resize.cpp", "line":67}]], "children":[{"name":"11-bit Integer Subtract", "type":"resource", "count":1, "data":[1.33333, 0, 0, 0]}, {"name":"Integer Compare", "type":"resource", "count":1, "data":[4.66667, 0.333333, 0, 0]}, {"name":"Select", "type":"resource", "count":1, "data":[4, 4, 0, 0]}, {"name":"Xor", "type":"resource", "count":1, "data":[0.444444, 0, 0, 0]}], "replace_name":"true"}, {"name":"resize.cpp:68", "type":"resource", "data":[5.27778, 0, 0, 0], "debug":[[{"filename":"resize.cpp", "line":68}]], "children":[{"name":"11-bit Integer Subtract", "type":"resource", "count":1, "data":[1.33333, 0, 0, 0]}, {"name":"Select", "type":"resource", "count":1, "data":[3.5, 0, 0, 0]}, {"name":"Xor", "type":"resource", "count":1, "data":[0.444444, 0, 0, 0]}], "replace_name":"true"}, {"name":"resize.cpp:69", "type":"resource", "data":[5.27778, 0, 0, 0], "debug":[[{"filename":"resize.cpp", "line":69}]], "children":[{"name":"11-bit Integer Subtract", "type":"resource", "count":1, "data":[1.33333, 0, 0, 0]}, {"name":"Select", "type":"resource", "count":1, "data":[3.5, 0, 0, 0]}, {"name":"Xor", "type":"resource", "count":1, "data":[0.444444, 0, 0, 0]}], "replace_name":"true"}, {"name":"resize.cpp:70", "type":"resource", "data":[3.77778, 0, 0, 0], "debug":[[{"filename":"resize.cpp", "line":70}]], "children":[{"name":"11-bit Integer Subtract", "type":"resource", "count":1, "data":[1.33333, 0, 0, 0]}, {"name":"Select", "type":"resource", "count":1, "data":[2, 0, 0, 0]}, {"name":"Xor", "type":"resource", "count":1, "data":[0.444444, 0, 0, 0]}], "replace_name":"true"}, {"name":"resize.cpp:76", "type":"resource", "data":[3.33333, 0.666667, 0, 0], "debug":[[{"filename":"resize.cpp", "line":76}]], "children":[{"name":"Integer Compare", "type":"resource", "count":1, "data":[3.33333, 0.666667, 0, 0]}], "replace_name":"true"}, {"name":"resize.cpp:78", "type":"resource", "data":[1.75, 0, 0, 0], "debug":[[{"filename":"resize.cpp", "line":78}]], "children":[{"name":"Select", "type":"resource", "count":1, "data":[1.75, 0, 0, 0]}], "replace_name":"true"}, {"name":"resize.cpp:79", "type":"resource", "data":[61, 10.6667, 0, 0], "debug":[[{"filename":"resize.cpp", "line":79}]], "children":[{"name":"32-bit Integer Add", "type":"resource", "count":1, "data":[33, 0, 0, 0]}, {"name":"Select", "type":"resource", "count":3, "data":[28, 10.6667, 0, 0]}], "replace_name":"true"}, {"name":"resize.cpp:80", "type":"resource", "data":[36.75, 1, 0, 0], "debug":[[{"filename":"resize.cpp", "line":80}]], "children":[{"name":"Integer Compare", "type":"resource", "count":1, "data":[35, 1, 0, 0]}, {"name":"Select", "type":"resource", "count":1, "data":[1.75, 0, 0, 0]}], "replace_name":"true"}, {"name":"resize.cpp:81", "type":"resource", "data":[61, 10.6667, 0, 0], "debug":[[{"filename":"resize.cpp", "line":81}]], "children":[{"name":"32-bit Integer Add", "type":"resource", "count":1, "data":[33, 0, 0, 0]}, {"name":"Select", "type":"resource", "count":3, "data":[28, 10.6667, 0, 0]}], "replace_name":"true"}, {"name":"resize.cpp:82", "type":"resource", "data":[1.75, 0, 0, 0], "debug":[[{"filename":"resize.cpp", "line":82}]], "children":[{"name":"Select", "type":"resource", "count":1, "data":[1.75, 0, 0, 0]}], "replace_name":"true"}, {"name":"resize.cpp:85", "type":"resource", "data":[41.6667, 0, 0, 0], "debug":[[{"filename":"resize.cpp", "line":85}]], "children":[{"name":"32-bit Integer Add", "type":"resource", "count":1, "data":[33, 0, 0, 0]}, {"name":"Select", "type":"resource", "count":1, "data":[8.66667, 0, 0, 0]}], "replace_name":"true"}, {"name":"resize.cpp:87", "type":"resource", "data":[61.5, 1.5, 0, 0], "debug":[[{"filename":"resize.cpp", "line":87}]], "children":[{"name":"And", "type":"resource", "count":3, "data":[0.5, 0.5, 0, 0]}, {"name":"Integer Compare", "type":"resource", "count":1, "data":[35, 1, 0, 0]}, {"name":"Select", "type":"resource", "count":1, "data":[26, 0, 0, 0]}], "replace_name":"true"}, {"name":"resize.cpp:88", "type":"resource", "data":[41.6667, 0, 0, 0], "debug":[[{"filename":"resize.cpp", "line":88}]], "children":[{"name":"32-bit Integer Add", "type":"resource", "count":1, "data":[33, 0, 0, 0]}, {"name":"Select", "type":"resource", "count":1, "data":[8.66667, 0, 0, 0]}], "replace_name":"true"}, {"name":"resize.cpp:92", "type":"resource", "data":[145, 5, 0, 0], "debug":[[{"filename":"resize.cpp", "line":92}]], "children":[{"name":"32-bit Integer Add", "type":"resource", "count":1, "data":[33, 0, 0, 0]}, {"name":"And", "type":"resource", "count":6, "data":[4, 1, 0, 0]}, {"name":"Integer Compare", "type":"resource", "count":4, "data":[108, 4, 0, 0]}], "replace_name":"true"}, {"name":"resize.cpp:98", "type":"resource", "data":[22, 0, 0, 0.5], "debug":[[{"filename":"resize.cpp", "line":98}]], "children":[{"name":"32-bit Integer Multiply", "type":"resource", "count":1, "data":[0, 0, 0, 0.5]}, {"name":"And", "type":"resource", "count":2, "data":[22, 0, 0, 0]}], "replace_name":"true"}, {"name":"resize.cpp:102", "type":"resource", "data":[1725, 456, 0, 20], "debug":[[{"filename":"resize.cpp", "line":102}]], "children":[{"name":"32-bit Integer Add", "type":"resource", "count":12, "data":[396, 0, 0, 0]}, {"name":"32-bit Integer Multiply", "type":"resource", "count":12, "data":[636, 456, 0, 20]}, {"name":"32-bit Integer Subtract", "type":"resource", "count":16, "data":[528, 0, 0, 0]}, {"name":"And", "type":"resource", "count":15, "data":[165, 0, 0, 0]}], "replace_name":"true"}, {"name":"resize.cpp:108", "type":"resource", "data":[3, 2, 0, 0], "debug":[[{"filename":"resize.cpp", "line":108}]], "children":[{"name":"Channel Write", "type":"resource", "count":1, "data":[3, 2, 0, 0]}], "replace_name":"true"}, {"name":"resize.cpp:113", "type":"resource", "data":[6.44444, 0.333333, 0, 0], "debug":[[{"filename":"resize.cpp", "line":113}]], "children":[{"name":"11-bit Integer Subtract", "type":"resource", "count":1, "data":[1.33333, 0, 0, 0]}, {"name":"Integer Compare", "type":"resource", "count":1, "data":[4.66667, 0.333333, 0, 0]}, {"name":"Xor", "type":"resource", "count":1, "data":[0.444444, 0, 0, 0]}], "replace_name":"true"}, {"name":"resize.cpp:114", "type":"resource", "data":[1.77778, 0, 0, 0], "debug":[[{"filename":"resize.cpp", "line":114}]], "children":[{"name":"11-bit Integer Subtract", "type":"resource", "count":1, "data":[1.33333, 0, 0, 0]}, {"name":"Xor", "type":"resource", "count":1, "data":[0.444444, 0, 0, 0]}], "replace_name":"true"}, {"name":"resize.cpp:115", "type":"resource", "data":[1.77778, 0, 0, 0], "debug":[[{"filename":"resize.cpp", "line":115}]], "children":[{"name":"11-bit Integer Subtract", "type":"resource", "count":1, "data":[1.33333, 0, 0, 0]}, {"name":"Xor", "type":"resource", "count":1, "data":[0.444444, 0, 0, 0]}], "replace_name":"true"}, {"name":"resize.cpp:116", "type":"resource", "data":[1.77778, 0, 0, 0], "debug":[[{"filename":"resize.cpp", "line":116}]], "children":[{"name":"11-bit Integer Subtract", "type":"resource", "count":1, "data":[1.33333, 0, 0, 0]}, {"name":"Xor", "type":"resource", "count":1, "data":[0.444444, 0, 0, 0]}], "replace_name":"true"}, {"name":"resize.cpp:118", "type":"resource", "data":[87.8333, 32.9167, 0, 0], "debug":[[{"filename":"resize.cpp", "line":118}]], "children":[{"name":"32-bit Integer Add", "type":"resource", "count":1, "data":[33, 0, 0, 0]}, {"name":"33-bit Integer Add", "type":"resource", "count":1, "data":[8.5, 0, 0, 0]}, {"name":"And", "type":"resource", "count":4, "data":[0.5, 0.25, 0, 0]}, {"name":"Integer Compare", "type":"resource", "count":5, "data":[13.8333, 0.666667, 0, 0]}, {"name":"Select", "type":"resource", "count":1, "data":[32, 32, 0, 0]}], "replace_name":"true"}, {"name":"resize.cpp:119", "type":"resource", "data":[52.5, 2.25, 0, 0], "debug":[[{"filename":"resize.cpp", "line":119}]], "children":[{"name":"32-bit Integer Add", "type":"resource", "count":1, "data":[33, 0, 0, 0]}, {"name":"33-bit Integer Add", "type":"resource", "count":1, "data":[8.5, 0, 0, 0]}, {"name":"And", "type":"resource", "count":3, "data":[0.5, 0.25, 0, 0]}, {"name":"Integer Compare", "type":"resource", "count":4, "data":[10.5, 2, 0, 0]}], "replace_name":"true"}]}]}, {"name":"resize.B3", "type":"basicblock", "children":[{"name":"Feedback", "type":"resource", "data":[3, 8, 0, 0], "details":[{"type":"text", "text":"Resources for loop-carried dependencies. To reduce this area:", "details":[{"type":"text", "text":"reduce number and size of loop-carried variables"}]}], "children":[{"name":"No Source Line", "type":"resource", "data":[3, 8, 0, 0]}]}, {"name":"Computation", "type":"resource", "children":[{"name":"No Source Line", "type":"resource", "data":[3, 2, 0, 0], "debug":[[{"filename":"", "line":0}]], "children":[{"name":"Channel Write", "type":"resource", "count":1, "data":[3, 2, 0, 0]}]}]}]}]}]}';
var area_srcJSON='{"max_resources":[109572,219144,514,112],"name":"System","children":[{"debug":[[{"filename":"resize.cpp","line":58}]],"total_kernel_resources":[5690,7370,8,20.5],"name":"resize","data":[5689.99998,7370.000127,8,20.5],"children":[{"detail":[{"text":"Feedback + Cluster logic","type":"text"}],"name":"Data control overhead","type":"resource","data":[611,1801,4,0]},{"name":"Component call","type":"resource","data":[0,0,0,0],"details":[{"text":"Stream implemented 96 bits wide with a buffer size of 0 elements.","type":"text"}]},{"name":"Component return","type":"resource","data":[0,0,0,0],"details":[{"text":"Stream implemented 1 bit wide with a buffer size of 0 elements.","type":"text"}]},{"name":"Stream \'original_image\'","type":"resource","data":[0,0,0,0],"details":[{"text":"Stream implemented 32 bits wide with a buffer size of 0 elements.","type":"text"}]},{"name":"Stream \'resized_image\'","type":"resource","data":[0,0,0,0],"details":[{"text":"Stream implemented 32 bits wide with a buffer size of 0 elements.","type":"text"}]},{"name":"Variable: \\n - \'accumColumn\' (resize.cpp:59)","type":"resource","data":[24,101,0,0],"details":[{"text":"Type: Register","type":"text"},{"text":"1 register of width 32 and depth 1","type":"text"}]},{"name":"Variable: \\n - \'accumRow\' (resize.cpp:59)","type":"resource","data":[24,101,0,0],"details":[{"text":"Type: Register","type":"text"},{"text":"1 register of width 32 and depth 1","type":"text"}]},{"name":"Variable: \\n - \'buf\' (resize.cpp:58)","type":"resource","data":[40,996,4,0],"details":[{"text":"Type: Shift Register (9 or fewer tap points)","type":"text"},{"text":"4 registers of width 8 and depth 1","type":"text"},{"text":"2 registers of width 8 and depth 727","type":"text"},{"text":"2 registers of width 8 and depth 728","type":"text"},{"text":"1 register of width 11 and depth 1","type":"text"}]},{"name":"Variable: \\n - \'col\' (resize.cpp:60)","type":"resource","data":[24,101,0,0],"details":[{"text":"Type: Register","type":"text"},{"text":"1 register of width 32 and depth 1","type":"text"}]},{"name":"Variable: \\n - \'i\' (resize.cpp:64)","type":"resource","data":[24,101,0,0],"details":[{"text":"Type: Register","type":"text"},{"text":"1 register of width 32 and depth 1","type":"text"}]},{"name":"Variable: \\n - \'row\' (resize.cpp:60)","type":"resource","data":[24,101,0,0],"details":[{"text":"Type: Register","type":"text"},{"text":"1 register of width 32 and depth 1","type":"text"}]},{"name":"Variable: \\n - \'write_y\' (resize.cpp:61)","type":"resource","data":[7,12,0,0],"details":[{"text":"Type: Register","type":"text"},{"text":"1 register of width 8 and depth 1","type":"text"}]},{"name":"No Source Line","data":[2007,3317,0,0],"type":"resource","children":[{"count":2,"name":"State","debug":[[{"filename":"","line":0}]],"type":"resource","data":[1844,3315,0,0]},{"count":1,"debug":[[{"filename":"","line":0}]],"name":"Channel Read","data":[1,0,0,0],"type":"resource"},{"count":4,"name":"32-bit Integer Add","debug":[[{"filename":"","line":0}]],"type":"resource","data":[132,0,0,0]},{"count":1,"name":"Select","debug":[[{"filename":"","line":0}]],"type":"resource","data":[27,0,0,0]},{"count":1,"debug":[[{"filename":"","line":0}]],"name":"Channel Write","data":[3,2,0,0],"type":"resource"}]},{"debug":[[{"filename":"resize.cpp","line":59}]],"name":"resize.cpp:59","data":[69.6667,42.6667,0,0],"type":"resource","children":[{"count":1,"name":"State","debug":[[{"filename":"resize.cpp","line":59}]],"type":"resource","data":[0,32,0,0]},{"count":1,"debug":[[{"filename":"resize.cpp","line":59}]],"name":"32-bit Integer Subtract","data":[33,0,0,0],"type":"resource"},{"count":4,"debug":[[{"filename":"resize.cpp","line":59}]],"name":"Select","data":[36.6667,10.6667,0,0],"type":"resource"}]},{"debug":[[{"filename":"resize.cpp","line":64}]],"name":"resize.cpp:64","data":[356.5,161,0,0],"type":"resource","children":[{"count":1,"name":"State","debug":[[{"filename":"resize.cpp","line":64}]],"type":"resource","data":[0,31,0,0]},{"count":3,"debug":[[{"filename":"resize.cpp","line":64}]],"name":"32-bit Integer Add","data":[99,0,0,0],"type":"resource"},{"count":1,"debug":[[{"filename":"resize.cpp","line":64}]],"name":"32-bit Integer Multiply","data":[169,128,0,0],"type":"resource"},{"count":3,"debug":[[{"filename":"resize.cpp","line":64}]],"name":"33-bit Integer Add","data":[51,0,0,0],"type":"resource"},{"count":7,"debug":[[{"filename":"resize.cpp","line":64}]],"name":"Integer Compare","data":[36,1,0,0],"type":"resource"},{"count":8,"debug":[[{"filename":"resize.cpp","line":64}]],"name":"And","data":[1.5,1,0,0],"type":"resource"}]},{"name":"resize.cpp:58","debug":[[{"filename":"resize.cpp","line":58}]],"replace_name":"true","type":"resource","data":[19.4444,4.33333,0,0],"children":[{"count":1,"name":"11-bit Integer Subtract","debug":[[{"filename":"resize.cpp","line":58}]],"type":"resource","data":[1.33333,0,0,0]},{"count":1,"name":"Integer Compare","debug":[[{"filename":"resize.cpp","line":58}]],"type":"resource","data":[4.66667,0.333333,0,0]},{"count":4,"name":"Select","debug":[[{"filename":"resize.cpp","line":58}]],"type":"resource","data":[13,4,0,0]},{"count":1,"name":"Xor","debug":[[{"filename":"resize.cpp","line":58}]],"type":"resource","data":[0.444444,0,0,0]}]},{"name":"resize.cpp:60","debug":[[{"filename":"resize.cpp","line":60}]],"replace_name":"true","type":"resource","data":[3.33333,0.666667,0,0],"children":[{"count":1,"name":"Integer Compare","debug":[[{"filename":"resize.cpp","line":60}]],"type":"resource","data":[3.33333,0.666667,0,0]}]},{"name":"resize.cpp:61","debug":[[{"filename":"resize.cpp","line":61}]],"replace_name":"true","type":"resource","data":[1.75,0,0,0],"children":[{"count":1,"name":"Select","debug":[[{"filename":"resize.cpp","line":61}]],"type":"resource","data":[1.75,0,0,0]}]},{"name":"resize.cpp:65","debug":[[{"filename":"resize.cpp","line":65}]],"replace_name":"true","type":"resource","data":[71,3,0,0],"children":[{"count":1,"name":"And","debug":[[{"filename":"resize.cpp","line":65}]],"type":"resource","data":[1,1,0,0]},{"count":2,"name":"Integer Compare","debug":[[{"filename":"resize.cpp","line":65}]],"type":"resource","data":[70,2,0,0]}]},{"name":"resize.cpp:66","debug":[[{"filename":"resize.cpp","line":66}]],"replace_name":"true","type":"resource","data":[1,0,0,0],"children":[{"count":1,"name":"Channel Read","debug":[[{"filename":"resize.cpp","line":66}]],"type":"resource","data":[1,0,0,0]}]},{"name":"resize.cpp:67","debug":[[{"filename":"resize.cpp","line":67}]],"replace_name":"true","type":"resource","data":[10.4444,4.33333,0,0],"children":[{"count":1,"name":"11-bit Integer Subtract","debug":[[{"filename":"resize.cpp","line":67}]],"type":"resource","data":[1.33333,0,0,0]},{"count":1,"name":"Integer Compare","debug":[[{"filename":"resize.cpp","line":67}]],"type":"resource","data":[4.66667,0.333333,0,0]},{"count":1,"name":"Select","debug":[[{"filename":"resize.cpp","line":67}]],"type":"resource","data":[4,4,0,0]},{"count":1,"name":"Xor","debug":[[{"filename":"resize.cpp","line":67}]],"type":"resource","data":[0.444444,0,0,0]}]},{"name":"resize.cpp:68","debug":[[{"filename":"resize.cpp","line":68}]],"replace_name":"true","type":"resource","data":[5.27778,0,0,0],"children":[{"count":1,"name":"11-bit Integer Subtract","debug":[[{"filename":"resize.cpp","line":68}]],"type":"resource","data":[1.33333,0,0,0]},{"count":1,"name":"Select","debug":[[{"filename":"resize.cpp","line":68}]],"type":"resource","data":[3.5,0,0,0]},{"count":1,"name":"Xor","debug":[[{"filename":"resize.cpp","line":68}]],"type":"resource","data":[0.444444,0,0,0]}]},{"name":"resize.cpp:69","debug":[[{"filename":"resize.cpp","line":69}]],"replace_name":"true","type":"resource","data":[5.27778,0,0,0],"children":[{"count":1,"name":"11-bit Integer Subtract","debug":[[{"filename":"resize.cpp","line":69}]],"type":"resource","data":[1.33333,0,0,0]},{"count":1,"name":"Select","debug":[[{"filename":"resize.cpp","line":69}]],"type":"resource","data":[3.5,0,0,0]},{"count":1,"name":"Xor","debug":[[{"filename":"resize.cpp","line":69}]],"type":"resource","data":[0.444444,0,0,0]}]},{"name":"resize.cpp:70","debug":[[{"filename":"resize.cpp","line":70}]],"replace_name":"true","type":"resource","data":[3.77778,0,0,0],"children":[{"count":1,"name":"11-bit Integer Subtract","debug":[[{"filename":"resize.cpp","line":70}]],"type":"resource","data":[1.33333,0,0,0]},{"count":1,"name":"Select","debug":[[{"filename":"resize.cpp","line":70}]],"type":"resource","data":[2,0,0,0]},{"count":1,"name":"Xor","debug":[[{"filename":"resize.cpp","line":70}]],"type":"resource","data":[0.444444,0,0,0]}]},{"name":"resize.cpp:76","debug":[[{"filename":"resize.cpp","line":76}]],"replace_name":"true","type":"resource","data":[3.33333,0.666667,0,0],"children":[{"count":1,"name":"Integer Compare","debug":[[{"filename":"resize.cpp","line":76}]],"type":"resource","data":[3.33333,0.666667,0,0]}]},{"name":"resize.cpp:78","debug":[[{"filename":"resize.cpp","line":78}]],"replace_name":"true","type":"resource","data":[1.75,0,0,0],"children":[{"count":1,"name":"Select","debug":[[{"filename":"resize.cpp","line":78}]],"type":"resource","data":[1.75,0,0,0]}]},{"name":"resize.cpp:79","debug":[[{"filename":"resize.cpp","line":79}]],"replace_name":"true","type":"resource","data":[61,10.6667,0,0],"children":[{"count":1,"name":"32-bit Integer Add","debug":[[{"filename":"resize.cpp","line":79}]],"type":"resource","data":[33,0,0,0]},{"count":3,"name":"Select","debug":[[{"filename":"resize.cpp","line":79}]],"type":"resource","data":[28,10.6667,0,0]}]},{"name":"resize.cpp:80","debug":[[{"filename":"resize.cpp","line":80}]],"replace_name":"true","type":"resource","data":[36.75,1,0,0],"children":[{"count":1,"name":"Integer Compare","debug":[[{"filename":"resize.cpp","line":80}]],"type":"resource","data":[35,1,0,0]},{"count":1,"name":"Select","debug":[[{"filename":"resize.cpp","line":80}]],"type":"resource","data":[1.75,0,0,0]}]},{"name":"resize.cpp:81","debug":[[{"filename":"resize.cpp","line":81}]],"replace_name":"true","type":"resource","data":[61,10.6667,0,0],"children":[{"count":1,"name":"32-bit Integer Add","debug":[[{"filename":"resize.cpp","line":81}]],"type":"resource","data":[33,0,0,0]},{"count":3,"name":"Select","debug":[[{"filename":"resize.cpp","line":81}]],"type":"resource","data":[28,10.6667,0,0]}]},{"name":"resize.cpp:82","debug":[[{"filename":"resize.cpp","line":82}]],"replace_name":"true","type":"resource","data":[1.75,0,0,0],"children":[{"count":1,"name":"Select","debug":[[{"filename":"resize.cpp","line":82}]],"type":"resource","data":[1.75,0,0,0]}]},{"name":"resize.cpp:85","debug":[[{"filename":"resize.cpp","line":85}]],"replace_name":"true","type":"resource","data":[41.6667,0,0,0],"children":[{"count":1,"name":"32-bit Integer Add","debug":[[{"filename":"resize.cpp","line":85}]],"type":"resource","data":[33,0,0,0]},{"count":1,"name":"Select","debug":[[{"filename":"resize.cpp","line":85}]],"type":"resource","data":[8.66667,0,0,0]}]},{"name":"resize.cpp:87","debug":[[{"filename":"resize.cpp","line":87}]],"replace_name":"true","type":"resource","data":[61.5,1.5,0,0],"children":[{"count":3,"name":"And","debug":[[{"filename":"resize.cpp","line":87}]],"type":"resource","data":[0.5,0.5,0,0]},{"count":1,"name":"Integer Compare","debug":[[{"filename":"resize.cpp","line":87}]],"type":"resource","data":[35,1,0,0]},{"count":1,"name":"Select","debug":[[{"filename":"resize.cpp","line":87}]],"type":"resource","data":[26,0,0,0]}]},{"name":"resize.cpp:88","debug":[[{"filename":"resize.cpp","line":88}]],"replace_name":"true","type":"resource","data":[41.6667,0,0,0],"children":[{"count":1,"name":"32-bit Integer Add","debug":[[{"filename":"resize.cpp","line":88}]],"type":"resource","data":[33,0,0,0]},{"count":1,"name":"Select","debug":[[{"filename":"resize.cpp","line":88}]],"type":"resource","data":[8.66667,0,0,0]}]},{"name":"resize.cpp:92","debug":[[{"filename":"resize.cpp","line":92}]],"replace_name":"true","type":"resource","data":[145,5,0,0],"children":[{"count":1,"name":"32-bit Integer Add","debug":[[{"filename":"resize.cpp","line":92}]],"type":"resource","data":[33,0,0,0]},{"count":6,"name":"And","debug":[[{"filename":"resize.cpp","line":92}]],"type":"resource","data":[4,1,0,0]},{"count":4,"name":"Integer Compare","debug":[[{"filename":"resize.cpp","line":92}]],"type":"resource","data":[108,4,0,0]}]},{"name":"resize.cpp:98","debug":[[{"filename":"resize.cpp","line":98}]],"replace_name":"true","type":"resource","data":[22,0,0,0.5],"children":[{"count":1,"name":"32-bit Integer Multiply","debug":[[{"filename":"resize.cpp","line":98}]],"type":"resource","data":[0,0,0,0.5]},{"count":2,"name":"And","debug":[[{"filename":"resize.cpp","line":98}]],"type":"resource","data":[22,0,0,0]}]},{"name":"resize.cpp:102","debug":[[{"filename":"resize.cpp","line":102}]],"replace_name":"true","type":"resource","data":[1725,456,0,20],"children":[{"count":12,"name":"32-bit Integer Add","debug":[[{"filename":"resize.cpp","line":102}]],"type":"resource","data":[396,0,0,0]},{"count":12,"name":"32-bit Integer Multiply","debug":[[{"filename":"resize.cpp","line":102}]],"type":"resource","data":[636,456,0,20]},{"count":16,"name":"32-bit Integer Subtract","debug":[[{"filename":"resize.cpp","line":102}]],"type":"resource","data":[528,0,0,0]},{"count":15,"name":"And","debug":[[{"filename":"resize.cpp","line":102}]],"type":"resource","data":[165,0,0,0]}]},{"name":"resize.cpp:108","debug":[[{"filename":"resize.cpp","line":108}]],"replace_name":"true","type":"resource","data":[3,2,0,0],"children":[{"count":1,"name":"Channel Write","debug":[[{"filename":"resize.cpp","line":108}]],"type":"resource","data":[3,2,0,0]}]},{"name":"resize.cpp:113","debug":[[{"filename":"resize.cpp","line":113}]],"replace_name":"true","type":"resource","data":[6.44444,0.333333,0,0],"children":[{"count":1,"name":"11-bit Integer Subtract","debug":[[{"filename":"resize.cpp","line":113}]],"type":"resource","data":[1.33333,0,0,0]},{"count":1,"name":"Integer Compare","debug":[[{"filename":"resize.cpp","line":113}]],"type":"resource","data":[4.66667,0.333333,0,0]},{"count":1,"name":"Xor","debug":[[{"filename":"resize.cpp","line":113}]],"type":"resource","data":[0.444444,0,0,0]}]},{"name":"resize.cpp:114","debug":[[{"filename":"resize.cpp","line":114}]],"replace_name":"true","type":"resource","data":[1.77778,0,0,0],"children":[{"count":1,"name":"11-bit Integer Subtract","debug":[[{"filename":"resize.cpp","line":114}]],"type":"resource","data":[1.33333,0,0,0]},{"count":1,"name":"Xor","debug":[[{"filename":"resize.cpp","line":114}]],"type":"resource","data":[0.444444,0,0,0]}]},{"name":"resize.cpp:115","debug":[[{"filename":"resize.cpp","line":115}]],"replace_name":"true","type":"resource","data":[1.77778,0,0,0],"children":[{"count":1,"name":"11-bit Integer Subtract","debug":[[{"filename":"resize.cpp","line":115}]],"type":"resource","data":[1.33333,0,0,0]},{"count":1,"name":"Xor","debug":[[{"filename":"resize.cpp","line":115}]],"type":"resource","data":[0.444444,0,0,0]}]},{"name":"resize.cpp:116","debug":[[{"filename":"resize.cpp","line":116}]],"replace_name":"true","type":"resource","data":[1.77778,0,0,0],"children":[{"count":1,"name":"11-bit Integer Subtract","debug":[[{"filename":"resize.cpp","line":116}]],"type":"resource","data":[1.33333,0,0,0]},{"count":1,"name":"Xor","debug":[[{"filename":"resize.cpp","line":116}]],"type":"resource","data":[0.444444,0,0,0]}]},{"name":"resize.cpp:118","debug":[[{"filename":"resize.cpp","line":118}]],"replace_name":"true","type":"resource","data":[87.8333,32.9167,0,0],"children":[{"count":1,"name":"32-bit Integer Add","debug":[[{"filename":"resize.cpp","line":118}]],"type":"resource","data":[33,0,0,0]},{"count":1,"name":"33-bit Integer Add","debug":[[{"filename":"resize.cpp","line":118}]],"type":"resource","data":[8.5,0,0,0]},{"count":4,"name":"And","debug":[[{"filename":"resize.cpp","line":118}]],"type":"resource","data":[0.5,0.25,0,0]},{"count":5,"name":"Integer Compare","debug":[[{"filename":"resize.cpp","line":118}]],"type":"resource","data":[13.8333,0.666667,0,0]},{"count":1,"name":"Select","debug":[[{"filename":"resize.cpp","line":118}]],"type":"resource","data":[32,32,0,0]}]},{"name":"resize.cpp:119","debug":[[{"filename":"resize.cpp","line":119}]],"replace_name":"true","type":"resource","data":[52.5,2.25,0,0],"children":[{"count":1,"name":"32-bit Integer Add","debug":[[{"filename":"resize.cpp","line":119}]],"type":"resource","data":[33,0,0,0]},{"count":1,"name":"33-bit Integer Add","debug":[[{"filename":"resize.cpp","line":119}]],"type":"resource","data":[8.5,0,0,0]},{"count":3,"name":"And","debug":[[{"filename":"resize.cpp","line":119}]],"type":"resource","data":[0.5,0.25,0,0]},{"count":4,"name":"Integer Compare","debug":[[{"filename":"resize.cpp","line":119}]],"type":"resource","data":[10.5,2,0,0]}]}],"total_percent":[8.07184,5.19293,3.36309,1.55642,18.75],"type":"function","details":[{"text":"Number of compute units: 1","type":"text"}],"compute_units":1}],"data":[5689.99998,7370.000127,8,20.5],"total_percent":[8.07184,5.19293,3.36309,1.55642,18.75],"total":[5690,7370,8,21],"debug_enabled":"true","columns":["","ALUTs","FFs","RAMs","DSPs","Details"],"type":"module"}';
var mavJSON='{"nodes":[{"type":"component", "id":2, "name":"resize", "children":[{"type":"bb", "id":3, "name":"resize.B0.runOnce", "details":[{"type":"table", "Latency":"2"}]}, {"type":"bb", "id":4, "name":"resize.B1.start", "children":[{"type":"inst", "id":7, "name":"Channel Read", "debug":[[{"filename":"", "line":0}]], "details":[{"type":"table", "Width":"96 bits", "Depth":"0", "Stall-free":"No", "Start Cycle":"2", "Latency":"0"}]}, {"type":"inst", "id":15, "name":"loop", "details":[{"type":"table", "Start Cycle":"0", "Latency":"1", "Loops To":"20"}]}, {"type":"inst", "id":16, "name":"end", "details":[{"type":"table", "Start Cycle":"6", "Latency":"1"}]}], "details":[{"type":"table", "Latency":"6", "II":"1", "Subloops":"Yes", "Pipelined":"Yes", "Fmax Bottlenecks":"No", "Loop Info":"Entry to loop. "}]}, {"type":"bb", "id":5, "name":"resize.B2", "children":[{"type":"inst", "id":9, "name":"Channel Read", "debug":[[{"filename":"resize.cpp", "line":66}]], "details":[{"type":"table", "Width":"32 bits", "Depth":"0", "Stall-free":"No", "Start Cycle":"9", "Latency":"0"}]}, {"type":"inst", "id":11, "name":"Channel Write", "debug":[[{"filename":"resize.cpp", "line":108}]], "details":[{"type":"table", "Width":"32 bits", "Depth":"0", "Stall-free":"No", "Start Cycle":"23", "Latency":"0"}]}, {"type":"inst", "id":17, "name":"loop", "details":[{"type":"table", "Start Cycle":"0", "Latency":"1", "Loops To":"18"}]}, {"type":"inst", "id":18, "name":"loop end", "details":[{"type":"table", "Start Cycle":"23", "Latency":"1"}]}], "details":[{"type":"table", "Latency":"23", "II":"1", "Subloops":"No", "Pipelined":"Yes", "Fmax Bottlenecks":"No", "Loop Info":""}]}, {"type":"bb", "id":6, "name":"resize.B3", "children":[{"type":"inst", "id":13, "name":"Channel Write", "debug":[[{"filename":"", "line":0}]], "details":[{"type":"table", "Width":"8 bits", "Depth":"0", "Stall-free":"No", "Start Cycle":"0", "Latency":"0"}]}, {"type":"inst", "id":19, "name":"begin", "details":[{"type":"table", "Start Cycle":"0", "Latency":"1"}]}, {"type":"inst", "id":20, "name":"loop end", "details":[{"type":"table", "Start Cycle":"1", "Latency":"1"}]}], "details":[{"type":"table", "Latency":"1", "II":"1", "Subloops":"Yes", "Pipelined":"Yes", "Fmax Bottlenecks":"No", "Loop Info":"Exit which branches back to loop. "}]}]}, {"type":"stream", "id":8, "name":"do", "debug":[[{"filename":"resize.cpp", "line":56}]], "details":[{"type":"table", "Width":"96 bits", "Depth":"0", "Bits per symbol":"96 bits", "Uses Packets":"No", "Uses Valid":"Yes"}]}, {"type":"stream", "id":10, "name":"original_image", "debug":[[{"filename":"resize.cpp", "line":56}]], "details":[{"type":"table", "Width":"32 bits", "Depth":"0", "Bits per symbol":"32 bits", "Uses Packets":"No", "Uses Valid":"Yes"}]}, {"type":"stream", "id":12, "name":"resized_image", "debug":[[{"filename":"resize.cpp", "line":56}]], "details":[{"type":"table", "Width":"32 bits", "Depth":"0", "Bits per symbol":"32 bits", "Uses Packets":"No", "Uses Ready":"Yes"}]}, {"type":"stream", "id":14, "name":"return", "debug":[[{"filename":"resize.cpp", "line":56}]], "details":[{"type":"table", "Width":"8 bits", "Depth":"0", "Bits per symbol":"8 bits", "Uses Packets":"No", "Uses Ready":"Yes"}]}, {"type":"interface", "id":23, "name":"cols", "debug":[[{"filename":"resize.cpp", "line":56}]], "details":[{"type":"table", "Stable":"No", "Width":"32 bits", "Component":"resize"}]}, {"type":"interface", "id":21, "name":"ratio", "debug":[[{"filename":"resize.cpp", "line":56}]], "details":[{"type":"table", "Stable":"No", "Width":"32 bits", "Component":"resize"}]}, {"type":"interface", "id":22, "name":"rows", "debug":[[{"filename":"resize.cpp", "line":56}]], "details":[{"type":"table", "Stable":"No", "Width":"32 bits", "Component":"resize"}]}], "links":[{"from":8, "to":7}, {"from":10, "to":9}, {"from":11, "to":12}, {"from":13, "to":14}, {"from":21, "to":7}, {"from":22, "to":7}, {"from":23, "to":7}, {"from":20, "to":15}, {"from":3, "to":15}, {"from":7, "to":16}, {"from":18, "to":17}, {"from":16, "to":17}, {"from":9, "to":18}, {"from":11, "to":18}, {"from":18, "to":19}, {"from":13, "to":20}, {"from":15, "to":7}, {"from":17, "to":9}, {"from":9, "to":11}, {"from":19, "to":13}]}';
var lmvJSON='{"nodes":[{"type":"interface", "id":23, "name":"cols", "debug":[[{"filename":"resize.cpp", "line":56}]], "details":[{"type":"table", "Stable":"No", "Width":"32 bits", "Component":"resize"}]}, {"type":"interface", "id":21, "name":"ratio", "debug":[[{"filename":"resize.cpp", "line":56}]], "details":[{"type":"table", "Stable":"No", "Width":"32 bits", "Component":"resize"}]}, {"type":"interface", "id":22, "name":"rows", "debug":[[{"filename":"resize.cpp", "line":56}]], "details":[{"type":"table", "Stable":"No", "Width":"32 bits", "Component":"resize"}]}], "links":[]}';
var loopsJSON='{"columns":["", "Pipelined", "II", "Bottleneck", "Details"], "children":[{"name":"Component: resize", "data":["", "", ""], "debug":[[{"filename":"resize.cpp", "line":56}]], "details":[{"type":"brief", "text":"Task function"}, {"type":"text", "text":"Task function"}], "children":[{"name":"resize.B1.start", "data":["Yes", ">=1", "n/a"], "debug":[[{"filename":"Component invocation", "line":0}]], "details":[{"type":"brief", "text":" "}, {"type":"text", "text":"Run simulation to verify component\'s dynamic II. Use the %L report to view results. II is an approximation due to variable inner loop trip count.", "links":[{"view":"Verification statistics"}]}], "children":[{"name":"resize.B2", "data":["Yes", "~1", "n/a"], "debug":[[{"filename":"resize.cpp", "line":64}], [{"filename":"resize.cpp", "line":64}], [{"filename":"resize.cpp", "line":118}], [{"filename":"resize.cpp", "line":119}]], "details":[{"type":"brief", "text":"II is an approximation."}, {"type":"text", "text":"Run simulation to verify component\'s dynamic II. Use the %L report to view results. II is an approximation due to the following stallable instructions:", "links":[{"view":"Verification statistics"}], "details":[{"type":"text", "text":"Stream Read Operation (%L)", "links":[{"filename":"resize.cpp", "line":"66"}]}, {"type":"text", "text":"Stream Write Operation (%L)", "links":[{"filename":"resize.cpp", "line":"108"}]}]}], "children":[{"name":"Fully unrolled loop", "data":["n/a", "n/a", "n/a"], "debug":[[{"filename":"resize.cpp", "line":101}]], "details":[{"type":"brief", "text":"Unrolled by #pragma unroll"}, {"type":"text", "text":"Unrolled by #pragma unroll"}], "children":[]}, {"name":"Fully unrolled loop", "data":["n/a", "n/a", "n/a"], "debug":[[{"filename":"resize.cpp", "line":112}]], "details":[{"type":"brief", "text":"Unrolled by #pragma unroll"}, {"type":"text", "text":"Unrolled by #pragma unroll"}], "children":[]}]}]}]}]}';
var summaryJSON='{"estimatedResources":{"name":"Estimated Resource Usage", "columns":["Component Name", "ALUTs ", "FFs  ", "RAMs ", "DSPs "], "children":[{"name":"resize", "data":[5690, 7370, 8, 20.5], "debug":[[{"filename":"resize.cpp", "line":56}]]}, {"name":"Total", "classes":["summary-highlight", "nohover"], "data":[5690, 7370, 8, 20], "data_percent":[5.19293, 3.36309, 1.55642, 18.75]}, {"name":"Available", "classes":["summary-highlight", "nohover"], "data":[109572, 219144, 514, 112]}]}, "compileWarnings":{"name":"Compile Warnings", "children":[]}}';
var infoJSON='{"name":"Info","rows":[{"name":"Project Name","data":["./a"],"classes":["info-table"]},{"name":"Target Family, Device","data":["Cyclone V, 5CEFA9F23I7"]},{"name":"i++ Version","data":["17.1.0 Build 590"]},{"name":"Quartus Version","data":["17.1.0 Build 590"]},{"name":"Command","data":["i++ -ffp-contract=fast -ffp-reassociate -march=CycloneV main.cpp resize.cpp bmp_tools.cpp"]},{"name":"Reports Generated At", "data":["Thu Jan 25 19:12:21 2024"]}]}';
var warningsJSON='{"rows":[]}';
var quartusJSON='{"quartusFitClockSummary":{  "name":"Quartus Fit Clock Summary"  ,"columns":["", "1x clock fmax"]  ,"children":[  {    "name":"Frequency (MHz)","data":[148.96]  }]},"quartusFitResourceUsageSummary":{  "name":"Quartus Fit Resource Utilization Summary"  ,"columns":["", "ALMs", "FFs", "RAMs", "DSPs"]  ,"children":[  {"name":"resize","data":[1173.5 ,2749 ,10 ,17]  }]}}';
var fileJSON=[{"path":"bmp_tools.cpp", "name":"bmp_tools.cpp", "has_active_debug_locs":true, "absName":"c:/intelFPGA/17.1/hls/examples/image_downsample/bmp_tools.cpp", "content":"// bmp_tools.cpp\012\012#include \"bmp_tools.h\"\012#include <stdio.h>\012#include <stdlib.h>\012\012// Bitmap header size in bytes\012static const int BMP_HEADER_SIZE = 54;\012\012void read_bmp (const char* filename, unsigned int** img_data, int& height, int& width) {\012  FILE *fp;\012  if ((fp=fopen(filename,\"rb\"))==NULL) {\012    printf(\"can't open file %s for binary reading\\n\", filename);\012    exit(1);\012  }\012\012  // Skip over unimportant parts of header\012  for (int i=0; i<18; i++) fgetc(fp); \012  \012  //read width and height\012  fread(&width, sizeof(int), 1, fp);\012  fread(&height, sizeof(int), 1, fp);\012  if (height < 0 || width < 0) {\012    printf(\"error got height %d, width %d\\n\", height, width);\012    exit(1);\012  }\012  printf(\"image size is %d (width) by %d (height) pixels\\n\", width, height);\012  *img_data = (unsigned int*) malloc(width * height * sizeof(unsigned int));\012\012  // Skip remaining part of header\012  for (int i=0; i<28; i++) fgetc(fp);\012  \012  // BMP: Each line must be a multiple of 4 bytes\012  int padding = (4-((width*3)&3))&3;\012  int idx=0;      \012  // Color order is BGR, read across bottom row, then repeat going up rows\012  for (int i=0; i< height; ++i) {\012	  for (int j=0; j< width; ++j) {\012      unsigned char b = fgetc(fp); //B\012      unsigned char g = fgetc(fp); //G\012      unsigned char r = fgetc(fp); //R\012      (*img_data)[idx] = (((unsigned int ) r << 16) | ((unsigned int ) g << 8) | ((unsigned int ) b << 0));\012      idx++;\012	  }\012	  // Discard the padding bytes\012	  for (int j=0; j< padding; ++j) {\012	  	unsigned char b = fgetc(fp);\012	  }\012  }\012  fclose(fp);\012}\012\012void write_bmp (const char* filename, unsigned int* img_data, int& height, int& width) {\012  FILE *fp;\012  unsigned int file_size = width * height * 3 + BMP_HEADER_SIZE;\012  unsigned char header[BMP_HEADER_SIZE] = { 0x42, 0x4d,         // BMP & DIB\012                                        (file_size & 0xff), ((file_size >> 8) & 0xff), ((file_size >> 16) & 0xff), ((file_size >> 24) & 0xff), // size of file in bytes\012                                        0x00, 0x00, 0x00, 0x00, // reserved\012                                        0x36, 0x00, 0x00, 0x00, // offset of start of image data\012                                        0x28, 0x00, 0x00, 0x00, // size of the DIB header\012                                        (width & 0xff), ((width >> 8) & 0xff), ((width >> 16) & 0xff), ((width >> 24) & 0xff),     // width in pixels\012                                        (height & 0xff), ((height >> 8) & 0xff), ((height >> 16) & 0xff), ((height >> 24) & 0xff), // height in pixels\012                                        0x01, 0x00, // number of color planes\012                                        0x18, 0x00, // number of bits per pixel\012                                        0x00, 0x00, 0x00, 0x00, // no compression - BI_RGB\012                                        0x00, 0x00, 0x00, 0x00, // image size - dummy 0 for BI_RGB\012                                        0x13, 0x0b, 0x00, 0x00, // horizontal ppm\012                                        0x13, 0x0b, 0x00, 0x00, // vertical ppm\012                                        0x00, 0x00, 0x00, 0x00, // default 2^n colors in palatte\012                                        0x00, 0x00, 0x00, 0x00  // every color is important\012                                      };\012  // Open file for write\012  if ((fp=fopen(filename,\"wb\"))==NULL) { \012    printf(\"can't open file %s for binary writing\\n\", filename); \012    exit(1);\012  }\012\012  // Write header\012  fwrite(header, 1, BMP_HEADER_SIZE, fp);\012\012  // Write data: Line size must be a multiple of 4 bytes\012  int padding = (4-((width*3)&3))&3;\012  int idx = 0;\012  for (int i = 0; i <  height; ++i) {\012    unsigned char p[3];\012    for (int j = 0; j < width ; ++j) {\012      // written in B, G, R order\012      p[0] = (img_data[idx] >>  0) & 0xff; //B\012      p[1] = (img_data[idx] >>  8) & 0xff; //G\012      p[2] = (img_data[idx] >> 16) & 0xff; //R\012      idx++;\012      fwrite(p, 1, 3, fp);\012    }\012    // Pad to multiple of 4 bytes\012    if (padding) {\012    	p[0]=p[1]=p[2]=0;\012    	fwrite(p,1,padding,fp);\012    }\012  }\012  fclose(fp);\012}\012"}, {"path":"bmp_tools.h", "name":"bmp_tools.h", "has_active_debug_locs":false, "absName":"c:/intelFPGA/17.1/hls/examples/image_downsample/bmp_tools.h", "content":"// bmp_tools.h\012#ifndef BMP_TOOLS_H\012#define BMP_TOOLS_H\012\012void read_bmp (const char* filename, unsigned int** img_data, int& height, int& width);\012void write_bmp (const char* filename, unsigned int* img_data, int& height, int& width);\012\012#endif // BMP_TOOLS_H\012"}, {"path":"C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/exception", "name":"exception", "has_active_debug_locs":true, "absName":"c:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/exception", "content":"// exception standard header for Microsoft\012#pragma once\012#ifndef _EXCEPTION_\012#define _EXCEPTION_\012#ifndef RC_INVOKED\012\012#include <xstddef>\012\012 #pragma pack(push,_CRT_PACKING)\012 #pragma warning(push,3)\012\012#ifdef _CRT_EXCEPTION_NO_MALLOC\012\012  #pragma push_macro(\"malloc\")\012  #pragma push_macro(\"free\")\012\012 #undef malloc\012 #undef free\012#endif /* _CRT_EXCEPTION_NO_MALLOC */\012\012_STD_BEGIN\012\012  #define _USE_EXCEPTION \\\012	using _STDEXT exception;\012\012  #define _USE_BAD_EXCEPTION \\\012	using _STDEXT bad_alloc; \\\012	using _STDEXT bad_exception;\012\012  #define _USE_EX \\\012	using ::set_terminate; using ::terminate_handler; using ::terminate; \\\012	using ::set_unexpected; using ::unexpected_handler; using ::unexpected;\012\012_STD_END\012\012 #if _HAS_EXCEPTIONS\012\012 #include <eh.h>\012 #include <malloc.h>\012 #include <string.h>\012\012 #if !defined(_WIN32)\012  #error ERROR: Only Win32 targets supported!\012 #endif /* !defined(_WIN32) */\012\012 #ifndef _CRTIMP\012\012  #ifdef	_DLL\012   #define _CRTIMP __declspec(dllimport)\012\012  #else	/* ndef _DLL */\012   #define _CRTIMP\012  #endif	/* _DLL */\012\012 #endif	/* _CRTIMP */\012\012#ifndef _MCRTIMP\012#ifdef  _DLL\012#define _MCRTIMP __declspec(dllimport)\012#else   /* ndef _DLL */\012#define _MCRTIMP\012#endif  /* _DLL */\012#endif  /* _CRTIMP */\012\012#ifndef _CRTIMP_PURE\012 #if defined(_M_CEE_PURE) || defined(_STATIC_CPPLIB)\012  #define _CRTIMP_PURE\012 #else\012  #define _CRTIMP_PURE _CRTIMP\012 #endif\012#endif\012\012#ifndef _ERRNO_T_DEFINED\012#define _ERRNO_T_DEFINED\012typedef int errno_t;\012#endif\012\012#if __STDC_WANT_SECURE_LIB__\012#define _CRT_SECURE_STRCPY(dest, destsize, source) ::strcpy_s((dest), (destsize), (source))\012#else\012#define _CRT_SECURE_STRCPY(dest, destsize, source) ::strcpy((dest), (source))\012#endif\012\012 _STD_BEGIN\012\012#ifdef _M_CEE_PURE\012 #define _DEFINE_EXCEPTION_MEMBER_FUNCTIONS\012 #define _EXCEPTION_INLINE inline\012#else /* _M_CEE_PURE */\012 #define _EXCEPTION_INLINE\012#endif /* _M_CEE_PURE */\012\012class _CRTIMP_PURE exception\012    {   // base of all library exceptions\012public:\012    _EXCEPTION_INLINE __CLR_OR_THIS_CALL exception();\012    _EXCEPTION_INLINE explicit __CLR_OR_THIS_CALL exception(const char * const &);\012    _EXCEPTION_INLINE __CLR_OR_THIS_CALL exception(const char * const &, int);\012    _EXCEPTION_INLINE __CLR_OR_THIS_CALL exception(const exception&);\012    _EXCEPTION_INLINE exception& __CLR_OR_THIS_CALL operator=(const exception&);\012    _EXCEPTION_INLINE virtual __CLR_OR_THIS_CALL ~exception();\012    _EXCEPTION_INLINE virtual const char * __CLR_OR_THIS_CALL what() const;\012\012private:\012    _EXCEPTION_INLINE void __CLR_OR_THIS_CALL _Copy_str(const char *);\012    _EXCEPTION_INLINE void __CLR_OR_THIS_CALL _Tidy();\012\012    const char * _Mywhat;\012    bool _Mydofree;\012    };\012\012#ifdef _DEFINE_EXCEPTION_MEMBER_FUNCTIONS\012\012_EXCEPTION_INLINE __CLR_OR_THIS_CALL exception::exception()\012    : _Mywhat(NULL), _Mydofree(false) { }\012\012_EXCEPTION_INLINE __CLR_OR_THIS_CALL exception::exception(const char * const & _What)\012    : _Mywhat(NULL), _Mydofree(false)\012    {\012    _Copy_str(_What);\012    }\012\012_EXCEPTION_INLINE __CLR_OR_THIS_CALL exception::exception(const char * const & _What, int)\012    : _Mywhat(_What), _Mydofree(false) { }\012\012_EXCEPTION_INLINE __CLR_OR_THIS_CALL exception::exception(const exception& _That)\012    : _Mywhat(NULL), _Mydofree(false)\012    {\012    *this = _That;\012    }\012\012_EXCEPTION_INLINE exception& __CLR_OR_THIS_CALL exception::operator=(const exception& _That)\012    {\012    if (this != &_That)\012        {\012        _Tidy();\012\012        if (_That._Mydofree)\012            {\012            _Copy_str(_That._Mywhat);\012            }\012        else\012            {\012            _Mywhat = _That._Mywhat;\012            }\012        }\012\012    return *this;\012    }\012\012_EXCEPTION_INLINE __CLR_OR_THIS_CALL exception::~exception()\012    {\012    _Tidy();\012    }\012\012_EXCEPTION_INLINE const char * __CLR_OR_THIS_CALL exception::what() const\012    {\012    return _Mywhat ? _Mywhat : \"Unknown exception\";\012    }\012\012// _Copy_str() assumes that *this is already tidy.\012_EXCEPTION_INLINE void __CLR_OR_THIS_CALL exception::_Copy_str(const char * _What)\012    {\012    if (_What != NULL)\012        {\012        const size_t _Buf_size = strlen(_What) + 1;\012        \012        _Mywhat = static_cast<char *>(malloc(_Buf_size));\012        \012        if (_Mywhat != NULL)\012            {\012            _CRT_SECURE_STRCPY(const_cast<char *>(_Mywhat), _Buf_size, _What);\012            _Mydofree = true;\012            }\012        }\012    }\012\012_EXCEPTION_INLINE void __CLR_OR_THIS_CALL exception::_Tidy()\012    {\012    if (_Mydofree)\012        {\012        free(const_cast<char *>(_Mywhat));\012        }\012\012    _Mywhat = NULL;\012    _Mydofree = false;\012    }\012\012#endif /* _DEFINE_EXCEPTION_MEMBER_FUNCTIONS */\012\012\012_USE_EX\012\012typedef void (__cdecl *_Prhand)(const exception&);\012\012_CRTIMP2 bool __cdecl uncaught_exception();\012\012_STD_END\012\012 #else /* _HAS_EXCEPTIONS */\012\012		// CLASS exception\012_STDEXT_BEGIN\012class exception;\012_STDEXT_END\012\012_STD_BEGIN\012\012_USE_EXCEPTION\012\012typedef void (__cdecl *_Prhand)(const exception&);\012extern _CRTIMP2_NCEEPURE _Prhand _Raise_handler;	// pointer to raise handler\012\012_STD_END\012\012_STDEXT_BEGIN\012class exception\012	{	// base of all library exceptions\012public:\012\012	static _STD _Prhand _Set_raise_handler(_STD _Prhand _Pnew)\012		{	// register a handler for _Raise calls\012		const _STD _Prhand _Pold = _STD _Raise_handler;\012		_STD _Raise_handler = _Pnew;\012		return (_Pold);\012		}\012\012	// this constructor is necessary to compile \012	// successfully header new for _HAS_EXCEPTIONS==0 scenario\012	explicit __CLR_OR_THIS_CALL exception(const char *_Message = \"unknown\", int x=1)\012		_THROW0()\012		: _Ptr(_Message)\012		{	// construct from message string\012                (void)x;\012		}\012\012	__CLR_OR_THIS_CALL exception(const exception& _Right) _THROW0()\012		: _Ptr(_Right._Ptr)\012		{	// construct by copying _Right\012		}\012\012	exception& __CLR_OR_THIS_CALL operator=(const exception& _Right) _THROW0()\012		{	// assign _Right\012		_Ptr = _Right._Ptr;\012		return (*this);\012		}\012\012	virtual __CLR_OR_THIS_CALL ~exception()\012		{	// destroy the object\012		}\012\012	virtual const char * __CLR_OR_THIS_CALL what() const _THROW0()\012		{	// return pointer to message string\012		return (_Ptr != 0 ? _Ptr : \"unknown exception\");\012		}\012\012	void __CLR_OR_THIS_CALL _Raise() const\012		{	// raise the exception\012		if (_STD _Raise_handler != 0)\012			(*_STD _Raise_handler)(*this);	// call raise handler if present\012\012		_Doraise();	// call the protected virtual\012		_RAISE(*this);	// raise this exception\012		}\012\012protected:\012	virtual void __CLR_OR_THIS_CALL _Doraise() const\012		{	// perform class-specific exception handling\012		}\012\012protected:\012	const char *_Ptr;	// the message pointer\012	};\012_STDEXT_END\012\012_STD_BEGIN\012\012		// TYPES\012typedef void (__cdecl *terminate_handler)();\012typedef void (__cdecl *unexpected_handler)();\012\012		// DUMMY FUNCTION DECLARATIONS\012inline terminate_handler __CRTDECL set_terminate(terminate_handler)\012	_THROW0()\012	{	// register a terminate handler\012	return 0;\012	}\012\012inline unexpected_handler __CRTDECL set_unexpected(unexpected_handler)\012	_THROW0()\012	{	// register an unexpected handler\012	return 0;\012	}\012\012inline void __CRTDECL terminate()\012	{	// handle exception termination\012	}\012\012inline void __CRTDECL unexpected()\012	{	// handle unexpected exception\012	}\012\012_CRTIMP2 bool __cdecl uncaught_exception();	// handle uncaught exception\012\012_STD_END\012\012 #endif /* _HAS_EXCEPTIONS */\012\012#if _HAS_EXCEPTIONS\012_STD_BEGIN\012#else\012_STDEXT_BEGIN\012#endif\012\012		// CLASS bad_exception\012class bad_exception : public exception\012	{	// base of all bad exceptions\012public:\012	__CLR_OR_THIS_CALL bad_exception(const char *_Message = \"bad exception\")\012		_THROW0()\012		: exception(_Message)\012		{	// construct from message string\012		}\012\012	virtual __CLR_OR_THIS_CALL ~bad_exception() _THROW0()\012		{	// destroy the object\012		}\012\012 #if !_HAS_EXCEPTIONS\012protected:\012	virtual void __CLR_OR_THIS_CALL _Doraise() const\012		{	// raise this exception\012		_RAISE(*this);\012		}\012 #endif /* _HAS_EXCEPTIONS */\012\012	};\012\012		// CLASS bad_alloc\012class bad_alloc : public exception\012	{	// base of all bad allocation exceptions\012public:\012	__CLR_OR_THIS_CALL bad_alloc(const char *_Message) _THROW0()\012		: exception(_Message)\012		{	// construct from message string\012		}\012\012	__CLR_OR_THIS_CALL bad_alloc() _THROW0()\012		: exception(\"bad allocation\", 1)\012		{	// construct from message string with no memory allocation\012		}\012\012	virtual __CLR_OR_THIS_CALL ~bad_alloc() _THROW0()\012		{	// destroy the object\012		}\012\012 #if !_HAS_EXCEPTIONS\012protected:\012	virtual void __CLR_OR_THIS_CALL _Doraise() const\012		{	// perform class-specific exception handling\012		_RAISE(*this);\012		}\012#endif  /* _HAS_EXCEPTIONS */\012\012	};\012\012#if _HAS_CPP0X\012		// CLASS bad_array_new_length\012class bad_array_new_length\012	: public bad_alloc\012	{	// bad array new exception\012public:\012\012	bad_array_new_length() _THROW0()\012		: bad_alloc(\"bad array new length\")\012		{	// default construct\012		}\012	};\012#endif /* _HAS_CPP0X */\012\012#if _HAS_EXCEPTIONS\012_STD_END\012#else\012_STDEXT_END\012\012_STD_BEGIN\012\012_USE_BAD_EXCEPTION\012\012_STD_END\012\012#endif\012\012_CRTIMP_PURE void __CLRCALL_PURE_OR_CDECL __ExceptionPtrCreate(_Out_ void* );\012_CRTIMP_PURE void __CLRCALL_PURE_OR_CDECL __ExceptionPtrDestroy(_Inout_ void* );\012_CRTIMP_PURE void __CLRCALL_PURE_OR_CDECL __ExceptionPtrCopy(_Out_ void*, _In_ const void* );\012_CRTIMP_PURE void __CLRCALL_PURE_OR_CDECL __ExceptionPtrAssign(_Inout_ void*, _In_ const void* );\012_CRTIMP_PURE bool __CLRCALL_PURE_OR_CDECL __ExceptionPtrCompare(_In_ const void*, _In_ const void*);\012\012_CRTIMP_PURE void __CLRCALL_PURE_OR_CDECL __ExceptionPtrCurrentException(_Out_ void*);\012_CRTIMP_PURE void __CLRCALL_PURE_OR_CDECL __ExceptionPtrRethrow(_In_ const void*);\012_CRTIMP_PURE void __CLRCALL_PURE_OR_CDECL __ExceptionPtrCopyException(_Inout_ void*, _In_ const void*, _In_ const void*);\012\012_STD_BEGIN\012\012#if defined(_NATIVE_NULLPTR_SUPPORTED) && !defined(_DO_NOT_USE_NULLPTR_IN_STL)\012typedef _STD nullptr_t _Null_type;\012#else /* defined(_NATIVE_NULLPTR_SUPPORTED) && !defined(_DO_NOT_USE_NULLPTR_IN_STL) */\012typedef int _Null_type;\012#endif /* defined(_NATIVE_NULLPTR_SUPPORTED) && !defined(_DO_NOT_USE_NULLPTR_IN_STL) */\012\012class _Exception_ptr\012	{\012public:\012	_Exception_ptr()\012		{\012		__ExceptionPtrCreate(this);\012		}\012	_Exception_ptr(_Null_type)\012		{\012		__ExceptionPtrCreate(this);\012		}\012	~_Exception_ptr()\012		{\012		__ExceptionPtrDestroy(this);\012		}\012	_Exception_ptr(_In_ const _Exception_ptr& _Rhs)\012		{\012		__ExceptionPtrCopy(this, const_cast<_Exception_ptr*>(&_Rhs));\012		}\012	_Exception_ptr& operator=(_In_ const _Exception_ptr& _Rhs)\012		{\012		__ExceptionPtrAssign(this, const_cast<_Exception_ptr*>(&_Rhs));\012		return *this;\012		}\012	_Exception_ptr& operator=(_Null_type)\012		{\012		_Exception_ptr _Ptr;\012		__ExceptionPtrAssign(this, &_Ptr);\012		return *this;\012		}\012\012	void _RethrowException() const\012		{\012		__ExceptionPtrRethrow(const_cast<_Exception_ptr*>(this));\012		}\012\012	static _Exception_ptr _Current_exception()\012		{\012		_Exception_ptr _Retval;\012		__ExceptionPtrCurrentException(&_Retval);\012		return _Retval;\012		}\012	static _Exception_ptr _Copy_exception(_In_ void* _Except, _In_ const void* _Ptr)\012		{\012		_Exception_ptr _Retval = NULL;\012		if (!_Ptr)\012			{\012			// unsupported exceptions\012			return _Retval;\012			}\012		__ExceptionPtrCopyException(&_Retval, _Except, _Ptr);\012		return _Retval;\012		}\012private:\012	void* _Data1;\012	void* _Data2;\012	};\012\012inline bool operator==(_In_ const _Exception_ptr& _Lhs, _In_ const _Exception_ptr& _Rhs)\012	{\012	return __ExceptionPtrCompare(const_cast<_Exception_ptr*>(&_Lhs),const_cast<_Exception_ptr*>(&_Rhs));\012	}\012\012inline bool operator==(_Null_type, _In_ const _Exception_ptr& _Rhs)\012	{\012	_Exception_ptr _Ptr;\012	return __ExceptionPtrCompare(&_Ptr,const_cast<_Exception_ptr*>(&_Rhs));\012	}\012\012inline bool operator==(_In_ const _Exception_ptr& _Lhs, _Null_type)\012	{\012	return operator==(NULL,_Lhs);\012	}\012\012typedef _Exception_ptr exception_ptr;\012\012inline exception_ptr current_exception()\012	{\012	return _Exception_ptr::_Current_exception();\012	}\012\012inline void rethrow_exception(_In_ exception_ptr _P)\012	{\012	_P._RethrowException();\012	}\012\012template <class _E> void *__GetExceptionInfo(_E);\012\012template<class _E> exception_ptr copy_exception(_E _Except)\012	{\012	return _Exception_ptr::_Copy_exception(&_Except, __GetExceptionInfo(_Except));\012	}\012\012_STD_END\012\012\012#ifdef _CRT_EXCEPTION_NO_MALLOC\012  #pragma pop_macro(\"free\")\012  #pragma pop_macro(\"malloc\")\012#endif /* _CRT_EXCEPTION_NO_MALLOC */\012\012 #pragma warning(pop)\012 #pragma pack(pop)\012\012#endif /* RC_INVOKED */\012#endif /* _EXCEPTION_ */\012\012/*\012 * Copyright (c) 1992-2007 by P.J. Plauger.  ALL RIGHTS RESERVED.\012 * Consult your license regarding permissions and restrictions.\012 V5.03:0009 */\012"}, {"path":"C:/intelFPGA/17.1/hls/include/HLS/hls.h", "name":"hls.h", "has_active_debug_locs":true, "absName":"c:/intelFPGA/17.1/hls/include/HLS/hls.h", "content":"#ifndef __HLS_H__\012#define __HLS_H__\012\012#ifndef __INTELFPGA_COMPILER__\012#ifndef component\012#define component\012#endif\012#define HLS_X86\012#endif\012\012#include \"HLS/hls_internal.h\"\012\012/* Deprecated APIs and names after intel rebranding */\012#ifdef __IHC_USE_DEPRECATED_NAMES\012#pragma message \"Warning: Enabling deprecated names - these names will not be supported in future releases.\"\012namespace ihc {}\012namespace altera = ihc;\012#define altera_hls_component_run_all ihc_hls_component_run_all\012#define altera_fence ihc_fence\012#define altera_hls_get_sim_time ihc_hls_get_sim_time\012#define altera_hls_enqueue ihc_hls_enqueue\012#define altera_hls_enqueue_noret ihc_hls_enqueue_noret\012#endif\012\012#ifdef __INTELFPGA_COMPILER__\012// Memory attributes\012#define hls_register                                  __attribute__((__register__))\012#define hls_memory                                    __attribute__((__memory__))\012#define hls_numbanks(__x)                             __attribute__((__numbanks__(__x)))\012#define hls_bankwidth(__x)                            __attribute__((__bankwidth__(__x)))\012#define hls_singlepump                                __attribute__((__singlepump__))\012#define hls_doublepump                                __attribute__((__doublepump__))\012#define hls_numports_readonly_writeonly(__rd, __wr)   __attribute__((__numports_readonly_writeonly__(__rd, __wr)))\012#define hls_bankbits(__x, ...)                        __attribute__((__bank_bits__(__x, ##__VA_ARGS__)))\012#define hls_merge(__x, __y)                           __attribute__((merge(__x, __y)))\012#define hls_init_on_reset                             __attribute__((__static_array_reset__(1)))\012#define hls_init_on_powerup                           __attribute__((__static_array_reset__(0)))\012#define hls_numreadports(__x)                         __attribute__((__numreadports__(__x)))\012#define hls_numwriteports(__x)                        __attribute__((__numwriteports__(__x)))\012\012// Memory attribute macros\012#define hls_simple_dual_port_memory hls_memory hls_singlepump hls_numports_readonly_writeonly(1,1)\012\012// Interface synthesis attributes\012#define hls_avalon_streaming_component         __attribute__((component_interface(\"avalon_streaming\")))\012#define hls_avalon_slave_component             __attribute__((component_interface(\"avalon_mm_slave\"))) __attribute__((stall_free_return))\012#define hls_always_run_component               __attribute__((component_interface(\"always_run\"))) __attribute__((stall_free_return))\012#define hls_conduit_argument                   __attribute__((argument_interface(\"wire\")))\012#define hls_avalon_slave_register_argument     __attribute__((argument_interface(\"avalon_mm_slave\")))\012#define hls_avalon_slave_memory_argument(__x)  __attribute__((local_mem_size(__x))) __attribute__((slave_memory_argument))\012#define hls_stable_argument                    __attribute__((stable_argument))\012#define hls_stall_free_return                  __attribute__((stall_free_return))\012\012// Component attributes\012#define hls_max_concurrency(__x)               __attribute__((max_concurrency(__x)))\012\012#else\012#define hls_register\012#define hls_memory\012#define hls_numbanks(__x)\012#define hls_bankwidth(__x)\012#define hls_singlepump\012#define hls_doublepump\012#define hls_numports_readonly_writeonly(__rd, __wr)\012#define hls_bankbits(__x, ...)\012#define hls_merge(__x, __y)\012#define hls_init_on_reset\012#define hls_init_on_powerup\012\012#define hls_numreadports(__x)\012#define hls_numwriteports(__x)\012\012#define hls_simple_dual_port_memory\012\012#define hls_avalon_streaming_component\012#define hls_avalon_slave_component\012#define hls_always_run_component\012#define hls_conduit_argument\012#define hls_avalon_slave_register_argument\012#define hls_avalon_slave_memory_argument(__x)\012#define hls_stable_argument\012#define hls_stall_free_return\012\012#define hls_max_concurrency(__x)\012\012#endif\012\012////////////////////////////////////////////////////////////////////////////////\012// Interfaces Declarations\012////////////////////////////////////////////////////////////////////////////////\012\012namespace ihc {\012\012  ////////////////////////////////\012 /// memory master interface  ///\012////////////////////////////////\012\012template <int n>         class dwidth:public internal::param {};\012template <int n>         class awidth:public internal::param {};\012template <int n>         class latency: public internal::param {};\012template <readwrite_t n> class readwrite_mode: public internal::param{}; // declared in hls_internal.h as enum readwrite_t {readwrite = 0, readonly = 1, writeonly = 2};\012template <int n>         class maxburst: public internal::param {};\012template <int n>         class align: public internal::param {};\012template <int n>         class aspace: public internal::param {};\012template <bool n>        class waitrequest: public internal::param{};\012\012template <typename DT, typename p1 = internal::notinit, typename p2 = internal::notinit, typename p3 = internal::notinit, typename p4 = internal::notinit, typename p5 = internal::notinit, typename p6 = internal::notinit, typename p7 = internal::notinit, typename p8 = internal::notinit>\012class mm_master\012#ifdef HLS_X86\012  : public internal::memory_base\012#endif\012{\012public:\012\012#ifdef HLS_X86\012  template<typename T> explicit mm_master(T *data, int size=0, bool use_socket=false):internal::memory_base(data,size,sizeof(DT),use_socket) {\012  }\012#else\012  template<typename T> explicit mm_master(T *data, int size=0, bool use_socket=false);\012#endif\012\012  //////////////////////////////////////////////////////////////////////////////\012  // The following operators apply to the mm_master object and are only\012  // supported in the testbench:\012  //   mm_master()\012  //   getInterfaceAtIndex()\012  //////////////////////////////////////////////////////////////////////////////\012  // The following operators apply to the base pointer and should only be used\012  // in the component:\012  //   operator[]()\012  //   operator*()\012  //   operator->()\012  //   operator T()\012  //   operator+()\012  //   operator&()\012  //   operator|()\012  //   operator^()\012  //////////////////////////////////////////////////////////////////////////////\012\012  DT &operator[](int index);\012  DT &operator*();\012  DT *operator->();\012  template<typename T> operator T();\012  DT *operator+(int index);\012  template<typename T> DT *operator&(T value);\012  template<typename T> DT *operator|(T value);\012  template<typename T> DT *operator^(T value);\012  // This function is only supported in the testbench:\012  mm_master<DT, p1, p2, p3, p4, p5, p6, p7, p8>& getInterfaceAtIndex(int index);\012\012#ifdef HLS_X86\012  // The copy constructor and assignment operator are necessary to ensure\012  // new_masters doesn't get copied.\012  mm_master(const mm_master &other) {\012    mem = other.mem;\012    size = other.size;\012    data_size = other.data_size;\012    use_socket = other.use_socket;\012  }\012  mm_master& operator=(const mm_master& other) {\012    mem = other.mem;\012    size = other.size;\012    data_size = other.data_size;\012    use_socket = other.use_socket;\012  }\012  // Clean up any derrived mm_masters when this object is destroyed.\012  ~mm_master() {\012    for(std::vector<internal::memory_base* >::iterator it = new_masters.begin(),\012        ie = new_masters.end(); it != ie; it++) {\012      delete *it;\012    }\012    new_masters.clear();\012  }\012private:\012  std::vector<internal::memory_base* > new_masters;\012#endif\012\012};\012\012  /////////////////////////////\012 /// streaming interfaces  ///\012//////////////////////////////\012\012template <int n> class buffer:public internal::param {};\012template <int n> class readyLatency:public internal::param {};\012template <int n> class bitsPerSymbol:public internal::param {};\012template <bool b> class usesPackets:public internal::param {};\012template <bool b> class usesValid:public internal::param {};\012template <bool b> class usesReady:public internal::param {};\012\012template <typename T, typename p1 = internal::notinit , typename p2 = internal::notinit, typename p3 = internal::notinit, typename p4 = internal::notinit, typename p5 = internal::notinit>\012class stream_in : public internal::stream<T,p1,p2,p3,p4,p5> {\012public:\012  stream_in();\012  T read();\012  void write(T arg);\012  T tryRead(bool &success);\012  bool tryWrite(T arg);\012\012  // for packet based stream\012  T read(bool& sop, bool& eop);\012  void write(T arg, bool sop, bool eop);\012  T tryRead(bool &success, bool& sop, bool& eop);\012  bool tryWrite(T arg, bool sop, bool eop);\012  void setStallCycles(unsigned average_stall, unsigned stall_delta=0);\012  void setValidCycles(unsigned average_valid, unsigned valid_delta=0);\012};\012\012template <typename T, typename p1 = internal::notinit , typename p2 = internal::notinit, typename p3 = internal::notinit, typename p4 = internal::notinit, typename p5 = internal::notinit>\012class stream_out : public internal::stream<T,p1,p2,p3,p4,p5> {\012\012public:\012  stream_out();\012  T read();\012  void write(T);\012  T tryRead(bool &success);\012  bool tryWrite(T arg);\012\012  // for packet based stream\012  T read(bool& sop, bool& eop);\012  void write(T arg, bool sop, bool eop);\012  T tryRead(bool &success, bool& sop, bool& eop);\012  bool tryWrite(T arg, bool sop, bool eop);\012  void setStallCycles(unsigned average_stall, unsigned stall_delta=0);\012  void setReadyCycles(unsigned average_ready, unsigned ready_delta=0);\012};\012\012}//namespace ihc\012\012////////////////////////////////////////////////////////////////////////////////\012// HLS Cosimulation Support API\012////////////////////////////////////////////////////////////////////////////////\012\012#define ihc_hls_enqueue(retptr, func, ...) \\\012  { \\\012    if (__ihc_hls_async_call_capable()){ \\\012      __ihc_enqueue_handle=(retptr); \\\012      (void) (*(func))(__VA_ARGS__); \\\012      __ihc_enqueue_handle=0; \\\012    } else { \\\012      *(retptr) = (*(func))(__VA_ARGS__); \\\012    } \\\012  }\012\012#define ihc_hls_enqueue_noret(func, ...) \\\012  { \\\012  __ihc_enqueue_handle=& __ihc_enqueue_handle; \\\012  (*(func))(__VA_ARGS__); \\\012  __ihc_enqueue_handle=0; \\\012  }\012\012#define ihc_hls_component_run_all(component_address) \\\012  __ihc_hls_component_run_all((void*) (component_address))\012\012// When running a simulation, this function will issue a reset to all components\012// in the testbench\012// Returns: 0 if reset did not occur (ie. if the component target is x86)\012//          1 if reset occured (ie. if the component target is an FPGA)\012extern \"C\" int ihc_hls_sim_reset(void);\012\012////////////////////////////////////////////////////////////////////////////////\012// HLS Component Built-Ins\012////////////////////////////////////////////////////////////////////////////////\012\012//Builtin memory fence function call\012#ifdef HLS_X86\012inline void ihc_fence() {};\012\012#else\012extern \"C\" void mem_fence(int);\012inline void ihc_fence() {\012  // fence on all types of fences from OpenCL\012  mem_fence(-1);\012}\012#endif\012\012////////////////////////////////////////////////////////////////////////////////\012// Implementions, no declarations below\012////////////////////////////////////////////////////////////////////////////////\012\012namespace ihc {\012#ifdef HLS_X86\012\012  //////////////////\012 /// mm_master  ///\012//////////////////\012\012template <typename DT, typename p1, typename p2, typename p3, typename p4, typename p5, typename p6, typename p7, typename p8>\012DT &mm_master<DT, p1, p2, p3, p4, p5, p6, p7, p8>::operator[](int index) {\012  assert(size==0 || index*data_size<size);\012  return ((DT*)mem)[index];\012}\012\012template <typename DT, typename p1, typename p2, typename p3, typename p4, typename p5, typename p6, typename p7, typename p8>\012DT &mm_master<DT, p1, p2, p3, p4, p5, p6, p7, p8>::operator*() {\012  return ((DT*)mem)[0];\012}\012\012template <typename DT, typename p1, typename p2, typename p3, typename p4, typename p5, typename p6, typename p7, typename p8>\012DT *mm_master<DT, p1, p2, p3, p4, p5, p6, p7, p8>::operator->() {\012  return (DT*)mem;\012}\012\012template <typename DT, typename p1, typename p2, typename p3, typename p4, typename p5, typename p6, typename p7, typename p8>\012template<typename T> mm_master<DT, p1, p2, p3, p4, p5, p6, p7, p8>::operator T() {\012  return (T)((unsigned long long)mem);\012}\012\012template <typename DT, typename p1, typename p2, typename p3, typename p4, typename p5, typename p6, typename p7, typename p8>\012DT *mm_master<DT, p1, p2, p3, p4, p5, p6, p7, p8>::operator+(int index) {\012  assert(size==0 || index*data_size<size);\012  return &((DT*)mem)[index];\012}\012\012// Bitwise operators\012template <typename DT, typename p1, typename p2, typename p3, typename p4, typename p5, typename p6, typename p7, typename p8>\012template<typename T> DT *mm_master<DT, p1, p2, p3, p4, p5, p6, p7, p8>::operator&(T value) {\012  return (DT*)((unsigned long long)mem & (unsigned long long)value);\012}\012\012template <typename DT, typename p1, typename p2, typename p3, typename p4, typename p5, typename p6, typename p7, typename p8>\012template<typename T> DT *mm_master<DT, p1, p2, p3, p4, p5, p6, p7, p8>::operator|(T value) {\012  return (DT*)((unsigned long long)mem | (unsigned long long)value);\012}\012\012template <typename DT, typename p1, typename p2, typename p3, typename p4, typename p5, typename p6, typename p7, typename p8>\012template<typename T> DT *mm_master<DT, p1, p2, p3, p4, p5, p6, p7, p8>::operator^(T value) {\012  return (DT*)((unsigned long long)mem ^ (unsigned long long)value);\012}\012\012// Function for creating new mm_master at an offset\012template <typename DT, typename p1, typename p2, typename p3, typename p4, typename p5, typename p6, typename p7, typename p8>\012mm_master<DT, p1, p2, p3, p4, p5, p6, p7, p8>& mm_master<DT, p1, p2, p3, p4, p5, p6, p7, p8>::getInterfaceAtIndex(int index) {\012  assert(size==0 || index*data_size<size);\012  // This new object is cleaned up when this' destructor is called.\012  mm_master<DT, p1, p2, p3, p4, p5, p6, p7, p8> *temp = new mm_master(&(((DT*)mem)[index]), size - index * sizeof(DT), use_socket);\012  new_masters.push_back(temp);\012  return *temp;\012}\012\012  ///////////////////\012 /// stream_in   ///\012///////////////////\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012stream_in<T,p1,p2,p3,p4,p5>::stream_in() {}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012T stream_in<T,p1,p2,p3,p4,p5>::tryRead(bool &success) {\012  success = !internal::stream<T,p1,p2,p3,p4,p5>::_internal_cosim_empty();\012  if (success) {\012    return read();\012  } else {\012    return T();\012  }\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012T stream_in<T,p1,p2,p3,p4,p5>::read() {\012    T elem = internal::stream<T,p1,p2,p3,p4,p5>::read();\012    return elem;\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012bool stream_in<T,p1,p2,p3,p4,p5>::tryWrite(T arg) {\012  bool success = true; /* stl::queue has no full */\012  if (success) {\012    write(arg);\012  }\012  return success;\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012void stream_in<T,p1,p2,p3,p4,p5>::write(T arg) {\012    internal::stream<T,p1,p2,p3,p4,p5>::write(arg);\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012T stream_in<T,p1,p2,p3,p4,p5>::tryRead(bool &success, bool& sop, bool& eop) {\012  success = !internal::stream<T,p1,p2,p3,p4,p5>::_internal_cosim_empty();\012  if (success) {\012    return read(sop, eop);\012  } else {\012    return T();\012  }\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012T stream_in<T,p1,p2,p3,p4,p5>::read(bool& sop, bool& eop) {\012    T elem = internal::stream<T,p1,p2,p3,p4,p5>::read(sop, eop);\012    return elem;\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012bool stream_in<T,p1,p2,p3,p4,p5>::tryWrite(T arg, bool sop, bool eop) {\012  bool success = true; /* stl::queue has no full */\012  if (success) {\012    write(arg, sop, eop);\012  }\012  return success;\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012void stream_in<T,p1,p2,p3,p4,p5>::write(T arg, bool sop, bool eop) {\012    internal::stream<T,p1,p2,p3,p4,p5>::write(arg, sop, eop);\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012void stream_in<T,p1,p2,p3,p4,p5>::setStallCycles(unsigned average_stall, unsigned stall_delta) {\012  if (stall_delta > average_stall) {\012    __ihc_hls_runtime_error_x86(\"The stall delta in setStallCycles cannot be larger than the average stall value\");\012  }\012  internal::stream<T,p1,p2,p3,p4,p5>::setStallCycles(average_stall, stall_delta);\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012void stream_in<T,p1,p2,p3,p4,p5>::setValidCycles(unsigned average_valid, unsigned valid_delta) {\012  if (average_valid == 0) {\012    __ihc_hls_runtime_error_x86(\"The valid average in setValidCycles must be at least 1\");\012  }\012  if (valid_delta > average_valid) {\012    __ihc_hls_runtime_error_x86(\"The valid delta in setValidCycles cannot be larger than the average valid value\");\012  }\012  internal::stream<T,p1,p2,p3,p4,p5>::setReadyorValidCycles(average_valid, valid_delta);\012}\012\012  ///////////////////\012 /// stream_out  ///\012///////////////////\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012stream_out<T,p1,p2,p3,p4,p5>::stream_out() {\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012T stream_out<T,p1,p2,p3,p4,p5>::tryRead(bool &success) {\012  success = !internal::stream<T,p1,p2,p3,p4,p5>::_internal_cosim_empty();\012  if (success) {\012    return read();\012  } else {\012    return T();\012  }\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012T stream_out<T,p1,p2,p3,p4,p5>::read() {\012    T elem = internal::stream<T,p1,p2,p3,p4,p5>::read();\012    return elem;\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012void stream_out<T,p1,p2,p3,p4,p5>::write(T arg) {\012    internal::stream<T,p1,p2,p3,p4,p5>::write(arg);\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012bool stream_out<T,p1,p2,p3,p4,p5>::tryWrite(T arg) {\012  bool success = true; /* stl::queue has no full */\012  if (success) {\012    write(arg);\012  }\012  return success;\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012T stream_out<T,p1,p2,p3,p4,p5>::tryRead(bool &success, bool& sop, bool& eop) {\012  success = !internal::stream<T,p1,p2,p3,p4,p5>::_internal_cosim_empty();\012  if (success) {\012    return read(sop, eop);\012  } else {\012    return T();\012  }\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012T stream_out<T,p1,p2,p3,p4,p5>::read(bool& sop, bool& eop) {\012    T elem = internal::stream<T,p1,p2,p3,p4,p5>::read(sop, eop);\012    return elem;\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012void stream_out<T,p1,p2,p3,p4,p5>::write(T arg, bool sop, bool eop) {\012    internal::stream<T,p1,p2,p3,p4,p5>::write(arg, sop, eop);\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012bool stream_out<T,p1,p2,p3,p4,p5>::tryWrite(T arg, bool sop, bool eop) {\012  bool success = true; /* stl::queue has no full */\012  if (success) {\012    write(arg, sop, eop);\012  }\012  return success;\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012void stream_out<T,p1,p2,p3,p4,p5>::setStallCycles(unsigned average_stall, unsigned stall_delta) {\012  if (stall_delta > average_stall) {\012    __ihc_hls_runtime_error_x86(\"The stall delta in setStallCycles cannot be larger than the average stall value\");\012  }\012  internal::stream<T,p1,p2,p3,p4,p5>::setStallCycles(average_stall, stall_delta);\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012void stream_out<T,p1,p2,p3,p4,p5>::setReadyCycles(unsigned average_ready, unsigned ready_delta) {\012  if (average_ready == 0) {\012    __ihc_hls_runtime_error_x86(\"The ready average in setReadCycles must be at least 1\");\012  }\012  if (ready_delta > average_ready) {\012    __ihc_hls_runtime_error_x86(\"The ready delta in setReadyCycles cannot be larger than the average ready value\");\012  }\012  internal::stream<T,p1,p2,p3,p4,p5>::setReadyorValidCycles(average_ready, ready_delta);\012}\012#else //fpga path. Ignore the class just return a consistant pointer/reference\012\012  //////////////////\012 /// mm_master  ///\012//////////////////\012\012template <typename DT, typename p1, typename p2, typename p3, typename p4, typename p5, typename p6, typename p7, typename p8>\012DT &mm_master<DT, p1, p2, p3, p4, p5, p6, p7, p8>::operator[](int index) {\012  return ((DT*)this)[index];\012}\012\012template <typename DT, typename p1, typename p2, typename p3, typename p4, typename p5, typename p6, typename p7, typename p8>\012DT &mm_master<DT, p1, p2, p3, p4, p5, p6, p7, p8>::operator*(){\012  return *((DT*)this);\012}\012\012template <typename DT, typename p1, typename p2, typename p3, typename p4, typename p5, typename p6, typename p7, typename p8>\012DT *mm_master<DT, p1, p2, p3, p4, p5, p6, p7, p8>::operator->() {\012  return (DT*)this;\012}\012\012template <typename DT, typename p1, typename p2, typename p3, typename p4, typename p5, typename p6, typename p7, typename p8>\012DT *mm_master<DT, p1, p2, p3, p4, p5, p6, p7, p8>::operator+(int index) {\012  return ((DT*)this)+index;\012}\012\012template <typename DT, typename p1, typename p2, typename p3, typename p4, typename p5, typename p6, typename p7, typename p8>\012template<typename T> mm_master<DT, p1, p2, p3, p4, p5, p6, p7, p8>::operator T() {\012  return (T)((unsigned long long)this);\012}\012\012// Bitwise operators\012template <typename DT, typename p1, typename p2, typename p3, typename p4, typename p5, typename p6, typename p7, typename p8>\012template<typename T> DT *mm_master<DT, p1, p2, p3, p4, p5, p6, p7, p8>::operator&(T value) {\012  return (DT*)((unsigned long long)this & (unsigned long long)value);\012}\012\012template <typename DT, typename p1, typename p2, typename p3, typename p4, typename p5, typename p6, typename p7, typename p8>\012template<typename T> DT *mm_master<DT, p1, p2, p3, p4, p5, p6, p7, p8>::operator|(T value) {\012  return (DT*)((unsigned long long)this | (unsigned long long)value);\012}\012\012template <typename DT, typename p1, typename p2, typename p3, typename p4, typename p5, typename p6, typename p7, typename p8>\012template<typename T> DT *mm_master<DT, p1, p2, p3, p4, p5, p6, p7, p8>::operator^(T value) {\012  return (DT*)((unsigned long long)this ^ (unsigned long long)value);\012}\012\012#endif\012} // namespace ihc\012\012#endif\012\012"}, {"path":"C:/intelFPGA/17.1/hls/include/HLS/hls_internal.h", "name":"hls_internal.h", "has_active_debug_locs":true, "absName":"c:/intelFPGA/17.1/hls/include/HLS/hls_internal.h", "content":"#ifndef __HLS_INTERNAL_H__\012#define __HLS_INTERNAL_H__\012\012#ifdef HLS_X86\012#include <queue>\012#include <string.h> //memcpy\012#include <assert.h>\012#endif\012#include <stdio.h>\012#include <stdlib.h>\012\012#if defined(__clang__) //our llvm defines _MSC_VER so check this first\012  #define WINDOWSWEAK\012  #define LINUXWEAK __attribute__((weak))\012#elif defined(_MSC_VER)\012  #define WINDOWSWEAK __declspec(selectany)\012  #define LINUXWEAK\012#else\012  #define WINDOWSWEAK\012  #define LINUXWEAK __attribute__((weak))\012#endif\012\012WINDOWSWEAK void *__ihc_enqueue_handle LINUXWEAK;\012\012extern \"C\" unsigned long long ihc_hls_get_sim_time(void);\012extern \"C\" int __ihc_hls_get_clock_period_ps(void);\012extern \"C\" int __ihc_hls_component_start_sim_task(const char *component_name);\012extern \"C\" int __ihc_hls_component_wait_sim_task(const char *component_name, int component_call_count);\012extern \"C\" void __ihc_hls_stream_sink_wait_sim_task(void* obj_ptr);\012extern \"C\" void __ihc_hls_component_run_all(const void* component_address);\012\012// Cosim internal support calls\012extern \"C\" int __ihc_hls_async_call_capable(void);\012// Print error message and bail\012extern \"C\" void __ihc_hls_runtime_error(const char *msg);\012inline void __ihc_hls_runtime_error_x86(const char *msg){\012  printf(\"Error: %s\\n\",msg);\012  exit(1);\012}\012\012enum readwrite_t {readwrite = 0, readonly = 1, writeonly = 2};\012\012namespace ihc {\012// Forward declarations so I can make them friends\012template <typename DT, typename p1, typename p2, typename p3, typename p4, typename p5, typename p6, typename p7, typename p8> class mm_master;\012template <typename T, typename p1, typename p2, typename p3, typename p4, typename p5> class stream_in;\012template <typename T, typename p1, typename p2, typename p3, typename p4, typename p5> class stream_out;\012\012namespace internal {\012\012\012// Interface parameter base types used to define interfaces\012class param {};\012class notinit:public param {};\012\012class memory_base {\012private:\012#ifdef HLS_X86\012  // Attributes\012  int aspace; \012  int awidth;\012  int dwidth;\012  int latency;\012  readwrite_t readwrite_mode;\012  bool byteenabled;\012  int maxburst;\012  int align;\012  bool waitrequest;\012  \012  size_t sim_base;\012  // Extra cosim book keeping\012  size_t data_size; //size of the underlying type used by the interface\012  void *mem;\012  size_t size;\012  bool use_socket; // if true, all reads and writes will go through the IPC socket instead of shared memory\012\012  //Make sure only the listed classes can reach the destructor, and nothing derived from them\012  ~memory_base() {}; // Cannot inherit from HLS interface\012  template <typename DT, typename p1, typename p2, typename p3, typename p4, typename p5, typename p6, typename p7, typename p8> friend class ::ihc::mm_master;\012\012  //description of test data buffer accessed through this interface\012  void set_mem(void *x) {mem=x;};\012  void set_size(size_t x) {size=x;};\012  void set_data_size(size_t datasize) {data_size = datasize;}\012  \012#endif\012public:\012#ifdef HLS_X86\012  memory_base() {}\012  memory_base(void *mem, size_t size, size_t data_size, bool use_socket):data_size(data_size),mem(mem),size(size),use_socket(use_socket) {}\012  memory_base(int aspace, int awidth, int dwidth,  int latency, readwrite_t readwrite_mode, bool byteenabled, int maxburst, int align, bool waitrequest );\012\012  void set_parameters(int aspace, int awidth, int dwidth,  int latency, readwrite_t readwrite_mode, bool byteenabled, int maxburst, int align, bool waitrequest );\012  void set_base(void *ptr, size_t datasize, size_t size, bool use_socket);\012  int get_interface_aspace() {return aspace;}\012  void * get_base(){return mem;}\012  size_t get_size() {return size;}\012  int get_awidth() {return awidth;}\012  int get_dwidth() {return dwidth;}\012  int get_latency() {return latency;}\012  readwrite_t get_readwrite_mode() {return readwrite_mode;}\012  bool get_byteenabled() {return byteenabled;}\012  int get_maxburst() {return maxburst;}\012  int get_align() {return align;}\012  bool get_waitrequest() {return waitrequest;}\012  \012  size_t get_data_size() {return data_size;}\012\012  void set_sim_base(size_t addr) {sim_base = addr;}\012  size_t get_sim_base() {return sim_base;}\012  \012  void set_use_socket(bool socket) {use_socket = socket;}\012  bool uses_socket() {return use_socket;}\012#endif\012};\012\012#ifdef HLS_X86\012class stream_abstract_base {\012  bool stable; // does the data on this interface change between function calls?\012  bool implicit; // is this interface synchronous with the component's function call interface?\012  bool global; // is this an implicit interface that carries a global variable's address?\012  size_t data_size; //size of the underlying type used by the interface\012protected:\012  unsigned m_average_stall;\012  unsigned m_stall_delta;\012  unsigned m_average_RoV;\012  unsigned m_RoV_delta;\012  unsigned m_remaining_period;\012  unsigned m_period_threshold;\012public:\012stream_abstract_base():stable(false), implicit(false), global(false), m_average_stall(0), m_stall_delta(0), m_average_RoV(1), m_RoV_delta(0), m_remaining_period(1), m_period_threshold(1) { assert(1==0);}\012stream_abstract_base(size_t data_size):stable(false), implicit(false), global(false), data_size(data_size), m_average_stall(0), m_stall_delta(0), m_average_RoV(1), m_RoV_delta(0), m_remaining_period(1), m_period_threshold(1){}\012  bool is_stable() {return stable;}\012  void set_stable() {stable = true;}\012  bool is_implicit() {return implicit;}\012  bool is_global() {return global;}\012  void set_implicit() {implicit = true;}\012  void set_global() {global = true;}\012  size_t get_data_size() {return data_size;}\012  void set_data_size(size_t datasize) {data_size = datasize;}\012  unsigned get_average_stall() {return m_average_stall;}\012  unsigned get_stall_delta() {return m_stall_delta;}\012  unsigned get_average_RoV() {return m_average_RoV;}\012  unsigned get_RoV_delta() {return m_RoV_delta;}\012  virtual bool _internal_cosim_empty() = 0;\012  virtual void read_by_ptr(void *data) = 0;\012  virtual void read_by_ptr_pkt(void *data, bool* sop, bool* eop) = 0;\012  virtual void write_by_ptr(void *data) = 0;\012  virtual void write_by_ptr_pkt(void *data, bool* sop, bool* eop) = 0;\012  virtual void front_by_ptr(void *data) = 0;\012  virtual void front_by_ptr_pkt(void *data, bool* sop, bool* eop) = 0;\012  virtual size_t get_size() = 0;\012};\012#endif\012\012template<typename T, typename p1 = notinit, typename p2 = notinit, typename p3 = notinit, typename p4 = notinit, typename p5 = notinit>\012class stream \012#ifdef HLS_X86\012  :  public stream_abstract_base \012#endif\012{\012   ~stream() {} // Cannot inherit from HLS interface\012  //Make sure only the listed classes can reach the destructor, and nothing derived from them\012  template <typename T1, typename p11, typename p21, typename p31, typename p41, typename p51> friend class ihc::stream_in;\012  template <typename T1, typename p11, typename p21, typename p31, typename p41, typename p51> friend class ihc::stream_out;\012\012#ifdef HLS_X86\012  std::queue<T> q_;\012  std::queue<std::pair<bool,bool> > qp_;\012#endif\012  \012protected:\012  stream();\012  \012#ifdef HLS_X86\012  stream(const stream<T,p1,p2,p3,p4,p5>& copy_from);\012#endif\012  \012public:     \012  bool _internal_cosim_empty(); \012#ifdef HLS_X86\012  virtual T read();               \012  virtual void write(T arg);      \012  virtual T tryRead(bool &success);   \012  virtual bool tryWrite(T arg);       \012\012  // for packet based stream \012  virtual T read(bool& sop, bool& eop);\012  virtual void write(T arg, bool sop, bool eop);\012  virtual T tryRead(bool &success, bool& sop, bool& eop);\012  virtual bool tryWrite(T arg, bool sop, bool eop);     \012  virtual void setStallCycles(unsigned average_stall, unsigned stall_delta=0);\012  virtual void setReadyorValidCycles(unsigned average_RoV, unsigned RoV_delta=0);\012#else\012  T read();               \012  void write(T arg);      \012  T tryRead(bool &success); \012  bool tryWrite(T arg);       \012\012  // for packet based stream \012  T read(bool& sop, bool& eop);\012  void write(T arg, bool sop, bool eop);\012  T tryRead(bool &success, bool& sop, bool& eop);\012  bool tryWrite(T arg, bool sop, bool eop);     \012#endif\012   T _internal_cosim_front();\012   T _internal_cosim_front(bool& sop, bool& eop);\012  \012#ifdef HLS_X86\012  void read_by_ptr(void *data);\012  void read_by_ptr_pkt(void *data, bool* sop, bool* eop);\012  void write_by_ptr(void *data);\012  void write_by_ptr_pkt(void *data, bool* sop, bool*eop);\012  void front_by_ptr(void *data);\012  void front_by_ptr_pkt(void *data, bool* sop, bool* eop);\012  size_t get_size() {return q_.size();}\012\012  // control stall/valid behaviour\012  bool stall();\012  void setStallPeriod();\012  //Middle Square Weyl Sequence RNG\012   unsigned msws();\012#endif\012};\012\012template <typename T, typename p1 , typename p2, typename p3, typename p4, typename p5>\012  stream<T,p1,p2,p3,p4,p5>::stream()\012#ifdef HLS_X86\012 :stream_abstract_base(sizeof(T))\012#endif\012{\012}\012#ifdef HLS_X86\012template <typename T, typename p1 , typename p2, typename p3, typename p4, typename p5>\012  stream<T,p1,p2,p3,p4,p5>::stream(const stream<T,p1,p2,p3,p4,p5>& copy_from):stream_abstract_base(sizeof(T)),q_(copy_from.q_),qp_(copy_from.qp_)\012{\012}\012#endif\012\012  ////////////////\012 /// stream   ///\012////////////////\012\012#ifdef HLS_X86\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012bool stream<T,p1,p2,p3,p4,p5>::_internal_cosim_empty() {\012  bool empty=q_.empty();  \012  return empty;\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012T stream<T,p1,p2,p3,p4,p5>::tryRead(bool &success) {\012  success = !_internal_cosim_empty();\012  if (success) {\012    return read();\012  } else {\012    return T();\012  }\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012T stream<T,p1,p2,p3,p4,p5>::tryRead(bool &success, bool& sop, bool& eop) {\012  success = !_internal_cosim_empty();\012  if (success) {\012    return read(sop,eop);\012  } else {\012    return T();\012  }\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012T stream<T,p1,p2,p3,p4,p5>::read() {\012  T arg;      \012  \012  bool empty = _internal_cosim_empty();\012  if(empty) __ihc_hls_runtime_error_x86(\"Cannot do a blocking read from an empty stream on an x86 target\");\012\012  arg = q_.front();\012  q_.pop();\012  qp_.pop(); //unused sideband signals\012  \012  return arg;\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012T stream<T,p1,p2,p3,p4,p5>::read(bool& sop, bool& eop) {\012  T arg;\012\012  bool empty = _internal_cosim_empty();\012  if(empty) __ihc_hls_runtime_error_x86(\"Cannot do a blocking read from an empty stream on an x86 target\");\012\012  arg = q_.front();\012  q_.pop();\012  std::pair<bool,bool> p = qp_.front();\012  qp_.pop(); //unused sideband signals\012  \012  sop = p.first;\012  eop = p.second;\012\012  return arg;\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012T stream<T,p1,p2,p3,p4,p5>::_internal_cosim_front() {\012  T arg;      \012    \012  bool empty = _internal_cosim_empty();\012  if(empty) __ihc_hls_runtime_error_x86(\"Cannot do a blocking read from an empty stream on an x86 target\");\012\012  arg = q_.front();\012  \012  return arg;\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012T stream<T,p1,p2,p3,p4,p5>::_internal_cosim_front(bool& sop, bool& eop) {\012  T arg;      \012    \012  bool empty = _internal_cosim_empty();\012  if(empty) __ihc_hls_runtime_error_x86(\"Cannot do a blocking read from an empty stream on an x86 target\");\012\012  arg = q_.front();\012  std::pair<bool,bool> p = qp_.front();\012\012  sop = p.first;\012  eop = p.second;\012  \012  return arg;\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012bool stream<T,p1,p2,p3,p4,p5>::tryWrite(T arg) {\012   bool success = true; /* stl::queue has no full */\012   if (success) {\012      write(arg);\012   }\012   return success;\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012bool stream<T,p1,p2,p3,p4,p5>::tryWrite(T arg, bool sop, bool eop) {\012   bool success = true; /* stl::queue has no full */\012   if (success) {\012      write(arg, sop, eop);\012   }\012   return success;\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012void stream<T,p1,p2,p3,p4,p5>::write(T arg) {\012    q_.push(arg);\012    qp_.push(std::pair<bool,bool>(false,false)); // sideband signals\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012void stream<T,p1,p2,p3,p4,p5>::write(T arg, bool sop, bool eop) {\012    q_.push(arg);\012    qp_.push(std::pair<bool,bool>(sop, eop)); // sideband signals\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012void stream<T,p1,p2,p3,p4,p5>::read_by_ptr(void *data) {\012    T elem = read();\012    memcpy(data, &elem, sizeof(T));\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012void stream<T,p1,p2,p3,p4,p5>::read_by_ptr_pkt(void *data, bool* sop, bool* eop) {\012    T elem = read(*sop, *eop);\012    memcpy(data, &elem, sizeof(T));\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012void stream<T,p1,p2,p3,p4,p5>::front_by_ptr_pkt(void *data, bool* sop, bool* eop) {\012    T elem = _internal_cosim_front(*sop, *eop);\012    memcpy(data, &elem, sizeof(T));    \012}\012\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012void stream<T,p1,p2,p3,p4,p5>::front_by_ptr(void *data) {\012    T elem = _internal_cosim_front();\012    memcpy(data, &elem, sizeof(T));    \012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012void stream<T,p1,p2,p3,p4,p5>::write_by_ptr_pkt(void *data, bool* sop, bool* eop) {\012    T elem;\012    memcpy(&elem, data, sizeof(T));\012    write(elem, *sop, *eop);\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012void stream<T,p1,p2,p3,p4,p5>::write_by_ptr(void *data) {\012    T elem;\012    memcpy(&elem, data, sizeof(T));\012    write(elem);\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012void stream<T,p1,p2,p3,p4,p5>::setStallPeriod() {\012    if (m_stall_delta == 0) {\012        m_remaining_period = m_average_stall;\012    } else {\012        m_remaining_period = (m_average_stall - m_stall_delta) + msws()%(m_stall_delta*2+1);\012    }\012    if (m_RoV_delta == 0) {\012        m_period_threshold = m_average_RoV;\012    } else {\012        m_period_threshold = (m_average_RoV - m_RoV_delta) + msws()%(m_RoV_delta*2+1);\012    }\012    m_remaining_period +=  m_period_threshold;\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012  void stream<T,p1,p2,p3,p4,p5>::setStallCycles(unsigned average_stall, unsigned stall_delta) {\012    m_average_stall = average_stall;\012    m_stall_delta = stall_delta;\012    setStallPeriod();\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012  void stream<T,p1,p2,p3,p4,p5>::setReadyorValidCycles(unsigned average_RoV, unsigned RoV_delta) {\012    m_average_RoV = average_RoV;\012    m_RoV_delta = RoV_delta;\012    setStallPeriod();\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012bool stream<T,p1,p2,p3,p4,p5>::stall() {\012  if (m_remaining_period > 0) {\012    m_remaining_period--;\012    if (m_remaining_period < m_period_threshold) { \012      return false;\012    } else {\012      return true;\012    }\012  }\012  setStallPeriod();\012  return false;\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012unsigned stream<T,p1,p2,p3,p4,p5>::msws() {\012  static unsigned long long x = 0, w = 0;\012  const unsigned long long s = 0xb5ad4eceda1ce2a9LL;\012  \012  x *= x; \012  x += (w += s); \012  return (unsigned) (x = (x>>32) | (x<<32));\012}\012\012#endif\012} //namespace internal\012} //namespace ihc\012\012#endif\012\012"}, {"path":"C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/iosfwd", "name":"iosfwd", "has_active_debug_locs":true, "absName":"c:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/iosfwd", "content":"// iosfwd standard header\012#pragma once\012#ifndef _IOSFWD_\012#define _IOSFWD_\012#ifndef RC_INVOKED\012#include <cstdio>\012#include <cstring>\012#include <cwchar>\012#include <xstddef>\012\012#include <crtdbg.h>\012\012 #pragma pack(push,_CRT_PACKING)\012 #pragma warning(push,3)\012\012_STD_BEGIN\012		// STREAM POSITIONING TYPES (from <streambuf>)\012\012typedef _Longlong streamoff;\012typedef _Longlong streamsize;\012\012  #define _FSEEK_OFF(str, off, way)	_fseeki64(str, off, way)\012  #define _Fpz	0	/* initializer for zero fpos_t */\012\012  #ifdef _M_CEE_PURE\012extern const streamoff _BADOFF;\012  #else /* _M_CEE_PURE */\012extern _CRTDATA2 _PGLOBAL const streamoff _BADOFF;\012  #endif /* _M_CEE_PURE */\012\012		// TEMPLATE CLASS fpos (from <streambuf>)\012template<class _Statetype>\012	class fpos\012	{	// store arbitrary file position\012	typedef fpos<_Statetype> _Myt;\012\012public:\012	__CLR_OR_THIS_CALL fpos(streamoff _Off = 0)\012		: _Myoff(_Off), _Fpos(_Fpz), _Mystate(_Stz)\012		{	// construct with stream offset\012		}\012\012	__CLR_OR_THIS_CALL fpos(_Statetype _State, fpos_t _Fileposition)\012		: _Myoff(0), _Fpos(_Fileposition), _Mystate(_State)\012		{	// construct with conversion state and C file position\012		}\012\012	_Statetype __CLR_OR_THIS_CALL state() const\012		{	// return conversion state\012		return (_Mystate);\012		}\012\012	void __CLR_OR_THIS_CALL state(_Statetype _State)\012		{	// set conversion state\012		_Mystate = _State;\012		}\012\012	fpos_t __CLR_OR_THIS_CALL seekpos() const\012		{	// return C file position\012		return (_Fpos);\012		}\012\012	__CLR_OR_THIS_CALL operator streamoff() const\012		{	// return offset\012		return ((streamoff)(_Myoff + _FPOSOFF(_Fpos)));\012		}\012\012	streamoff __CLR_OR_THIS_CALL operator-(const _Myt& _Right) const\012		{	// return difference of file positions as an offset\012		return ((streamoff)*this - (streamoff)_Right);\012		}\012\012	_Myt& __CLR_OR_THIS_CALL operator+=(streamoff _Off)\012		{	// add offset\012		_Myoff += _Off;\012		return (*this);\012		}\012\012	_Myt& __CLR_OR_THIS_CALL operator-=(streamoff _Off)\012		{	// subtract offset\012		_Myoff -= _Off;\012		return (*this);\012		}\012\012	_Myt __CLR_OR_THIS_CALL operator+(streamoff _Off) const\012		{	// return this + offset\012		_Myt _Tmp = *this;\012		return (_Tmp += _Off);\012		}\012\012	_Myt __CLR_OR_THIS_CALL operator-(streamoff _Off) const\012		{	// return this - offset\012		_Myt _Tmp = *this;\012		return (_Tmp -= _Off);\012		}\012\012	bool __CLR_OR_THIS_CALL operator==(const _Myt& _Right) const\012		{	// test for file position equality\012		return ((streamoff)*this == (streamoff)_Right);\012		}\012\012	bool __CLR_OR_THIS_CALL operator==(streamoff _Right) const\012		{	// test for file position equality with streamoff\012		return ((streamoff)*this == _Right);\012		}\012\012	bool __CLR_OR_THIS_CALL operator!=(const _Myt& _Right) const\012		{	// test for file position inequality\012		return (!(*this == _Right));\012		}\012\012private:\012	_PGLOBAL static const _Statetype _Stz;	// initial conversion state\012	streamoff _Myoff;	// stream offset\012	fpos_t _Fpos;	// C file position\012	_Statetype _Mystate;	// current conversion state\012	};\012\012	// STATIC fpos::_Stz OBJECT\012template<class _Statetype>\012	_PGLOBAL const _Statetype fpos<_Statetype>::_Stz = _Statetype();\012\012 #define _POS_TYPE_FROM_STATE(postype, state, position)	\\\012	postype(state, position)\012 #define _POS_TYPE_TO_FPOS_T(pos)	pos.seekpos()\012 #define _POS_TYPE_TO_STATE(pos)	pos.state()\012\012typedef fpos<_Mbstatet> streampos;\012\012typedef streampos wstreampos;\012\012		// TEMPLATE STRUCT _Char_traits (FROM <string>)\012template<class _Elem,\012	class _Int_type>\012	struct _Char_traits\012	{	// properties of a string or stream element\012	typedef _Elem char_type;\012	typedef _Int_type int_type;\012	typedef streampos pos_type;\012	typedef streamoff off_type;\012	typedef _Mbstatet state_type;\012\012	static int __CLRCALL_OR_CDECL compare(\012		_In_count_(_Count) const _Elem *_First1,\012		_In_count_(_Count) const _Elem *_First2, size_t _Count)\012		{	// compare [_First1, _First1 + _Count) with [_First2, ...)\012		for (; 0 < _Count; --_Count, ++_First1, ++_First2)\012			if (!eq(*_First1, *_First2))\012				return (lt(*_First1, *_First2) ? -1 : +1);\012		return (0);\012		}\012\012	static size_t __CLRCALL_OR_CDECL length(_In_z_ const _Elem *_First)\012		{	// find length of null-terminated sequence\012		size_t _Count;\012		for (_Count = 0; !eq(*_First, _Elem()); ++_First)\012			++_Count;\012		return (_Count);\012		}\012\012	static _Elem *__CLRCALL_OR_CDECL copy(\012		_Out_cap_(_Count) _Elem *_First1,\012		_In_count_(_Count) const _Elem *_First2, size_t _Count)\012		{	// copy [_First1, _First1 + _Count) to [_First2, ...)\012		_Elem *_Next = _First1;\012		for (; 0 < _Count; --_Count, ++_Next, ++_First2)\012			assign(*_Next, *_First2);\012		return (_First1);\012		}\012\012	static _Elem *__CLRCALL_OR_CDECL _Copy_s(\012		_Out_cap_(_Dest_size) _Elem *_First1, size_t _Dest_size,\012		_In_count_(_Count) const _Elem *_First2, size_t _Count)\012		{	// copy [_First1, _First1 + _Count) to [_First2, ...)\012		_SCL_SECURE_CRT_VALIDATE(_Dest_size >= _Count, NULL);\012		return (copy(_First1, _First2, _Count));\012		}\012\012	static const _Elem *__CLRCALL_OR_CDECL find(\012		_In_count_(_Count) const _Elem *_First,\012		size_t _Count, const _Elem& _Ch)\012		{	// look for _Ch in [_First, _First + _Count)\012		for (; 0 < _Count; --_Count, ++_First)\012			if (eq(*_First, _Ch))\012				return (_First);\012		return (0);\012		}\012\012	static _Elem *__CLRCALL_OR_CDECL move(\012		_Out_cap_(_Count) _Elem *_First1,\012		_In_count_(_Count) const _Elem *_First2, size_t _Count)\012		{	// copy [_First1, _First1 + _Count) to [_First2, ...)\012		_Elem *_Next = _First1;\012		if (_First2 < _Next && _Next < _First2 + _Count)\012			for (_Next += _Count, _First2 += _Count; 0 < _Count; --_Count)\012				assign(*--_Next, *--_First2);\012		else\012			for (; 0 < _Count; --_Count, ++_Next, ++_First2)\012				assign(*_Next, *_First2);\012		return (_First1);\012		}\012\012	static _Elem *__CLRCALL_OR_CDECL assign(\012		_Out_cap_(_Count) _Elem *_First,\012		size_t _Count, _Elem _Ch)\012		{	// assign _Count * _Ch to [_First, ...)\012		_Elem *_Next = _First;\012		for (; 0 < _Count; --_Count, ++_Next)\012			assign(*_Next, _Ch);\012		return (_First);\012		}\012\012	static void __CLRCALL_OR_CDECL assign(_Elem& _Left, const _Elem& _Right)\012		{	// assign an element\012		_Left = _Right;\012		}\012\012	static bool __CLRCALL_OR_CDECL eq(const _Elem& _Left, const _Elem& _Right)\012		{	// test for element equality\012		return (_Left == _Right);\012		}\012\012	static bool __CLRCALL_OR_CDECL lt(const _Elem& _Left, const _Elem& _Right)\012		{	// test if _Left precedes _Right\012		return (_Left < _Right);\012		}\012\012	static _Elem __CLRCALL_OR_CDECL to_char_type(const int_type& _Meta)\012		{	// convert metacharacter to character\012		return ((_Elem)_Meta);\012		}\012\012	static int_type __CLRCALL_OR_CDECL to_int_type(const _Elem& _Ch)\012		{	// convert character to metacharacter\012		return ((int_type)_Ch);\012		}\012\012	static bool __CLRCALL_OR_CDECL eq_int_type(const int_type& _Left,\012		const int_type& _Right)\012		{	// test for metacharacter equality\012		return (_Left == _Right);\012		}\012\012	static int_type __CLRCALL_OR_CDECL not_eof(const int_type& _Meta)\012		{	// return anything but EOF\012		return (_Meta != eof() ? (int_type)_Meta : (int_type)!eof());\012		}\012\012	static int_type __CLRCALL_OR_CDECL eof()\012		{	// return end-of-file metacharacter\012		return ((int_type)EOF);\012		}\012	};\012\012		// TEMPLATE STRUCT char_traits\012template<class _Elem>\012	struct char_traits\012		: public _Char_traits<_Elem, long>\012	{	// properties of a string or stream unknown element\012	};\012\012 #if _HAS_CHAR16_T_LANGUAGE_SUPPORT\012		// STRUCT char_traits<char16_t>\012template<>\012	struct char_traits<char16_t>\012	: public _Char_traits<char16_t, unsigned short>\012	{	// properties of a string or stream char16_t element\012	};\012\012		// STRUCT char_traits<char32_t>\012template<>\012	struct char_traits<char32_t>\012	: public _Char_traits<char32_t, unsigned long>\012	{	// properties of a string or stream char32_t element\012	};\012 #endif /* _HAS_CHAR16_T_LANGUAGE_SUPPORT */\012\012		// STRUCT char_traits<wchar_t>\012template<>\012	struct char_traits<wchar_t>\012	{	// properties of a string or stream wchar_t element\012	typedef wchar_t _Elem;\012	typedef _Elem char_type;	// for overloads\012	typedef wint_t int_type;\012	typedef streampos pos_type;\012	typedef streamoff off_type;\012	typedef _Mbstatet state_type;\012\012	static int __CLRCALL_OR_CDECL compare(const _Elem *_First1, const _Elem *_First2,\012		size_t _Count)\012		{	// compare [_First1, _First1 + _Count) with [_First2, ...)\012		return (_CSTD wmemcmp(_First1, _First2, _Count));\012		}\012\012	static size_t __CLRCALL_OR_CDECL length(const _Elem *_First)\012		{	// find length of null-terminated sequence\012		return (_CSTD wcslen(_First));\012		}\012\012	static _Elem *__CLRCALL_OR_CDECL copy(_Elem *_First1, const _Elem *_First2,\012		size_t _Count)\012		{	// copy [_First1, _First1 + _Count) to [_First2, ...)\012		return ((_Elem *)_CSTD wmemcpy(_First1, _First2, _Count));\012		}\012\012	static _Elem *__CLRCALL_OR_CDECL _Copy_s(\012		_Out_cap_(_Size_in_words) _Elem *_First1, size_t _Size_in_words,\012		_In_count_(_Count) const _Elem *_First2, size_t _Count)\012		{	// copy [_First1, _First1 + _Count) to [_First2, ...)\012		_CRT_SECURE_WMEMCPY(_First1, _Size_in_words, _First2, _Count);\012		return _First1;\012		}\012\012	static const _Elem *__CLRCALL_OR_CDECL find(const _Elem *_First, size_t _Count,\012		const _Elem& _Ch)\012		{	// look for _Ch in [_First, _First + _Count)\012		return ((const _Elem *)_CSTD wmemchr(_First, _Ch, _Count));\012		}\012\012	static _Elem *__CLRCALL_OR_CDECL move(_Elem *_First1, const _Elem *_First2,\012		size_t _Count)\012		{	// copy [_First1, _First1 + _Count) to [_First2, ...)\012		return ((_Elem *)_CSTD wmemmove(_First1, _First2, _Count));\012		}\012\012	static _Elem *__CLRCALL_OR_CDECL assign(_Elem *_First, size_t _Count, _Elem _Ch)\012		{	// assign _Count * _Ch to [_First, ...)\012		return ((_Elem *)_CSTD wmemset(_First, _Ch, _Count));\012		}\012\012	static void __CLRCALL_OR_CDECL assign(_Elem& _Left, const _Elem& _Right)\012		{	// assign an element\012		_Left = _Right;\012		}\012\012	static bool __CLRCALL_OR_CDECL eq(const _Elem& _Left, const _Elem& _Right)\012		{	// test for element equality\012		return (_Left == _Right);\012		}\012\012	static bool __CLRCALL_OR_CDECL lt(const _Elem& _Left, const _Elem& _Right)\012		{	// test if _Left precedes _Right\012		return (_Left < _Right);\012		}\012\012	static _Elem __CLRCALL_OR_CDECL to_char_type(const int_type& _Meta)\012		{	// convert metacharacter to character\012		return (_Meta);\012		}\012\012	static int_type __CLRCALL_OR_CDECL to_int_type(const _Elem& _Ch)\012		{	// convert character to metacharacter\012		return (_Ch);\012		}\012\012	static bool __CLRCALL_OR_CDECL eq_int_type(const int_type& _Left,\012		const int_type& _Right)\012		{	// test for metacharacter equality\012		return (_Left == _Right);\012		}\012\012	static int_type __CLRCALL_OR_CDECL not_eof(const int_type& _Meta)\012		{	// return anything but EOF\012		return (_Meta != eof() ? _Meta : !eof());\012		}\012\012	static int_type __CLRCALL_OR_CDECL eof()\012		{	// return end-of-file metacharacter\012		return (WEOF);\012		}\012	};\012\012 #ifdef _NATIVE_WCHAR_T_DEFINED\012		// STRUCT char_traits<unsigned short>\012template<> struct char_traits<unsigned short>\012	{	// properties of a string or stream unsigned short element\012	typedef unsigned short _Elem;\012	typedef _Elem char_type;	// for overloads\012	typedef wint_t int_type;\012	typedef streampos pos_type;\012	typedef streamoff off_type;\012	typedef _Mbstatet state_type;\012\012	static int __CLRCALL_OR_CDECL compare(const _Elem *_First1, const _Elem *_First2,\012		size_t _Count)\012		{	// compare [_First1, _First1 + _Count) with [_First2, ...)\012		return (_CSTD wmemcmp((const wchar_t *)_First1,\012			(const wchar_t *)_First2, _Count));\012		}\012\012	static size_t __CLRCALL_OR_CDECL length(const _Elem *_First)\012		{	// find length of null-terminated sequence\012		return (_CSTD wcslen((const wchar_t *)_First));\012		}\012\012	static _Elem *__CLRCALL_OR_CDECL copy(_Elem *_First1, const _Elem *_First2,\012		size_t _Count)\012		{	// copy [_First1, _First1 + _Count) to [_First2, ...)\012		return ((_Elem *)_CSTD wmemcpy((wchar_t *)_First1,\012			(const wchar_t *)_First2, _Count));\012		}\012\012	static _Elem *__CLRCALL_OR_CDECL _Copy_s(\012		_Out_cap_(_Size_in_words) _Elem *_First1, size_t _Size_in_words,\012		_In_count_(_Count) const _Elem *_First2, size_t _Count)\012		{	// copy [_First1, _First1 + _Count) to [_First2, ...)\012		_CRT_SECURE_WMEMCPY((wchar_t *)_First1, _Size_in_words, (const wchar_t *)_First2, _Count);\012		return _First1;\012		}\012\012	static const _Elem *__CLRCALL_OR_CDECL find(const _Elem *_First, size_t _Count,\012		const _Elem& _Ch)\012		{	// look for _Ch in [_First, _First + _Count)\012		return ((const _Elem *)_CSTD wmemchr((const wchar_t *)_First,\012			_Ch, _Count));\012		}\012\012	static _Elem *__CLRCALL_OR_CDECL move(_Elem *_First1, const _Elem *_First2,\012		size_t _Count)\012		{	// copy [_First1, _First1 + _Count) to [_First2, ...)\012		return ((_Elem *)_CSTD wmemmove((wchar_t *)_First1,\012			(const wchar_t *)_First2, _Count));\012		}\012\012	static _Elem *__CLRCALL_OR_CDECL assign(_Elem *_First, size_t _Count, _Elem _Ch)\012		{	// assign _Count * _Ch to [_First, ...)\012		return ((_Elem *)_CSTD wmemset((wchar_t *)_First, _Ch, _Count));\012		}\012\012	static void __CLRCALL_OR_CDECL assign(_Elem& _Left, const _Elem& _Right)\012		{	// assign an element\012		_Left = _Right;\012		}\012\012	static bool __CLRCALL_OR_CDECL eq(const _Elem& _Left, const _Elem& _Right)\012		{	// test for element equality\012		return (_Left == _Right);\012		}\012\012	static bool __CLRCALL_OR_CDECL lt(const _Elem& _Left, const _Elem& _Right)\012		{	// test if _Left precedes _Right\012		return (_Left < _Right);\012		}\012\012	static _Elem __CLRCALL_OR_CDECL to_char_type(const int_type& _Meta)\012		{	// convert metacharacter to character\012		return (_Meta);\012		}\012\012	static int_type __CLRCALL_OR_CDECL to_int_type(const _Elem& _Ch)\012		{	// convert character to metacharacter\012		return (_Ch);\012		}\012\012	static bool __CLRCALL_OR_CDECL eq_int_type(const int_type& _Left,\012		const int_type& _Right)\012		{	// test for metacharacter equality\012		return (_Left == _Right);\012		}\012\012	static int_type __CLRCALL_OR_CDECL not_eof(const int_type& _Meta)\012		{	// return anything but EOF\012		return (_Meta != eof() ? _Meta : !eof());\012		}\012\012	static int_type __CLRCALL_OR_CDECL eof()\012		{	// return end-of-file metacharacter\012		return (WEOF);\012		}\012	};\012 #endif /* _NATIVE_WCHAR_T_DEFINED */\012\012		// STRUCT char_traits<char> (FROM <string>)\012template<> struct char_traits<char>\012	{	// properties of a string or stream char element\012	typedef char _Elem;\012	typedef _Elem char_type;\012	typedef int int_type;\012	typedef streampos pos_type;\012	typedef streamoff off_type;\012	typedef _Mbstatet state_type;\012\012	static int __CLRCALL_OR_CDECL compare(const _Elem *_First1, const _Elem *_First2,\012		size_t _Count)\012		{	// compare [_First1, _First1 + _Count) with [_First2, ...)\012		return (_CSTD memcmp(_First1, _First2, _Count));\012		}\012\012	static size_t __CLRCALL_OR_CDECL length(const _Elem *_First)\012		{	// find length of null-terminated string\012		return (_CSTD strlen(_First));\012		}\012\012	static _Elem *__CLRCALL_OR_CDECL copy(_Elem *_First1, const _Elem *_First2,\012		size_t _Count)\012		{	// copy [_First1, _First1 + _Count) to [_First2, ...)\012		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));\012		}\012\012	static _Elem *__CLRCALL_OR_CDECL _Copy_s(\012		_Out_cap_(_Size_in_bytes) _Elem *_First1, size_t _Size_in_bytes,\012		_In_count_(_Count) const _Elem *_First2, size_t _Count)\012		{	// copy [_First1, _First1 + _Count) to [_First2, ...)\012		_CRT_SECURE_MEMCPY(_First1, _Size_in_bytes, _First2, _Count);\012		return _First1;\012		}\012\012	static const _Elem *__CLRCALL_OR_CDECL find(const _Elem *_First, size_t _Count,\012		const _Elem& _Ch)\012		{	// look for _Ch in [_First, _First + _Count)\012		return ((const _Elem *)_CSTD memchr(_First, _Ch, _Count));\012		}\012\012	static _Elem *__CLRCALL_OR_CDECL move(_Elem *_First1, const _Elem *_First2,\012		size_t _Count)\012		{	// copy [_First1, _First1 + _Count) to [_First2, ...)\012		return ((_Elem *)_CSTD memmove(_First1, _First2, _Count));\012		}\012\012	static _Elem *__CLRCALL_OR_CDECL assign(_Elem *_First, size_t _Count, _Elem _Ch)\012		{	// assign _Count * _Ch to [_First, ...)\012		return ((_Elem *)_CSTD memset(_First, _Ch, _Count));\012		}\012\012	static void __CLRCALL_OR_CDECL assign(_Elem& _Left, const _Elem& _Right)\012		{	// assign an element\012		_Left = _Right;\012		}\012\012	static bool __CLRCALL_OR_CDECL eq(const _Elem& _Left, const _Elem& _Right)\012		{	// test for element equality\012		return (_Left == _Right);\012		}\012\012	static bool __CLRCALL_OR_CDECL lt(const _Elem& _Left, const _Elem& _Right)\012		{	// test if _Left precedes _Right\012		return ((unsigned char)_Left < (unsigned char)_Right);\012		}\012\012	static _Elem __CLRCALL_OR_CDECL to_char_type(const int_type& _Meta)\012		{	// convert metacharacter to character\012		return ((_Elem)_Meta);\012		}\012\012	static int_type __CLRCALL_OR_CDECL to_int_type(const _Elem& _Ch)\012		{	// convert character to metacharacter\012		return ((unsigned char)_Ch);\012		}\012\012	static bool __CLRCALL_OR_CDECL eq_int_type(const int_type& _Left,\012		const int_type& _Right)\012		{	// test for metacharacter equality\012		return (_Left == _Right);\012		}\012\012	static int_type __CLRCALL_OR_CDECL not_eof(const int_type& _Meta)\012		{	// return anything but EOF\012		return (_Meta != eof() ? _Meta : !eof());\012		}\012\012	static int_type __CLRCALL_OR_CDECL eof()\012		{	// return end-of-file metacharacter\012		return (EOF);\012		}\012	};\012\012		// FORWARD REFERENCES\012template<class _Ty>\012	class allocator;\012class ios_base;\012template<class _Elem,\012	class _Traits = char_traits<_Elem> >\012	class basic_ios;\012template<class _Elem,\012	class _Traits = char_traits<_Elem> >\012	class istreambuf_iterator;\012template<class _Elem,\012	class _Traits = char_traits<_Elem> >\012	class ostreambuf_iterator;\012template<class _Elem,\012	class _Traits = char_traits<_Elem> >\012	class basic_streambuf;\012template<class _Elem,\012	class _Traits = char_traits<_Elem> >\012	class basic_istream;\012template<class _Elem,\012	class _Traits = char_traits<_Elem> >\012	class basic_ostream;\012template<class _Elem,\012	class _Traits = char_traits<_Elem> >\012	class basic_iostream;\012template<class _Elem,\012	class _Traits = char_traits<_Elem>,\012	class _Alloc = allocator<_Elem> >\012	class basic_stringbuf;\012template<class _Elem,\012	class _Traits = char_traits<_Elem>,\012	class _Alloc = allocator<_Elem> >\012	class basic_istringstream;\012template<class _Elem,\012	class _Traits = char_traits<_Elem>,\012	class _Alloc = allocator<_Elem> >\012	class basic_ostringstream;\012template<class _Elem,\012	class _Traits = char_traits<_Elem>,\012	class _Alloc = allocator<_Elem> >\012	class basic_stringstream;\012template<class _Elem,\012	class _Traits = char_traits<_Elem> >\012	class basic_filebuf;\012template<class _Elem,\012	class _Traits = char_traits<_Elem> >\012	class basic_ifstream;\012template<class _Elem,\012	class _Traits = char_traits<_Elem> >\012	class basic_ofstream;\012template<class _Elem,\012	class _Traits = char_traits<_Elem> >\012	class basic_fstream;\012\012 #if defined(_DLL_CPPLIB) && !defined(_M_CEE_PURE)\012template<class _Elem,\012	class _InIt >\012	class num_get;\012template<class _Elem,\012	class _OutIt >\012	class num_put;\012template<class _Elem>\012	class collate;\012 #endif /* defined(_DLL_CPPLIB) etc. */\012\012		// char TYPEDEFS\012typedef basic_ios<char, char_traits<char> > ios;\012typedef basic_streambuf<char, char_traits<char> > streambuf;\012typedef basic_istream<char, char_traits<char> > istream;\012typedef basic_ostream<char, char_traits<char> > ostream;\012typedef basic_iostream<char, char_traits<char> > iostream;\012typedef basic_stringbuf<char, char_traits<char>,\012	allocator<char> > stringbuf;\012typedef basic_istringstream<char, char_traits<char>,\012	allocator<char> > istringstream;\012typedef basic_ostringstream<char, char_traits<char>,\012	allocator<char> > ostringstream;\012typedef basic_stringstream<char, char_traits<char>,\012	allocator<char> > stringstream;\012typedef basic_filebuf<char, char_traits<char> > filebuf;\012typedef basic_ifstream<char, char_traits<char> > ifstream;\012typedef basic_ofstream<char, char_traits<char> > ofstream;\012typedef basic_fstream<char, char_traits<char> > fstream;\012\012		// wchat_t TYPEDEFS\012typedef basic_ios<wchar_t, char_traits<wchar_t> > wios;\012typedef basic_streambuf<wchar_t, char_traits<wchar_t> >\012	wstreambuf;\012typedef basic_istream<wchar_t, char_traits<wchar_t> > wistream;\012typedef basic_ostream<wchar_t, char_traits<wchar_t> > wostream;\012typedef basic_iostream<wchar_t, char_traits<wchar_t> > wiostream;\012typedef basic_stringbuf<wchar_t, char_traits<wchar_t>,\012	allocator<wchar_t> > wstringbuf;\012typedef basic_istringstream<wchar_t, char_traits<wchar_t>,\012	allocator<wchar_t> > wistringstream;\012typedef basic_ostringstream<wchar_t, char_traits<wchar_t>,\012	allocator<wchar_t> > wostringstream;\012typedef basic_stringstream<wchar_t, char_traits<wchar_t>,\012	allocator<wchar_t> > wstringstream;\012typedef basic_filebuf<wchar_t, char_traits<wchar_t> > wfilebuf;\012typedef basic_ifstream<wchar_t, char_traits<wchar_t> > wifstream;\012typedef basic_ofstream<wchar_t, char_traits<wchar_t> > wofstream;\012typedef basic_fstream<wchar_t, char_traits<wchar_t> > wfstream;\012\012\012 #if defined(_DLL_CPPLIB) && !defined(_M_CEE_PURE)\012typedef num_get<char, istreambuf_iterator<char, char_traits<char> > >\012	numget;\012typedef num_get<wchar_t, istreambuf_iterator<wchar_t, char_traits<wchar_t> > >\012	wnumget;\012typedef num_put<char, ostreambuf_iterator<char, char_traits<char> > >\012	numput;\012typedef num_put<wchar_t, ostreambuf_iterator<wchar_t, char_traits<wchar_t> > >\012	wnumput;\012typedef collate<char> ncollate;\012typedef collate<wchar_t> wcollate;\012 #endif /* defined(_DLL_CPPLIB) etc. */\012_STD_END\012\012 #pragma warning(pop)\012 #pragma pack(pop)\012\012#endif /* RC_INVOKED */\012#endif /* _IOSFWD_ */\012\012/*\012 * Copyright (c) 1992-2009 by P.J. Plauger.  ALL RIGHTS RESERVED.\012 * Consult your license regarding permissions and restrictions.\012V5.20:0009 */\012"}, {"path":"main.cpp", "name":"main.cpp", "has_active_debug_locs":true, "absName":"c:/intelFPGA/17.1/hls/examples/image_downsample/main.cpp", "content":"// main.cpp\012#include \"HLS/hls.h\"\012#include \"resize.h\"\012#include \"bmp_tools.h\"\012\012#include <string>\012#include <stdio.h> //printf\012#include <stdlib.h> // malloc, free\012#include <ctime>\012\012int main (void) {\012	clock_t start_time = clock();\012  // image files\012  std::string input_bmp_filename    = \"test.bmp\";\012  std::string output_bmp_filename   = \"downsampled.bmp\";\012  std::string expected_bmp_filename = \"expected.bmp\";\012\012  // downsampling parameters\012  unsigned int ratio = 128;\012\012  // load image\012  unsigned int* in_img = 0;;\012  int rows, cols;\012  read_bmp(input_bmp_filename.c_str(), &in_img, rows, cols);\012\012  // run downsampling component\012  input_image_stream in_img_s;\012  output_image_stream out_img_s;\012  for (int i = 0; i < (rows*cols); ++i) {\012    in_img_s.write(in_img[i]);\012  }\012  resize(ratio, rows, cols, in_img_s, out_img_s);\012\012  // save output image\012  int out_rows = rows / (SCALE_GRAN / ratio);\012  int out_cols = cols / (SCALE_GRAN / ratio);\012  unsigned int* out_img = (unsigned int*) malloc(out_rows * out_cols * sizeof(unsigned int));\012  for (int i = 0; i < (out_rows*out_cols); ++i) {\012    out_img[i] = out_img_s.read();\012  }\012  write_bmp(output_bmp_filename.c_str(), out_img, out_rows, out_cols);\012\012  // load expected output and compare\012  unsigned int* exp_img = 0;;\012  int exp_rows, exp_cols;\012  read_bmp(expected_bmp_filename.c_str(), &exp_img, exp_rows, exp_cols);\012\012  // check dimensions\012  bool passed = (out_rows == exp_rows) && (out_cols == exp_cols);\012  if (!passed) {\012    printf(\"ERROR: dimensions (%d, %d) != (%d, %d)\\n\", out_cols, out_rows, exp_cols, exp_rows);\012  }\012\012  // compare image data\012  if (passed) {\012    for (int i = 0; i < (out_rows*out_cols); ++i) {\012      passed &= (out_img[i] == exp_img[i]);\012    }\012  }\012\012  if (passed) {\012    printf(\"PASSED\\n\");\012  } else {\012    printf(\"FAILED\\n\");\012  }\012\012  // free memory\012  free(in_img);\012  free(out_img);\012  free(exp_img);\012\012	clock_t end_time = clock();\012    double duration = static_cast<double>(end_time - start_time) / CLOCKS_PER_SEC;\012\012    printf(\"Execution time: %.6f seconds\\n\", duration);\012	\012  return 0;\012}\012"}, {"path":"resize.cpp", "name":"resize.cpp", "has_active_debug_locs":true, "absName":"c:/intelFPGA/17.1/hls/examples/image_downsample/resize.cpp", "content":"// resize.cpp\012#include \"HLS/hls.h\"\012#include \"resize.h\"\012\012struct uchar4 {\012  unsigned char d[4];\012};\012\012struct uint4 {\012  unsigned int d[4];\012};\012\012// The maximum number of blocks supported per row. It must cover the border around the image.\012#define MAXBX 91     \012// The number of cells per dimension in one block\012#define BLOCK_SIZE 2 \012// The number of pixels per cell\012#define CELL_SIZE 8  \012// The number of bins per cell\012#define NBINS 9      \012#define MAXCOLS (MAXBX * CELL_SIZE)\012#define BLOCK_HIST (NBINS * BLOCK_SIZE * BLOCK_SIZE)\012\012\012/* Conversion Helper Functions */\012uint4 convert_uint4(uchar4 x) {\012  uint4 y;\012  y.d[0] = (unsigned int) x.d[0];\012  y.d[1] = (unsigned int) x.d[1];\012  y.d[2] = (unsigned int) x.d[2];\012  y.d[3] = (unsigned int) x.d[3];\012  return y;\012}\012\012uchar4 convert_uchar4(uint4 x) {\012  uchar4 y;\012  y.d[0] = (unsigned char) x.d[0];\012  y.d[1] = (unsigned char) x.d[1];\012  y.d[2] = (unsigned char) x.d[2];\012  y.d[3] = (unsigned char) x.d[3];\012  return y;\012}\012\012unsigned int convert_uint(uchar4 x) {\012  return ( (((unsigned int) x.d[3]) << 24) | (((unsigned int) x.d[2]) << 16)  | (((unsigned int) x.d[1]) << 8) | (((unsigned int) x.d[0]) << 0));\012}\012\012/*!\012 * @brief Input an image of ROWS x COLS, and output is a reduced scale image by a factor SCALE_GRAN / ratio\012 * @note It is the equivalent of gpu::HOGInvoker::resize() of OpenCV library.\012 * @param[in] ratio          : Describes the scaling factor\012 * @param[in] rows           : The number of rows in the original image\012 * @param[in] cols           : The number of columns in the original image\012 * @param[in] original_image : The original input image\012 */\012component void resize(unsigned ratio, int rows, int cols, input_image_stream& original_image, output_image_stream& resized_image) {\012  unsigned int out_pointer = 0;\012  uchar4 buf[MAXCOLS + 2]; // Must buffer one row and 2 pixels from the original image to be able to downscale using bilinear interpolation\012  unsigned int accumColumn, accumRow = SCALE_GRAN - ratio;\012  int col = 0, row = 0;\012  bool write_x, write_y;\012\012  // Downsample the image using vector operation. It processes row by row.\012  for (int i = 0; i < rows * MAXCOLS + MAXCOLS + 1; i++) {\012    if (row < rows && col < cols) {\012      unsigned int predata=original_image.read();\012      buf[MAXCOLS + 1].d[0]= predata&0xff;\012      buf[MAXCOLS + 1].d[1]= (predata>>8)&0xff;\012      buf[MAXCOLS + 1].d[2]= (predata>>16)&0xff;\012      buf[MAXCOLS + 1].d[3]=0;\012    }\012\012    // Use integer logic to compute the fraction and determine when to\012    // write and how to interpolate\012    // write this row / column only if overflowing ratio + SCALE_GRAN\012    if (col == 0) {\012      accumColumn = SCALE_GRAN - ratio;\012      write_y = false;\012      accumRow += ratio;\012      if (accumRow >= SCALE_GRAN) {\012        accumRow -= SCALE_GRAN;\012        write_y = true;\012      }\012    }\012    accumColumn += ratio;\012    write_x = false;\012    if (accumColumn >= SCALE_GRAN) {\012      accumColumn -= SCALE_GRAN;\012      write_x = true;\012    }\012    /* The actual bilinear interpolation core. */\012    if (write_x && write_y && (i >= MAXCOLS + 1) && col > 0 && (col - 1) < cols) {\012      uint4 pix0 = convert_uint4(buf[0]);\012      uint4 pix1 = convert_uint4(buf[1]);\012      uint4 pix2 = convert_uint4(buf[MAXCOLS]);\012      uint4 pix3 = convert_uint4(buf[MAXCOLS + 1]);\012      /* The following operations process all components in a pixel together. */\012      unsigned int rc=(accumRow&0xff)*(accumColumn&0xff);\012      uint4 tmp_pixel;\012      #pragma unroll\012      for (int d = 0; d < 4; ++d) {\012        tmp_pixel.d[d] =(pix3.d[d]*SCALE_GRAN*SCALE_GRAN +\012            ((pix1.d[d]-pix3.d[d])&0x3ffffff)*(accumRow&0x3ffffff)*SCALE_GRAN +\012            ((pix2.d[d]-pix3.d[d])&0x3ffffff)*(accumColumn&0x3ffffff)*SCALE_GRAN +\012            ((pix0.d[d]+pix3.d[d]-pix2.d[d]-pix1.d[d])&0x3ffffff)*(rc&0x3ffffff))/SCALE_GRAN/SCALE_GRAN;\012      }\012      uchar4 pixel=convert_uchar4(tmp_pixel);\012      resized_image.write(convert_uint(pixel));\012    }\012    /* Shift the buffer in preparation for the next iteration. */\012    #pragma unroll\012    for (int i = 0; i < MAXCOLS + 1; i++) {\012      buf[i].d[0] = buf[i + 1].d[0];\012      buf[i].d[1] = buf[i + 1].d[1];\012      buf[i].d[2] = buf[i + 1].d[2];\012      buf[i].d[3] = buf[i + 1].d[3];\012    }\012    col = col == MAXCOLS - 1 ? 0 : col + 1;\012    row = col == 0 ? row + 1 : row;\012  }\012}\012"}, {"path":"resize.h", "name":"resize.h", "has_active_debug_locs":false, "absName":"c:/intelFPGA/17.1/hls/examples/image_downsample/resize.h", "content":"// resize.h\012#ifndef RESIZE_H\012#define RESIZE_H\012\012// Represent scale as fraction SCALE_GRAN / ratio\012#define SCALE_GRAN 256\012\012typedef ihc::stream_in<unsigned int> input_image_stream;\012typedef ihc::stream_out<unsigned int> output_image_stream;\012\012component void resize(unsigned ratio, int rows, int cols, input_image_stream& original_image, output_image_stream& resized_image);\012\012#endif // RESIZE_H\012"}, {"path":"C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/xmemory", "name":"xmemory", "has_active_debug_locs":true, "absName":"c:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/xmemory", "content":"// xmemory internal header (from <memory>)\012#pragma once\012#ifndef _XMEMORY_\012#define _XMEMORY_\012#ifndef RC_INVOKED\012#include <cstdlib>\012#include <new>\012#include <xutility>\012\012 #pragma pack(push,_CRT_PACKING)\012 #pragma warning(push,3)\012\012 #define _ALLOCATOR	allocator\012\012 #pragma push_macro(\"new\")\012 #undef new\012\012 #pragma warning(disable: 4100)\012\012#ifndef _FARQ	/* specify standard memory model */\012 #define _FARQ\012 #define _PDFT	ptrdiff_t\012 #define _SIZT	size_t\012#endif /* _FARQ */\012\012_STD_BEGIN\012		// TEMPLATE FUNCTION _Allocate\012template<class _Ty> inline\012	_Ty _FARQ *_Allocate(_SIZT _Count, _Ty _FARQ *)\012	{	// allocate storage for _Count elements of type _Ty\012	void *_Ptr = 0;\012\012	if (_Count <= 0)\012		_Count = 0;\012	else if (((_SIZT)(-1) / sizeof (_Ty) < _Count)\012		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)\012		_THROW_NCEE(bad_alloc, 0);\012\012	return ((_Ty _FARQ *)_Ptr);\012	}\012\012		// TEMPLATE FUNCTION _Construct\012template<class _Ty1,\012	class _Ty2> inline\012	void _Construct(_Ty1 _FARQ *_Ptr, _Ty2&& _Val)\012	{	// construct object at _Ptr with value _Val\012	void _FARQ *_Vptr = _Ptr;\012	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));\012	}\012\012template<class _Ty1> inline\012	void _Construct(_Ty1 _FARQ *_Ptr)\012	{	// construct object at _Ptr with default value\012	void _FARQ *_Vptr = _Ptr;\012\012	::new (_Vptr) _Ty1();\012	}\012\012		// TEMPLATE FUNCTION _Destroy\012template<class _Ty> inline\012	void _Destroy(_Ty _FARQ *_Ptr)\012	{	// destroy object at _Ptr\012	_Ptr->~_Ty();\012	}\012\012template<> inline\012	void _Destroy(char _FARQ *)\012	{	// destroy a char (do nothing)\012	}\012\012template<> inline\012	void _Destroy(wchar_t _FARQ *)\012	{	// destroy a wchar_t (do nothing)\012	}\012\012 #ifdef _NATIVE_WCHAR_T_DEFINED\012template<> inline\012	void _Destroy(unsigned short _FARQ *)\012	{	// destroy a unsigned short (do nothing)\012	}\012 #endif /* _NATIVE_WCHAR_T_DEFINED */\012\012		// TEMPLATE FUNCTION _Destroy_range\012template<class _Alloc> inline\012	void _Destroy_range(typename _Alloc::pointer _First,\012		typename _Alloc::pointer _Last, _Alloc& _Al)\012	{	// destroy [_First, _Last)\012	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));\012	}\012\012template<class _Alloc> inline\012	void _Destroy_range(typename _Alloc::pointer _First,\012		typename _Alloc::pointer _Last, _Alloc& _Al,\012		_Nonscalar_ptr_iterator_tag)\012	{	// destroy [_First, _Last), arbitrary type\012	for (; _First != _Last; ++_First)\012		_Dest_val(_Al, _First);\012	}\012\012template<class _Alloc> inline\012	void _Destroy_range(typename _Alloc::pointer _First,\012		typename _Alloc::pointer _Last, _Alloc& _Al,\012		_Scalar_ptr_iterator_tag)\012	{	// destroy [_First, _Last), scalar type (do nothing)\012	}\012\012		// TEMPLATE FUNCTION addressof\012template<class _Ty> inline\012	_Ty * addressof(_Ty& _Val)\012	{	// return address of _Val\012	return ((_Ty *) &(char&)_Val);\012	}\012\012		// TEMPLATE CLASS _Allocator_base\012template<class _Ty>\012	struct _Allocator_base\012	{	// base class for generic allocators\012	typedef _Ty value_type;\012	};\012\012		// TEMPLATE CLASS _Allocator_base<const _Ty>\012template<class _Ty>\012	struct _Allocator_base<const _Ty>\012	{	// base class for generic allocators for const _Ty\012	typedef _Ty value_type;\012	};\012\012		// TEMPLATE CLASS _ALLOCATOR\012template<class _Ty>\012	class _ALLOCATOR\012		: public _Allocator_base<_Ty>\012	{	// generic allocator for objects of class _Ty\012public:\012	typedef _Allocator_base<_Ty> _Mybase;\012	typedef typename _Mybase::value_type value_type;\012\012	typedef value_type _FARQ *pointer;\012	typedef value_type _FARQ& reference;\012	typedef const value_type _FARQ *const_pointer;\012	typedef const value_type _FARQ& const_reference;\012\012	typedef _SIZT size_type;\012	typedef _PDFT difference_type;\012\012	template<class _Other>\012		struct rebind\012		{	// convert this type to _ALLOCATOR<_Other>\012		typedef _ALLOCATOR<_Other> other;\012		};\012\012	pointer address(reference _Val) const\012		{	// return address of mutable _Val\012		return ((pointer) &(char&)_Val);\012		}\012\012	const_pointer address(const_reference _Val) const\012		{	// return address of nonmutable _Val\012		return ((const_pointer) &(char&)_Val);\012		}\012\012	_ALLOCATOR() _THROW0()\012		{	// construct default allocator (do nothing)\012		}\012\012	_ALLOCATOR(const _ALLOCATOR<_Ty>&) _THROW0()\012		{	// construct by copying (do nothing)\012		}\012\012	template<class _Other>\012		_ALLOCATOR(const _ALLOCATOR<_Other>&) _THROW0()\012		{	// construct from a related allocator (do nothing)\012		}\012\012	template<class _Other>\012		_ALLOCATOR<_Ty>& operator=(const _ALLOCATOR<_Other>&)\012		{	// assign from a related allocator (do nothing)\012		return (*this);\012		}\012\012	void deallocate(pointer _Ptr, size_type)\012		{	// deallocate object at _Ptr, ignore size\012		::operator delete(_Ptr);\012		}\012\012	pointer allocate(size_type _Count)\012		{	// allocate array of _Count elements\012		return (_Allocate(_Count, (pointer)0));\012		}\012\012	pointer allocate(size_type _Count, const void _FARQ *)\012		{	// allocate array of _Count elements, ignore hint\012		return (allocate(_Count));\012		}\012\012	void construct(pointer _Ptr, const _Ty& _Val)\012		{	// construct object at _Ptr with value _Val\012		_Construct(_Ptr, _Val);\012		}\012\012	void construct(pointer _Ptr, _Ty&& _Val)\012		{	// construct object at _Ptr with value _Val\012		::new ((void _FARQ *)_Ptr) _Ty(_STD forward<_Ty>(_Val));\012		}\012\012	template<class _Other>\012		void construct(pointer _Ptr, _Other&& _Val)\012		{	// construct object at _Ptr with value _Val\012		::new ((void _FARQ *)_Ptr) _Ty(_STD forward<_Other>(_Val));\012		}\012\012	void destroy(pointer _Ptr)\012		{	// destroy object at _Ptr\012		_Destroy(_Ptr);\012		}\012\012	_SIZT max_size() const _THROW0()\012		{	// estimate maximum array size\012		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);\012		return (0 < _Count ? _Count : 1);\012		}\012	};\012\012		// CLASS _ALLOCATOR<void>\012template<> class _ALLOCATOR<void>\012	{	// generic _ALLOCATOR for type void\012public:\012	typedef void _Ty;\012	typedef _Ty _FARQ *pointer;\012	typedef const _Ty _FARQ *const_pointer;\012	typedef _Ty value_type;\012\012	template<class _Other>\012		struct rebind\012		{	// convert this type to an _ALLOCATOR<_Other>\012		typedef _ALLOCATOR<_Other> other;\012		};\012\012	_ALLOCATOR() _THROW0()\012		{	// construct default allocator (do nothing)\012		}\012\012	_ALLOCATOR(const _ALLOCATOR<_Ty>&) _THROW0()\012		{	// construct by copying (do nothing)\012		}\012\012	template<class _Other>\012		_ALLOCATOR(const _ALLOCATOR<_Other>&) _THROW0()\012		{	// construct from related allocator (do nothing)\012		}\012\012	template<class _Other>\012		_ALLOCATOR<_Ty>& operator=(const _ALLOCATOR<_Other>&)\012		{	// assign from a related allocator (do nothing)\012		return (*this);\012		}\012	};\012\012template<class _Ty,\012	class _Other> inline\012	bool operator==(const allocator<_Ty>&,\012		const allocator<_Other>&) _THROW0()\012	{	// test for allocator equality\012	return (true);\012	}\012\012template<class _Ty,\012	class _Other> inline\012	bool operator!=(const allocator<_Ty>& _Left,\012		const allocator<_Other>& _Right) _THROW0()\012	{	// test for allocator inequality\012	return (!(_Left == _Right));\012	}\012\012		// TEMPLATE FUNCTIONS _Cons_val AND _Dest_val\012template<class _Alloc,\012	class _Ty1,\012	class _Ty2>\012	void _Cons_val(_Alloc& _Alval, _Ty1 *_Pdest, _Ty2&& _Src)\012	{	// construct using allocator\012	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));\012	}\012\012template<class _Alloc,\012	class _Ty1>\012	void _Dest_val(_Alloc& _Alval, _Ty1 *_Pdest)\012	{	// destroy using allocator\012	_Alval.destroy(_Pdest);\012	}\012_STD_END\012\012 #pragma pop_macro(\"new\")\012\012 #pragma warning(pop)\012 #pragma pack(pop)\012\012#endif /* RC_INVOKED */\012#endif /* _XMEMORY_ */\012\012/*\012 * This file is derived from software bearing the following\012 * restrictions:\012 *\012 * Copyright (c) 1994\012 * Hewlett-Packard Company\012 *\012 * Permission to use, copy, modify, distribute and sell this\012 * software and its documentation for any purpose is hereby\012 * granted without fee, provided that the above copyright notice\012 * appear in all copies and that both that copyright notice and\012 * this permission notice appear in supporting documentation.\012 * Hewlett-Packard Company makes no representations about the\012 * suitability of this software for any purpose. It is provided\012 * \"as is\" without express or implied warranty.\012 */\012\012/*\012 * Copyright (c) 1992-2009 by P.J. Plauger.  ALL RIGHTS RESERVED.\012 * Consult your license regarding permissions and restrictions.\012V5.20:0009 */\012"}, {"path":"C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/xstring", "name":"xstring", "has_active_debug_locs":true, "absName":"c:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/xstring", "content":"// xstring internal header (from <string>)\012#pragma once\012#ifndef _XSTRING_\012#define _XSTRING_\012#ifndef RC_INVOKED\012#include <xmemory>\012\012 #pragma pack(push,_CRT_PACKING)\012 #pragma warning(push,3)\012\012_STD_BEGIN\012  #pragma warning(disable: 4251)\012\012template<class _Elem,\012	class _Traits = char_traits<_Elem>,\012	class _Ax = allocator<_Elem> >\012	class basic_string;\012\012  #define _STRING_ITER_BASE(it)			(it)._Ptr\012  #define _STRING_CONST_ITERATOR(ptr)	const_iterator(ptr, this)\012  #define _STRING_ITERATOR(ptr)			iterator(ptr, this)\012\012		// TEMPLATE CLASS _String_const_iterator\012template<class _Elem,\012	class _Traits,\012	class _Alloc>\012	class _String_const_iterator\012		: public _Iterator012<random_access_iterator_tag,\012			typename _Alloc::value_type,\012			typename _Alloc::difference_type,\012			typename _Alloc::const_pointer,\012			typename _Alloc::const_reference,\012			_Iterator_base>\012	{	// iterator for nonmutable string\012public:\012	typedef _String_const_iterator<_Elem, _Traits, _Alloc> _Myiter;\012	typedef basic_string<_Elem, _Traits, _Alloc> _Mystr;\012	typedef random_access_iterator_tag iterator_category;\012\012	typedef typename _Alloc::value_type value_type;\012	typedef typename _Alloc::difference_type difference_type;\012	typedef typename _Alloc::const_pointer pointer;\012	typedef typename _Alloc::const_reference reference;\012\012	_String_const_iterator()\012		{	// construct with null pointer\012		this->_Ptr = 0;\012		}\012\012	_String_const_iterator(pointer _Parg, const _Container_base *_Pstring)\012		{	// construct with pointer _Parg\012		this->_Adopt(_Pstring);\012		this->_Ptr = _Parg;\012		}\012\012	typedef pointer _Unchecked_type;\012\012	_Myiter& _Rechecked(_Unchecked_type _Right)\012		{	// reset from unchecked iterator\012		this->_Ptr = _Right;\012		return (*this);\012		}\012\012	_Unchecked_type _Unchecked() const\012		{	// make an unchecked iterator\012		return (_Unchecked_type(this->_Ptr));\012		}\012\012	reference operator*() const\012		{	// return designated object\012 #if _ITERATOR_DEBUG_LEVEL == 2\012		if (this->_Getcont() == 0\012			|| this->_Ptr == 0\012			|| this->_Ptr < ((_Mystr *)this->_Getcont())->_Myptr()\012			|| ((_Mystr *)this->_Getcont())->_Myptr()\012				+ ((_Mystr *)this->_Getcont())->_Mysize <= this->_Ptr)\012			{	// report error\012			_DEBUG_ERROR(\"string iterator not dereferencable\");\012			_SCL_SECURE_OUT_OF_RANGE;\012			}\012\012 #elif _ITERATOR_DEBUG_LEVEL == 1\012		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);\012		_SCL_SECURE_VALIDATE_RANGE(\012			((_Mystr *)this->_Getcont())->_Myptr() <= this->_Ptr\012			&& this->_Ptr < ((_Mystr *)this->_Getcont())->_Myptr()\012				+ ((_Mystr *)this->_Getcont())->_Mysize);\012 #endif /* _ITERATOR_DEBUG_LEVEL */\012\012		__analysis_assume(this->_Ptr != 0);\012\012		return (*this->_Ptr);\012		}\012\012	pointer operator->() const\012		{	// return pointer to class object\012		return (&**this);\012		}\012\012	_Myiter& operator++()\012		{	// preincrement\012 #if _ITERATOR_DEBUG_LEVEL == 2\012		if (this->_Getcont() == 0\012			|| this->_Ptr == 0\012			|| ((_Mystr *)this->_Getcont())->_Myptr()\012				+ ((_Mystr *)this->_Getcont())->_Mysize <= this->_Ptr)\012			{	// report error\012			_DEBUG_ERROR(\"string iterator not incrementable\");\012			_SCL_SECURE_OUT_OF_RANGE;\012			}\012\012 #elif _ITERATOR_DEBUG_LEVEL == 1\012		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);\012		_SCL_SECURE_VALIDATE_RANGE(\012			this->_Ptr < ((_Mystr *)this->_Getcont())->_Myptr()\012				+ ((_Mystr *)this->_Getcont())->_Mysize);\012 #endif /* _ITERATOR_DEBUG_LEVEL */\012\012		++this->_Ptr;\012		return (*this);\012		}\012\012	_Myiter operator++(int)\012		{	// postincrement\012		_Myiter _Tmp = *this;\012		++*this;\012		return (_Tmp);\012		}\012\012	_Myiter& operator--()\012		{	// predecrement\012 #if _ITERATOR_DEBUG_LEVEL == 2\012		if (this->_Getcont() == 0\012			|| this->_Ptr == 0\012			|| this->_Ptr <= ((_Mystr *)this->_Getcont())->_Myptr())\012			{	// report error\012			_DEBUG_ERROR(\"string iterator not decrementable\");\012			_SCL_SECURE_OUT_OF_RANGE;\012			}\012\012 #elif _ITERATOR_DEBUG_LEVEL == 1\012		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);\012		_SCL_SECURE_VALIDATE_RANGE(\012			((_Mystr *)this->_Getcont())->_Myptr() < this->_Ptr);\012 #endif /* _ITERATOR_DEBUG_LEVEL */\012\012		--this->_Ptr;\012		return (*this);\012		}\012\012	_Myiter operator--(int)\012		{	// postdecrement\012		_Myiter _Tmp = *this;\012		--*this;\012		return (_Tmp);\012		}\012\012	_Myiter& operator+=(difference_type _Off)\012		{	// increment by integer\012 #if _ITERATOR_DEBUG_LEVEL == 2\012		if (this->_Getcont() == 0\012			|| this->_Ptr == 0\012			|| this->_Ptr + _Off < ((_Mystr *)this->_Getcont())->_Myptr()\012			|| ((_Mystr *)this->_Getcont())->_Myptr()\012				+ ((_Mystr *)this->_Getcont())->_Mysize < this->_Ptr + _Off)\012			{	// report error\012			_DEBUG_ERROR(\"string iterator + offset out of range\");\012			_SCL_SECURE_OUT_OF_RANGE;\012			}\012\012 #elif _ITERATOR_DEBUG_LEVEL == 1\012		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);\012		_SCL_SECURE_VALIDATE_RANGE(\012			((_Mystr *)this->_Getcont())->_Myptr() <= this->_Ptr + _Off\012				&& this->_Ptr + _Off <= ((_Mystr *)this->_Getcont())->_Myptr()\012					+ ((_Mystr *)this->_Getcont())->_Mysize);\012 #endif /* _ITERATOR_DEBUG_LEVEL */\012\012		_Ptr += _Off;\012		return (*this);\012		}\012\012	_Myiter operator+(difference_type _Off) const\012		{	// return this + integer\012		_Myiter _Tmp = *this;\012		return (_Tmp += _Off);\012		}\012\012	_Myiter& operator-=(difference_type _Off)\012		{	// decrement by integer\012		return (*this += -_Off);\012		}\012\012	_Myiter operator-(difference_type _Off) const\012		{	// return this - integer\012		_Myiter _Tmp = *this;\012		return (_Tmp -= _Off);\012		}\012\012	difference_type operator-(const _Myiter& _Right) const\012		{	// return difference of iterators\012		_Compat(_Right);\012		return (this->_Ptr - _Right._Ptr);\012		}\012\012	reference operator[](difference_type _Off) const\012		{	// subscript\012		return (*(*this + _Off));\012		}\012\012	bool operator==(const _Myiter& _Right) const\012		{	// test for iterator equality\012		_Compat(_Right);\012		return (this->_Ptr == _Right._Ptr);\012		}\012\012	bool operator!=(const _Myiter& _Right) const\012		{	// test for iterator inequality\012		return (!(*this == _Right));\012		}\012\012	bool operator<(const _Myiter& _Right) const\012		{	// test if this < _Right\012		_Compat(_Right);\012		return (this->_Ptr < _Right._Ptr);\012		}\012\012	bool operator>(const _Myiter& _Right) const\012		{	// test if this > _Right\012		return (_Right < *this);\012		}\012\012	bool operator<=(const _Myiter& _Right) const\012		{	// test if this <= _Right\012		return (!(_Right < *this));\012		}\012\012	bool operator>=(const _Myiter& _Right) const\012		{	// test if this >= _Right\012		return (!(*this < _Right));\012		}\012\012 #if _ITERATOR_DEBUG_LEVEL == 2\012	void _Compat(const _Myiter& _Right) const\012		{	// test for compatible iterator pair\012		if (this->_Getcont() == 0\012			|| this->_Getcont() != _Right._Getcont())\012			{	// report error\012			_DEBUG_ERROR(\"string iterators incompatible\");\012			_SCL_SECURE_INVALID_ARGUMENT;\012			}\012		}\012\012 #elif _ITERATOR_DEBUG_LEVEL == 1\012	void _Compat(const _Myiter& _Right) const\012		{	// test for compatible iterator pair\012		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);\012		_SCL_SECURE_VALIDATE_RANGE(this->_Getcont() == _Right._Getcont());\012		}\012\012 #else /* _ITERATOR_DEBUG_LEVEL == 0 */\012	void _Compat(const _Myiter&) const\012		{	// test for compatible iterator pair\012		}\012 #endif /* _ITERATOR_DEBUG_LEVEL */\012\012	pointer _Ptr;	// pointer to element in string\012	};\012\012template<class _Elem,\012	class _Traits,\012	class _Alloc> inline\012	typename _String_const_iterator<_Elem, _Traits, _Alloc>::_Unchecked_type\012		_Unchecked(_String_const_iterator<_Elem, _Traits, _Alloc> _Iter)\012	{	// convert to unchecked\012	return (_Iter._Unchecked());\012	}\012\012template<class _Elem,\012	class _Traits,\012	class _Alloc> inline\012	_String_const_iterator<_Elem, _Traits, _Alloc>\012		_Rechecked(_String_const_iterator<_Elem, _Traits, _Alloc>& _Iter,\012			typename _String_const_iterator<_Elem, _Traits, _Alloc>\012				::_Unchecked_type _Right)\012	{	// convert to checked\012	return (_Iter._Rechecked(_Right));\012	}\012\012template<class _Elem,\012	class _Traits,\012	class _Alloc> inline\012	_String_const_iterator<_Elem, _Traits, _Alloc> operator+(\012		typename _String_const_iterator<_Elem, _Traits, _Alloc>\012			::difference_type _Off,\012		_String_const_iterator<_Elem, _Traits, _Alloc> _Next)\012	{	// add offset to iterator\012	return (_Next += _Off);\012	}\012\012		// TEMPLATE CLASS _String_iterator\012template<class _Elem,\012	class _Traits,\012	class _Alloc>\012	class _String_iterator\012		: public _String_const_iterator<_Elem, _Traits, _Alloc>\012	{	// iterator for mutable string\012public:\012	typedef _String_iterator<_Elem, _Traits, _Alloc> _Myiter;\012	typedef _String_const_iterator<_Elem, _Traits, _Alloc> _Mybase;\012	typedef basic_string<_Elem, _Traits, _Alloc> _Mystr;\012	typedef random_access_iterator_tag iterator_category;\012\012	typedef typename _Mystr::value_type value_type;\012	typedef typename _Mystr::difference_type difference_type;\012	typedef typename _Mystr::pointer pointer;\012	typedef typename _Mystr::reference reference;\012\012	_String_iterator()\012		{	// construct with null string pointer\012		}\012\012	_String_iterator(pointer _Parg, const _Container_base *_Pstring)\012		: _Mybase(_Parg, _Pstring)\012		{	// construct with pointer _Parg\012		}\012\012	typedef pointer _Unchecked_type;\012\012	_Myiter& _Rechecked(_Unchecked_type _Right)\012		{	// reset from unchecked iterator\012		this->_Ptr = _Right;\012		return (*this);\012		}\012\012	_Unchecked_type _Unchecked() const\012		{	// make an unchecked iterator\012		return (_Unchecked_type(this->_Ptr));\012		}\012\012	reference operator*() const\012		{	// return designated object\012		return ((reference)**(_Mybase *)this);\012		}\012\012	pointer operator->() const\012		{	// return pointer to class object\012		return (&**this);\012		}\012\012	_Myiter& operator++()\012		{	// preincrement\012		++*(_Mybase *)this;\012		return (*this);\012		}\012\012	_Myiter operator++(int)\012		{	// postincrement\012		_Myiter _Tmp = *this;\012		++*this;\012		return (_Tmp);\012		}\012\012	_Myiter& operator--()\012		{	// predecrement\012		--*(_Mybase *)this;\012		return (*this);\012		}\012\012	_Myiter operator--(int)\012		{	// postdecrement\012		_Myiter _Tmp = *this;\012		--*this;\012		return (_Tmp);\012		}\012\012	_Myiter& operator+=(difference_type _Off)\012		{	// increment by integer\012		*(_Mybase *)this += _Off;\012		return (*this);\012		}\012\012	_Myiter operator+(difference_type _Off) const\012		{	// return this + integer\012		_Myiter _Tmp = *this;\012		return (_Tmp += _Off);\012		}\012\012	_Myiter& operator-=(difference_type _Off)\012		{	// decrement by integer\012		return (*this += -_Off);\012		}\012\012	_Myiter operator-(difference_type _Off) const\012		{	// return this - integer\012		_Myiter _Tmp = *this;\012		return (_Tmp -= _Off);\012		}\012\012	difference_type operator-(const _Mybase& _Right) const\012		{	// return difference of iterators\012		return ((_Mybase)*this - _Right);\012		}\012\012	reference operator[](difference_type _Off) const\012		{	// subscript\012		return (*(*this + _Off));\012		}\012	};\012\012template<class _Elem,\012	class _Traits,\012	class _Alloc> inline\012	typename _String_iterator<_Elem, _Traits, _Alloc>::_Unchecked_type\012		_Unchecked(_String_iterator<_Elem, _Traits, _Alloc> _Iter)\012	{	// convert to unchecked\012	return (_Iter._Unchecked());\012	}\012\012template<class _Elem,\012	class _Traits,\012	class _Alloc> inline\012	_String_iterator<_Elem, _Traits, _Alloc>\012		_Rechecked(_String_iterator<_Elem, _Traits, _Alloc>& _Iter,\012			typename _String_iterator<_Elem, _Traits, _Alloc>\012				::_Unchecked_type _Right)\012	{	// convert to checked\012	return (_Iter._Rechecked(_Right));\012	}\012\012template<class _Elem,\012	class _Traits,\012	class _Alloc> inline\012	_String_iterator<_Elem, _Traits, _Alloc> operator+(\012		typename _String_iterator<_Elem, _Traits, _Alloc>\012			::difference_type _Off,\012		_String_iterator<_Elem, _Traits, _Alloc> _Next)\012	{	// add offset to iterator\012	return (_Next += _Off);\012	}\012\012		// TEMPLATE CLASS _String_val\012template<class _Elem,\012	class _Alloc>\012	class _String_val\012		: public _Container_base\012	{	// base class for basic_string to hold data\012public:\012 #if _ITERATOR_DEBUG_LEVEL == 0\012	typedef typename _Alloc::template rebind<_Elem>::other _Alty;\012\012	_String_val(_Alty _Al = _Alty())\012		: _Alval(_Al)\012		{	// construct allocator from _Al\012		}\012\012	~_String_val()\012		{	// destroy the object\012		}\012\012 #else /* _ITERATOR_DEBUG_LEVEL == 0 */\012	typedef typename _Alloc::template rebind<_Elem>::other _Alty;\012\012	_String_val(_Alty _Al = _Alty())\012		: _Alval(_Al)\012		{	// construct allocator from _Al\012		typename _Alloc::template rebind<_Container_proxy>::other\012			_Alproxy(_Alval);\012		this->_Myproxy = _Alproxy.allocate(1);\012		_Cons_val(_Alproxy, this->_Myproxy, _Container_proxy());\012		this->_Myproxy->_Mycont = this;\012		}\012\012	~_String_val()\012		{	// destroy the object\012		typename _Alloc::template rebind<_Container_proxy>::other\012			_Alproxy(_Alval);\012		this->_Orphan_all();\012		_Dest_val(_Alproxy, this->_Myproxy);\012		_Alproxy.deallocate(this->_Myproxy, 1);\012		this->_Myproxy = 0;\012		}\012 #endif /* _ITERATOR_DEBUG_LEVEL == 0 */\012\012	typedef typename _Alty::size_type size_type;\012	typedef typename _Alty::difference_type difference_type;\012	typedef typename _Alty::pointer pointer;\012	typedef typename _Alty::const_pointer const_pointer;\012	typedef typename _Alty::reference reference;\012	typedef typename _Alty::const_reference const_reference;\012	typedef typename _Alty::value_type value_type;\012\012	enum\012		{	// length of internal buffer, [1, 16]\012		_BUF_SIZE = 16 / sizeof (_Elem) < 1 ? 1\012			: 16 / sizeof (_Elem)};\012	enum\012		{	// roundup mask for allocated buffers, [0, 15]\012		_ALLOC_MASK = sizeof (_Elem) <= 1 ? 15\012			: sizeof (_Elem) <= 2 ? 7\012			: sizeof (_Elem) <= 4 ? 3\012			: sizeof (_Elem) <= 8 ? 1 : 0};\012\012	union _Bxty\012		{	// storage for small buffer or pointer to larger one\012		_Elem _Buf[_BUF_SIZE];\012		_Elem *_Ptr;\012		char _Alias[_BUF_SIZE];	// to permit aliasing\012		} _Bx;\012\012	size_type _Mysize;	// current length of string\012	size_type _Myres;	// current storage reserved for string\012	_Alty _Alval;	// allocator object for strings\012	};\012\012		// TEMPLATE CLASS basic_string\012template<class _Elem,\012	class _Traits,\012	class _Ax>\012	class basic_string\012		: public _String_val<_Elem, _Ax>\012	{	// null-terminated transparent array of elements\012public:\012	typedef basic_string<_Elem, _Traits, _Ax> _Myt;\012	typedef _String_val<_Elem, _Ax> _Mybase;\012	typedef typename _Mybase::_Alty _Alloc;\012	typedef typename _Alloc::size_type size_type;\012	typedef typename _Alloc::difference_type difference_type;\012	typedef typename _Alloc::pointer pointer;\012	typedef typename _Alloc::const_pointer const_pointer;\012	typedef typename _Alloc::reference reference;\012	typedef typename _Alloc::const_reference const_reference;\012	typedef typename _Alloc::value_type value_type;\012\012	typedef _String_iterator<_Elem, _Traits, _Alloc> iterator;\012	typedef _String_const_iterator<_Elem, _Traits, _Alloc> const_iterator;\012\012	typedef _STD reverse_iterator<iterator> reverse_iterator;\012	typedef _STD reverse_iterator<const_iterator> const_reverse_iterator;\012\012	basic_string(const _Myt& _Right)\012		: _Mybase(_Right._Alval)\012		{	// construct by copying _Right\012		_Tidy();\012		assign(_Right, 0, npos);\012		}\012\012	basic_string()\012		: _Mybase()\012		{	// construct empty string\012		_Tidy();\012		}\012\012	explicit basic_string(const _Alloc& _Al)\012		: _Mybase(_Al)\012		{	// construct empty string with allocator\012		_Tidy();\012		}\012\012	basic_string(const _Myt& _Right, size_type _Roff,\012		size_type _Count = npos)\012		: _Mybase(_Right._Alval)\012		{	// construct from _Right [_Roff, _Roff + _Count)\012		_Tidy();\012		assign(_Right, _Roff, _Count);\012		}\012\012	basic_string(const _Myt& _Right, size_type _Roff, size_type _Count,\012		const _Alloc& _Al)\012		: _Mybase(_Al)\012		{	// construct from _Right [_Roff, _Roff + _Count) with allocator\012		_Tidy();\012		assign(_Right, _Roff, _Count);\012		}\012\012	basic_string(const _Elem *_Ptr, size_type _Count)\012		: _Mybase()\012		{	// construct from [_Ptr, _Ptr + _Count)\012		_Tidy();\012		assign(_Ptr, _Count);\012		}\012\012	basic_string(const _Elem *_Ptr, size_type _Count, const _Alloc& _Al)\012		: _Mybase(_Al)\012		{	// construct from [_Ptr, _Ptr + _Count) with allocator\012		_Tidy();\012		assign(_Ptr, _Count);\012		}\012\012	basic_string(const _Elem *_Ptr)\012		: _Mybase()\012		{	// construct from [_Ptr, <null>)\012		_Tidy();\012		assign(_Ptr);\012		}\012\012	basic_string(const _Elem *_Ptr, const _Alloc& _Al)\012		: _Mybase(_Al)\012		{	// construct from [_Ptr, <null>) with allocator\012		_Tidy();\012		assign(_Ptr);\012		}\012\012	basic_string(size_type _Count, _Elem _Ch)\012		: _Mybase()\012		{	// construct from _Count * _Ch\012		_Tidy();\012		assign(_Count, _Ch);\012		}\012\012	basic_string(size_type _Count, _Elem _Ch, const _Alloc& _Al)\012		: _Mybase(_Al)\012		{	// construct from _Count * _Ch with allocator\012		_Tidy();\012		assign(_Count, _Ch);\012		}\012\012	template<class _It>\012		basic_string(_It _First, _It _Last)\012		: _Mybase()\012		{	// construct from [_First, _Last)\012		_Tidy();\012		_Construct(_First, _Last, _Iter_cat(_First));\012		}\012\012	template<class _It>\012		basic_string(_It _First, _It _Last, const _Alloc& _Al)\012		: _Mybase(_Al)\012		{	// construct from [_First, _Last) with allocator\012		_Tidy();\012		_Construct(_First, _Last, _Iter_cat(_First));\012		}\012\012	template<class _It>\012		void _Construct(_It _Count,\012			_It _Ch, _Int_iterator_tag)\012		{	// initialize from _Count * _Ch\012		assign((size_type)_Count, (_Elem)_Ch);\012		}\012\012	template<class _It>\012		void _Construct(_It _First,\012			_It _Last, input_iterator_tag)\012		{	// initialize from [_First, _Last), input iterators\012		_TRY_BEGIN\012		for (; _First != _Last; ++_First)\012			append((size_type)1, (_Elem)*_First);\012		_CATCH_ALL\012		_Tidy(true);\012		_RERAISE;\012		_CATCH_END\012		}\012\012	template<class _It>\012		void _Construct(_It _First,\012			_It _Last, forward_iterator_tag)\012		{	// initialize from [_First, _Last), forward iterators\012		_DEBUG_RANGE(_First, _Last);\012		size_type _Count = 0;\012		_Distance(_First, _Last, _Count);\012		reserve(_Count);\012\012		_TRY_BEGIN\012		for (; _First != _Last; ++_First)\012			append((size_type)1, (_Elem)*_First);\012		_CATCH_ALL\012		_Tidy(true);\012		_RERAISE;\012		_CATCH_END\012		}\012\012	basic_string(const_pointer _First, const_pointer _Last)\012		: _Mybase()\012		{	// construct from [_First, _Last), const pointers\012		_DEBUG_RANGE(_First, _Last);\012		_Tidy();\012		if (_First != _Last)\012			assign(&*_First, _Last - _First);\012		}\012\012	basic_string(const_pointer _First, const_pointer _Last,\012		const _Alloc& _Al)\012		: _Mybase(_Al)\012		{	// construct from [_First, _Last), const pointers\012		_DEBUG_RANGE(_First, _Last);\012		_Tidy();\012		if (_First != _Last)\012			assign(&*_First, _Last - _First);\012		}\012\012	basic_string(const_iterator _First, const_iterator _Last)\012		: _Mybase()\012		{	// construct from [_First, _Last), const_iterators\012		_DEBUG_RANGE(_First, _Last);\012		_Tidy();\012		if (_First != _Last)\012			assign(&*_First, _Last - _First);\012		}\012\012	basic_string(_Myt&& _Right)\012		: _Mybase(_STD forward<_Alloc>(_Right._Alval))\012		{	// construct by moving _Right\012		_Tidy();\012		assign(_STD forward<_Myt>(_Right));\012		}\012\012	_Myt& operator=(_Myt&& _Right)\012		{	// assign by moving _Right\012		return (assign(_STD forward<_Myt>(_Right)));\012		}\012\012	_Myt& assign(_Myt&& _Right)\012		{	// assign by moving _Right\012		if (this == &_Right)\012			;\012		else if (get_allocator() != _Right.get_allocator()\012			&& this->_BUF_SIZE <= _Right._Myres)\012			*this = _Right;\012		else\012			{	// not same, clear this and steal from _Right\012			_Tidy(true);\012			if (_Right._Myres < this->_BUF_SIZE)\012				_Traits::move(this->_Bx._Buf, _Right._Bx._Buf,\012					_Right._Mysize + 1);\012			else\012				{	// copy pointer\012				this->_Bx._Ptr = _Right._Bx._Ptr;\012				_Right._Bx._Ptr = 0;\012				}\012			this->_Mysize = _Right._Mysize;\012			this->_Myres = _Right._Myres;\012\012			_Right._Mysize = 0;\012			_Right._Myres = 0;\012			}\012		return (*this);\012		}\012\012	void swap(_Myt&& _Right)\012		{	// exchange contents with movable _Right\012		if (this != &_Right)\012			{	// swap with emptied container\012 #if 0 < _ITERATOR_DEBUG_LEVEL\012			this->_Orphan_all();\012			this->_Swap_all(_Right);\012 #endif /* 0 < _ITERATOR_DEBUG_LEVEL */\012\012			assign(_STD forward<_Myt>(_Right));\012			}\012		}\012\012	~basic_string()\012		{	// destroy the string\012		_Tidy(true);\012		}\012\012	typedef _Traits traits_type;\012	typedef _Alloc allocator_type;\012\012	_PGLOBAL static const size_type npos;	// bad/missing length/position\012\012	_Myt& operator=(const _Myt& _Right)\012		{	// assign _Right\012		return (assign(_Right));\012		}\012\012	_Myt& operator=(const _Elem *_Ptr)\012		{	// assign [_Ptr, <null>)\012		return (assign(_Ptr));\012		}\012\012	_Myt& operator=(_Elem _Ch)\012		{	// assign 1 * _Ch\012		return (assign(1, _Ch));\012		}\012\012	_Myt& operator+=(const _Myt& _Right)\012		{	// append _Right\012		return (append(_Right));\012		}\012\012	_Myt& operator+=(const _Elem *_Ptr)\012		{	// append [_Ptr, <null>)\012		return (append(_Ptr));\012		}\012\012	_Myt& operator+=(_Elem _Ch)\012		{	// append 1 * _Ch\012		return (append((size_type)1, _Ch));\012		}\012\012	_Myt& append(const _Myt& _Right)\012		{	// append _Right\012		return (append(_Right, 0, npos));\012		}\012\012	_Myt& append(const _Myt& _Right,\012		size_type _Roff, size_type _Count)\012		{	// append _Right [_Roff, _Roff + _Count)\012		if (_Right.size() < _Roff)\012			_Xran();	// _Roff off end\012		size_type _Num = _Right.size() - _Roff;\012		if (_Num < _Count)\012			_Count = _Num;	// trim _Count to size\012		if (npos - this->_Mysize <= _Count)\012			_Xlen();	// result too long\012\012		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))\012			{	// make room and append new stuff\012			_Traits::copy(_Myptr() + this->_Mysize,\012				_Right._Myptr() + _Roff, _Count);\012			_Eos(_Num);\012			}\012		return (*this);\012		}\012\012	_Myt& append(const _Elem *_Ptr, size_type _Count)\012		{	// append [_Ptr, _Ptr + _Count)\012 #if _ITERATOR_DEBUG_LEVEL == 2\012		if (_Count != 0)\012			_DEBUG_POINTER(_Ptr);\012 #endif /* _ITERATOR_DEBUG_LEVEL == 2 */\012\012		if (_Inside(_Ptr))\012			return (append(*this, _Ptr - _Myptr(), _Count));	// substring\012		if (npos - this->_Mysize <= _Count)\012			_Xlen();	// result too long\012\012		size_type _Num;\012		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))\012			{	// make room and append new stuff\012			_Traits::copy(_Myptr() + this->_Mysize, _Ptr, _Count);\012			_Eos(_Num);\012			}\012		return (*this);\012		}\012\012	_Myt& append(const _Elem *_Ptr)\012		{	// append [_Ptr, <null>)\012		_DEBUG_POINTER(_Ptr);\012		return (append(_Ptr, _Traits::length(_Ptr)));\012		}\012\012	_Myt& append(size_type _Count, _Elem _Ch)\012		{	// append _Count * _Ch\012		if (npos - this->_Mysize <= _Count)\012			_Xlen();	// result too long\012\012		size_type _Num;\012		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))\012			{	// make room and append new stuff using assign\012			_Chassign(this->_Mysize, _Count, _Ch);\012			_Eos(_Num);\012			}\012		return (*this);\012		}\012\012	template<class _It>\012		_Myt& append(_It _First, _It _Last)\012		{	// append [_First, _Last)\012		return (_Append(_First, _Last, _Iter_cat(_First)));\012		}\012\012	template<class _It>\012		_Myt& _Append(_It _Count, _It _Ch, _Int_iterator_tag)\012		{	// append _Count * _Ch\012		return (append((size_type)_Count, (_Elem)_Ch));\012		}\012\012	template<class _It>\012		_Myt& _Append(_It _First, _It _Last, input_iterator_tag)\012		{	// append [_First, _Last), input iterators\012		return (replace(end(), end(), _First, _Last));\012		}\012\012	_Myt& append(const_pointer _First, const_pointer _Last)\012		{	// append [_First, _Last), const pointers\012		return (replace(end(), end(), _First, _Last));\012		}\012\012	_Myt& append(const_iterator _First, const_iterator _Last)\012		{	// append [_First, _Last), const_iterators\012		return (replace(end(), end(), _First, _Last));\012		}\012\012	_Myt& assign(const _Myt& _Right)\012		{	// assign _Right\012		return (assign(_Right, 0, npos));\012		}\012\012	_Myt& assign(const _Myt& _Right,\012		size_type _Roff, size_type _Count)\012		{	// assign _Right [_Roff, _Roff + _Count)\012		if (_Right.size() < _Roff)\012			_Xran();	// _Roff off end\012		size_type _Num = _Right.size() - _Roff;\012		if (_Count < _Num)\012			_Num = _Count;	// trim _Num to size\012\012		if (this == &_Right)\012			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring\012		else if (_Grow(_Num))\012			{	// make room and assign new stuff\012			_Traits::copy(_Myptr(), _Right._Myptr() + _Roff, _Num);\012			_Eos(_Num);\012			}\012		return (*this);\012		}\012\012	_Myt& assign(const _Elem *_Ptr, size_type _Count)\012		{	// assign [_Ptr, _Ptr + _Count)\012 #if _ITERATOR_DEBUG_LEVEL == 2\012		if (_Count != 0)\012			_DEBUG_POINTER(_Ptr);\012 #endif /* _ITERATOR_DEBUG_LEVEL == 2 */\012\012		if (_Inside(_Ptr))\012			return (assign(*this, _Ptr - _Myptr(), _Count));	// substring\012\012		if (_Grow(_Count))\012			{	// make room and assign new stuff\012			_Traits::copy(_Myptr(), _Ptr, _Count);\012			_Eos(_Count);\012			}\012		return (*this);\012		}\012\012	_Myt& assign(const _Elem *_Ptr)\012		{	// assign [_Ptr, <null>)\012		_DEBUG_POINTER(_Ptr);\012		return (assign(_Ptr, _Traits::length(_Ptr)));\012		}\012\012	_Myt& assign(size_type _Count, _Elem _Ch)\012		{	// assign _Count * _Ch\012		if (_Count == npos)\012			_Xlen();	// result too long\012\012		if (_Grow(_Count))\012			{	// make room and assign new stuff\012			_Chassign(0, _Count, _Ch);\012			_Eos(_Count);\012			}\012		return (*this);\012		}\012\012	template<class _It>\012		_Myt& assign(_It _First, _It _Last)\012		{	// assign [First, _Last)\012		return (_Assign(_First, _Last, _Iter_cat(_First)));\012		}\012\012	template<class _It>\012		_Myt& _Assign(_It _Count, _It _Ch, _Int_iterator_tag)\012		{	// assign _Count * _Ch\012		return (assign((size_type)_Count, (_Elem)_Ch));\012		}\012\012	template<class _It>\012		_Myt& _Assign(_It _First, _It _Last, input_iterator_tag)\012		{	// assign [First, _Last), input iterators\012		return (replace(begin(), end(), _First, _Last));\012		}\012\012	_Myt& assign(const_pointer _First, const_pointer _Last)\012		{	// assign [First, _Last), const pointers\012		return (replace(begin(), end(), _First, _Last));\012		}\012\012	_Myt& assign(const_iterator _First, const_iterator _Last)\012		{	// assign [First, _Last), const_iterators\012		return (replace(begin(), end(), _First, _Last));\012		}\012\012	_Myt& insert(size_type _Off, const _Myt& _Right)\012		{	// insert _Right at _Off\012		return (insert(_Off, _Right, 0, npos));\012		}\012\012	_Myt& insert(size_type _Off,\012		const _Myt& _Right, size_type _Roff, size_type _Count)\012		{	// insert _Right [_Roff, _Roff + _Count) at _Off\012		if (this->_Mysize < _Off || _Right.size() < _Roff)\012			_Xran();	// _Off or _Roff off end\012		size_type _Num = _Right.size() - _Roff;\012		if (_Num < _Count)\012			_Count = _Num;	// trim _Count to size\012		if (npos - this->_Mysize <= _Count)\012			_Xlen();	// result too long\012\012		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))\012			{	// make room and insert new stuff\012			_Traits::move(_Myptr() + _Off + _Count,\012				_Myptr() + _Off, this->_Mysize - _Off);	// empty out hole\012			if (this == &_Right)\012				_Traits::move(_Myptr() + _Off,\012					_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),\012						_Count);	// substring\012			else\012				_Traits::copy(_Myptr() + _Off,\012					_Right._Myptr() + _Roff, _Count);	// fill hole\012			_Eos(_Num);\012			}\012		return (*this);\012		}\012\012	_Myt& insert(size_type _Off,\012		const _Elem *_Ptr, size_type _Count)\012		{	// insert [_Ptr, _Ptr + _Count) at _Off\012 #if _ITERATOR_DEBUG_LEVEL == 2\012		if (_Count != 0)\012			_DEBUG_POINTER(_Ptr);\012 #endif /* _ITERATOR_DEBUG_LEVEL == 2 */\012\012		if (_Inside(_Ptr))\012			return (insert(_Off, *this,\012				_Ptr - _Myptr(), _Count));	// substring\012		if (this->_Mysize < _Off)\012			_Xran();	// _Off off end\012		if (npos - this->_Mysize <= _Count)\012			_Xlen();	// result too long\012		size_type _Num;\012		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))\012			{	// make room and insert new stuff\012			_Traits::move(_Myptr() + _Off + _Count,\012				_Myptr() + _Off, this->_Mysize - _Off);	// empty out hole\012			_Traits::copy(_Myptr() + _Off, _Ptr, _Count);	// fill hole\012			_Eos(_Num);\012			}\012		return (*this);\012		}\012\012	_Myt& insert(size_type _Off, const _Elem *_Ptr)\012		{	// insert [_Ptr, <null>) at _Off\012		_DEBUG_POINTER(_Ptr);\012		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));\012		}\012\012	_Myt& insert(size_type _Off,\012		size_type _Count, _Elem _Ch)\012		{	// insert _Count * _Ch at _Off\012		if (this->_Mysize < _Off)\012			_Xran();	// _Off off end\012		if (npos - this->_Mysize <= _Count)\012			_Xlen();	// result too long\012		size_type _Num;\012		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))\012			{	// make room and insert new stuff\012			_Traits::move(_Myptr() + _Off + _Count,\012				_Myptr() + _Off, this->_Mysize - _Off);	// empty out hole\012			_Chassign(_Off, _Count, _Ch);	// fill hole\012			_Eos(_Num);\012			}\012		return (*this);\012		}\012\012	iterator insert(const_iterator _Where)\012		{	// insert <null> at _Where\012		return (insert(_Where, _Elem()));\012		}\012\012	iterator insert(const_iterator _Where, _Elem _Ch)\012		{	// insert _Ch at _Where\012		size_type _Off = _Pdif(_Where, begin());\012		insert(_Off, 1, _Ch);\012		return (begin() + _Off);\012		}\012\012	void insert(const_iterator _Where, size_type _Count, _Elem _Ch)\012		{	// insert _Count * _Elem at _Where\012		size_type _Off = _Pdif(_Where, begin());\012		insert(_Off, _Count, _Ch);\012		}\012\012	template<class _It>\012		void insert(const_iterator _Where, _It _First, _It _Last)\012		{	// insert [_First, _Last) at _Where\012		_Insert(_Where, _First, _Last, _Iter_cat(_First));\012		}\012\012	template<class _It>\012		void _Insert(const_iterator _Where, _It _Count, _It _Ch,\012			_Int_iterator_tag)\012		{	// insert _Count * _Ch at _Where\012		insert(_Where, (size_type)_Count, (_Elem)_Ch);\012		}\012\012	template<class _It>\012		void _Insert(const_iterator _Where, _It _First, _It _Last,\012			input_iterator_tag)\012		{	// insert [_First, _Last) at _Where, input iterators\012		replace(_Where, _Where, _First, _Last);\012		}\012\012	void insert(const_iterator _Where,\012		const_pointer _First, const_pointer _Last)\012		{	// insert [_First, _Last) at _Where, const pointers\012		replace(_Where, _Where, _First, _Last);\012		}\012\012	void insert(const_iterator _Where,\012		const_iterator _First, const_iterator _Last)\012		{	// insert [_First, _Last) at _Where, const_iterators\012		replace(_Where, _Where, _First, _Last);\012		}\012\012	_Myt& erase(size_type _Off = 0,\012		size_type _Count = npos)\012		{	// erase elements [_Off, _Off + _Count)\012		if (this->_Mysize < _Off)\012			_Xran();	// _Off off end\012		if (this->_Mysize - _Off < _Count)\012			_Count = this->_Mysize - _Off;	// trim _Count\012		if (0 < _Count)\012			{	// move elements down\012			_Traits::move(_Myptr() + _Off, _Myptr() + _Off + _Count,\012				this->_Mysize - _Off - _Count);\012			size_type _Newsize = this->_Mysize - _Count;\012			_Eos(_Newsize);\012			}\012		return (*this);\012		}\012\012	iterator erase(const_iterator _Where)\012		{	// erase element at _Where\012		size_type _Count = _Pdif(_Where, begin());\012		erase(_Count, 1);\012		return (_STRING_ITERATOR(_Myptr() + _Count));\012		}\012\012	iterator erase(const_iterator _First, const_iterator _Last)\012		{	// erase substring [_First, _Last)\012		size_type _Count = _Pdif(_First, begin());\012		erase(_Count, _Pdif(_Last, _First));\012		return (_STRING_ITERATOR(_Myptr() + _Count));\012		}\012\012	void clear()\012		{	// erase all\012		_Eos(0);\012		}\012\012	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)\012		{	// replace [_Off, _Off + _N0) with _Right\012		return (replace(_Off, _N0, _Right, 0, npos));\012		}\012\012	_Myt& replace(size_type _Off,\012		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)\012		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)\012		if (this->_Mysize < _Off || _Right.size() < _Roff)\012			_Xran();	// _Off or _Roff off end\012		if (this->_Mysize - _Off < _N0)\012			_N0 = this->_Mysize - _Off;	// trim _N0 to size\012		size_type _Num = _Right.size() - _Roff;\012		if (_Num < _Count)\012			_Count = _Num;	// trim _Count to size\012		if (npos - _Count <= this->_Mysize - _N0)\012			_Xlen();	// result too long\012\012		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail\012		size_type _Newsize = this->_Mysize + _Count - _N0;\012		if (this->_Mysize < _Newsize)\012			_Grow(_Newsize);\012\012		if (this != &_Right)\012			{	// no overlap, just move down and copy in new stuff\012			_Traits::move(_Myptr() + _Off + _Count,\012				_Myptr() + _Off + _N0, _Nm);	// empty hole\012			_Traits::copy(_Myptr() + _Off,\012				_Right._Myptr() + _Roff, _Count);	// fill hole\012			}\012		else if (_Count <= _N0)\012			{	// hole doesn't get larger, just copy in substring\012			_Traits::move(_Myptr() + _Off,\012				_Myptr() + _Roff, _Count);	// fill hole\012			_Traits::move(_Myptr() + _Off + _Count,\012				_Myptr() + _Off + _N0, _Nm);	// move tail down\012			}\012		else if (_Roff <= _Off)\012			{	// hole gets larger, substring begins before hole\012			_Traits::move(_Myptr() + _Off + _Count,\012				_Myptr() + _Off + _N0, _Nm);	// move tail down\012			_Traits::move(_Myptr() + _Off,\012				_Myptr() + _Roff, _Count);	// fill hole\012			}\012		else if (_Off + _N0 <= _Roff)\012			{	// hole gets larger, substring begins after hole\012			_Traits::move(_Myptr() + _Off + _Count,\012				_Myptr() + _Off + _N0, _Nm);	// move tail down\012			_Traits::move(_Myptr() + _Off,\012				_Myptr() + (_Roff + _Count - _N0), _Count);	// fill hole\012			}\012		else\012			{	// hole gets larger, substring begins in hole\012			_Traits::move(_Myptr() + _Off,\012				_Myptr() + _Roff, _N0);	// fill old hole\012			_Traits::move(_Myptr() + _Off + _Count,\012				_Myptr() + _Off + _N0, _Nm);	// move tail down\012			_Traits::move(_Myptr() + _Off + _N0, _Myptr() + _Roff + _Count,\012				_Count - _N0);	// fill rest of new hole\012			}\012\012		_Eos(_Newsize);\012		return (*this);\012		}\012\012	_Myt& replace(size_type _Off,\012		size_type _N0, const _Elem *_Ptr, size_type _Count)\012		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)\012 #if _ITERATOR_DEBUG_LEVEL == 2\012		if (_Count != 0)\012			_DEBUG_POINTER(_Ptr);\012 #endif /* _ITERATOR_DEBUG_LEVEL == 2 */\012\012		if (_Inside(_Ptr))\012			return (replace(_Off, _N0, *this,\012				_Ptr - _Myptr(), _Count));	// substring, replace carefully\012		if (this->_Mysize < _Off)\012			_Xran();	// _Off off end\012		if (this->_Mysize - _Off < _N0)\012			_N0 = this->_Mysize - _Off;	// trim _N0 to size\012		if (npos - _Count <= this->_Mysize - _N0)\012			_Xlen();	// result too long\012		size_type _Nm = this->_Mysize - _N0 - _Off;\012\012		if (_Count < _N0)\012			_Traits::move(_Myptr() + _Off + _Count,\012				_Myptr() + _Off + _N0, _Nm);	// smaller hole, move tail up\012		size_type _Num;\012		if ((0 < _Count || 0 < _N0)\012			&& _Grow(_Num = this->_Mysize + _Count - _N0))\012			{	// make room and rearrange\012			if (_N0 < _Count)\012				_Traits::move(_Myptr() + _Off + _Count,\012					_Myptr() + _Off + _N0, _Nm);	// move tail down\012			_Traits::copy(_Myptr() + _Off, _Ptr, _Count);	// fill hole\012			_Eos(_Num);\012			}\012		return (*this);\012		}\012\012	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)\012		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)\012		_DEBUG_POINTER(_Ptr);\012		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));\012		}\012\012	_Myt& replace(size_type _Off,\012		size_type _N0, size_type _Count, _Elem _Ch)\012		{	// replace [_Off, _Off + _N0) with _Count * _Ch\012		if (this->_Mysize < _Off)\012			_Xran();	// _Off off end\012		if (this->_Mysize - _Off < _N0)\012			_N0 = this->_Mysize - _Off;	// trim _N0 to size\012		if (npos - _Count <= this->_Mysize - _N0)\012			_Xlen();	// result too long\012		size_type _Nm = this->_Mysize - _N0 - _Off;\012\012		if (_Count < _N0)\012			_Traits::move(_Myptr() + _Off + _Count,\012				_Myptr() + _Off + _N0, _Nm);	// smaller hole, move tail up\012		size_type _Num;\012		if ((0 < _Count || 0 < _N0)\012			&& _Grow(_Num = this->_Mysize + _Count - _N0))\012			{	// make room and rearrange\012			if (_N0 < _Count)\012				_Traits::move(_Myptr() + _Off + _Count,\012					_Myptr() + _Off + _N0, _Nm);	// move tail down\012			_Chassign(_Off, _Count, _Ch);	// fill hole\012			_Eos(_Num);\012			}\012		return (*this);\012		}\012\012	_Myt& replace(const_iterator _First, const_iterator _Last,\012		const _Myt& _Right)\012		{	// replace [_First, _Last) with _Right\012		return (replace(\012			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));\012		}\012\012	_Myt& replace(const_iterator _First, const_iterator _Last,\012		const _Elem *_Ptr, size_type _Count)\012		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)\012		return (replace(\012			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));\012		}\012\012	_Myt& replace(const_iterator _First, const_iterator _Last,\012		const _Elem *_Ptr)\012		{	// replace [_First, _Last) with [_Ptr, <null>)\012		return (replace(\012			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));\012		}\012\012	_Myt& replace(const_iterator _First, const_iterator _Last,\012		size_type _Count, _Elem _Ch)\012		{	// replace [_First, _Last) with _Count * _Ch\012		return (replace(\012			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));\012		}\012\012	template<class _It>\012		_Myt& replace(const_iterator _First, const_iterator _Last,\012			_It _First2, _It _Last2)\012		{	// replace [_First, _Last) with [_First2, _Last2)\012		return (_Replace(_First, _Last,\012			_First2, _Last2, _Iter_cat(_First2)));\012		}\012\012	template<class _It>\012		_Myt& _Replace(const_iterator _First, const_iterator _Last,\012			_It _Count, _It _Ch, _Int_iterator_tag)\012		{	// replace [_First, _Last) with _Count * _Ch\012		return (replace(_First, _Last, (size_type)_Count, (_Elem)_Ch));\012		}\012\012	template<class _It>\012		_Myt& _Replace(const_iterator _First, const_iterator _Last,\012			_It _First2, _It _Last2, input_iterator_tag)\012		{	// replace [_First, _Last) with [_First2, _Last2), input iterators\012		_Myt _Right(_First2, _Last2);\012		replace(_First, _Last, _Right);\012		return (*this);\012		}\012\012	_Myt& replace(const_iterator _First, const_iterator _Last,\012		const_pointer _First2, const_pointer _Last2)\012		{	// replace [_First, _Last) with [_First2, _Last2), const pointers\012		if (_First2 == _Last2)\012			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));\012		else\012			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),\012				&*_First2, _Last2 - _First2);\012		return (*this);\012		}\012\012	_Myt& replace(const_iterator _First, const_iterator _Last,\012		const_iterator _First2, const_iterator _Last2)\012		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators\012		if (_First2 == _Last2)\012			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));\012		else\012			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),\012				&*_First2, _Last2 - _First2);\012		return (*this);\012		}\012\012	iterator begin()\012		{	// return iterator for beginning of mutable sequence\012		return (_STRING_ITERATOR(_Myptr()));\012		}\012\012	const_iterator begin() const\012		{	// return iterator for beginning of nonmutable sequence\012		return (_STRING_CONST_ITERATOR(_Myptr()));\012		}\012\012	iterator end()\012		{	// return iterator for end of mutable sequence\012		return (_STRING_ITERATOR(_Myptr() + this->_Mysize));\012		}\012\012	const_iterator end() const\012		{	// return iterator for end of nonmutable sequence\012		return (_STRING_CONST_ITERATOR(_Myptr() + this->_Mysize));\012		}\012\012	reverse_iterator rbegin()\012		{	// return iterator for beginning of reversed mutable sequence\012		return (reverse_iterator(end()));\012		}\012\012	const_reverse_iterator rbegin() const\012		{	// return iterator for beginning of reversed nonmutable sequence\012		return (const_reverse_iterator(end()));\012		}\012\012	reverse_iterator rend()\012		{	// return iterator for end of reversed mutable sequence\012		return (reverse_iterator(begin()));\012		}\012\012	const_reverse_iterator rend() const\012		{	// return iterator for end of reversed nonmutable sequence\012		return (const_reverse_iterator(begin()));\012		}\012\012 #if _HAS_CPP0X\012	const_iterator cbegin() const\012		{	// return iterator for beginning of nonmutable sequence\012		return (((const _Myt *)this)->begin());\012		}\012\012	const_iterator cend() const\012		{	// return iterator for end of nonmutable sequence\012		return (((const _Myt *)this)->end());\012		}\012\012	const_reverse_iterator crbegin() const\012		{	// return iterator for beginning of reversed nonmutable sequence\012		return (((const _Myt *)this)->rbegin());\012		}\012\012	const_reverse_iterator crend() const\012		{	// return iterator for ebd of reversed nonmutable sequence\012		return (((const _Myt *)this)->rend());\012		}\012\012	void shrink_to_fit()\012		{	// reduce capacity\012		if (size() < capacity())\012			{	// worth shrinking, do it\012			_Myt _Tmp(*this);\012			swap(_Tmp);\012			}\012		}\012 #endif /* _HAS_CPP0X */\012\012	reference at(size_type _Off)\012		{	// subscript mutable sequence with checking\012		if (this->_Mysize <= _Off)\012			_Xran();	// _Off off end\012		return (_Myptr()[_Off]);\012		}\012\012	const_reference at(size_type _Off) const\012		{	// subscript nonmutable sequence with checking\012		if (this->_Mysize <= _Off)\012			_Xran();	// _Off off end\012		return (_Myptr()[_Off]);\012		}\012\012	reference operator[](size_type _Off)\012		{	// subscript mutable sequence\012 #if _ITERATOR_DEBUG_LEVEL == 2\012\012		if (this->_Mysize <= _Off)\012\012			_DEBUG_ERROR(\"string subscript out of range\");\012\012 #elif _ITERATOR_DEBUG_LEVEL == 1\012		_SCL_SECURE_VALIDATE_RANGE(_Off < this->_Mysize);\012 #endif /* _ITERATOR_DEBUG_LEVEL == 2 */\012\012		return (_Myptr()[_Off]);\012		}\012\012	const_reference operator[](size_type _Off) const\012		{	// subscript nonmutable sequence\012 #if _ITERATOR_DEBUG_LEVEL == 2\012		if (this->_Mysize < _Off)	// sic\012			_DEBUG_ERROR(\"string subscript out of range\");\012\012 #elif _ITERATOR_DEBUG_LEVEL == 1\012		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic\012 #endif /* _ITERATOR_DEBUG_LEVEL == 2 */\012\012		return (_Myptr()[_Off]);\012		}\012\012	void push_back(_Elem _Ch)\012		{	// insert element at end\012		insert(end(), _Ch);\012		}\012\012 #if _HAS_CPP0X\012	void pop_back()\012		{	// erase element at end\012		erase(this->_Mysize - 1);	// throws if _Mysize == 0\012		}\012\012	reference front()\012		{	// return first element of mutable sequence\012		return (*begin());\012		}\012\012	const_reference front() const\012		{	// return first element of nonmutable sequence\012		return (*begin());\012		}\012\012	reference back()\012		{	// return last element of mutable sequence\012		return (*(end() - 1));\012		}\012\012	const_reference back() const\012		{	// return last element of nonmutable sequence\012		return (*(end() - 1));\012		}\012 #endif /* _HAS_CPP0X */\012\012	const _Elem *c_str() const\012		{	// return pointer to null-terminated nonmutable array\012		return (_Myptr());\012		}\012\012	const _Elem *data() const\012		{	// return pointer to nonmutable array\012		return (c_str());\012		}\012\012	size_type length() const\012		{	// return length of sequence\012		return (this->_Mysize);\012		}\012\012	size_type size() const\012		{	// return length of sequence\012		return (this->_Mysize);\012		}\012\012	size_type max_size() const\012		{	// return maximum possible length of sequence\012		size_type _Num = this->_Alval.max_size();\012		return (_Num <= 1 ? 1 : _Num - 1);\012		}\012\012	void resize(size_type _Newsize)\012		{	// determine new length, padding with null elements as needed\012		resize(_Newsize, _Elem());\012		}\012\012	void resize(size_type _Newsize, _Elem _Ch)\012		{	// determine new length, padding with _Ch elements as needed\012		if (_Newsize <= this->_Mysize)\012			erase(_Newsize);\012		else\012			append(_Newsize - this->_Mysize, _Ch);\012		}\012\012	size_type capacity() const\012		{	// return current length of allocated storage\012		return (this->_Myres);\012		}\012\012	void reserve(size_type _Newcap = 0)\012		{	// determine new minimum length of allocated storage\012		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)\012			{	// change reservation\012			size_type _Size = this->_Mysize;\012			if (_Grow(_Newcap, true))\012				_Eos(_Size);\012			}\012		}\012\012	bool empty() const\012		{	// test if sequence is empty\012		return (this->_Mysize == 0);\012		}\012\012	_SCL_INSECURE_DEPRECATE\012\012	size_type copy(_Elem *_Ptr,\012		size_type _Count, size_type _Off = 0) const\012		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)\012 #if _ITERATOR_DEBUG_LEVEL == 2\012		if (_Count != 0)\012			_DEBUG_POINTER(_Ptr);\012 #endif /* _ITERATOR_DEBUG_LEVEL == 2 */\012\012		if (this->_Mysize < _Off)\012			_Xran();	// _Off off end\012		if (this->_Mysize - _Off < _Count)\012			_Count = this->_Mysize - _Off;\012		_Traits::copy(_Ptr, _Myptr() + _Off, _Count);\012		return (_Count);\012		}\012\012	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,\012		size_type _Count, size_type _Off = 0) const\012		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)\012 #if _ITERATOR_DEBUG_LEVEL == 2\012		if (_Count != 0)\012			_DEBUG_POINTER(_Dest);\012 #endif /* _ITERATOR_DEBUG_LEVEL == 2 */\012\012		if (this->_Mysize < _Off)\012			_Xran();	// _Off off end\012		if (this->_Mysize - _Off < _Count)\012			_Count = this->_Mysize - _Off;\012		_Traits::_Copy_s(_Dest, _Dest_size, _Myptr() + _Off, _Count);\012		return (_Count);\012		}\012\012	void swap(_Myt& _Right)\012		{	// exchange contents with _Right\012		if (this == &_Right)\012			;	// same object, do nothing\012		else if (this->_Alval == _Right._Alval)\012			{	// same allocator, swap control information\012 #if 0 < _ITERATOR_DEBUG_LEVEL\012			this->_Swap_all(_Right);\012 #endif /* 0 < _ITERATOR_DEBUG_LEVEL */\012\012			_STD swap(this->_Bx, _Right._Bx);\012			_STD swap(this->_Mysize, _Right._Mysize);\012			_STD swap(this->_Myres, _Right._Myres);\012			}\012		else\012			{	// different allocator, do multiple assigns\012			_Myt _Tmp = *this;\012\012			*this = _Right;\012			_Right = _Tmp;\012			}\012		}\012\012	size_type find(const _Myt& _Right, size_type _Off = 0) const\012		{	// look for _Right beginnng at or after _Off\012		return (find(_Right._Myptr(), _Off, _Right.size()));\012		}\012\012	size_type find(const _Elem *_Ptr,\012		size_type _Off, size_type _Count) const\012		{	// look for [_Ptr, _Ptr + _Count) beginnng at or after _Off\012 #if _ITERATOR_DEBUG_LEVEL == 2\012		if (_Count != 0)\012			_DEBUG_POINTER(_Ptr);\012 #endif /* _ITERATOR_DEBUG_LEVEL == 2 */\012\012		if (_Count == 0 && _Off <= this->_Mysize)\012			return (_Off);	// null string always matches (if inside string)\012\012		size_type _Nm;\012		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))\012			{	// room for match, look for it\012			const _Elem *_Uptr, *_Vptr;\012			for (_Nm -= _Count - 1, _Vptr = _Myptr() + _Off;\012				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;\012				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)\012				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)\012					return (_Uptr - _Myptr());	// found a match\012			}\012\012		return (npos);	// no match\012		}\012\012	size_type find(const _Elem *_Ptr, size_type _Off = 0) const\012		{	// look for [_Ptr, <null>) beginnng at or after _Off\012		_DEBUG_POINTER(_Ptr);\012		return (find(_Ptr, _Off, _Traits::length(_Ptr)));\012		}\012\012	size_type find(_Elem _Ch, size_type _Off = 0) const\012		{	// look for _Ch at or after _Off\012		return (find((const _Elem *)&_Ch, _Off, 1));\012		}\012\012	size_type rfind(const _Myt& _Right, size_type _Off = npos) const\012		{	// look for _Right beginning before _Off\012		return (rfind(_Right._Myptr(), _Off, _Right.size()));\012		}\012\012	size_type rfind(const _Elem *_Ptr,\012		size_type _Off, size_type _Count) const\012		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off\012 #if _ITERATOR_DEBUG_LEVEL == 2\012		if (_Count != 0)\012			_DEBUG_POINTER(_Ptr);\012 #endif /* _ITERATOR_DEBUG_LEVEL == 2 */\012\012		if (_Count == 0)\012			return (_Off < this->_Mysize ? _Off\012				: this->_Mysize);	// null always matches\012		if (_Count <= this->_Mysize)\012			{	// room for match, look for it\012			const _Elem *_Uptr = _Myptr() +\012				(_Off < this->_Mysize - _Count ? _Off\012					: this->_Mysize - _Count);\012			for (; ; --_Uptr)\012				if (_Traits::eq(*_Uptr, *_Ptr)\012					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)\012					return (_Uptr - _Myptr());	// found a match\012				else if (_Uptr == _Myptr())\012					break;	// at beginning, no more chance for match\012			}\012\012		return (npos);	// no match\012		}\012\012	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const\012		{	// look for [_Ptr, <null>) beginning before _Off\012		_DEBUG_POINTER(_Ptr);\012		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));\012		}\012\012	size_type rfind(_Elem _Ch, size_type _Off = npos) const\012		{	// look for _Ch before _Off\012		return (rfind((const _Elem *)&_Ch, _Off, 1));\012		}\012\012	size_type find_first_of(const _Myt& _Right,\012		size_type _Off = 0) const\012		{	// look for one of _Right at or after _Off\012		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));\012		}\012\012	size_type find_first_of(const _Elem *_Ptr,\012		size_type _Off, size_type _Count) const\012		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off\012 #if _ITERATOR_DEBUG_LEVEL == 2\012		if (_Count != 0)\012			_DEBUG_POINTER(_Ptr);\012 #endif /* _ITERATOR_DEBUG_LEVEL == 2 */\012\012		if (0 < _Count && _Off < this->_Mysize)\012			{	// room for match, look for it\012			const _Elem *const _Vptr = _Myptr() + this->_Mysize;\012			for (const _Elem *_Uptr = _Myptr() + _Off; _Uptr < _Vptr; ++_Uptr)\012				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)\012					return (_Uptr - _Myptr());	// found a match\012			}\012\012		return (npos);	// no match\012		}\012\012	size_type find_first_of(const _Elem *_Ptr, size_type _Off = 0) const\012		{	// look for one of [_Ptr, <null>) at or after _Off\012		_DEBUG_POINTER(_Ptr);\012		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));\012		}\012\012	size_type find_first_of(_Elem _Ch, size_type _Off = 0) const\012		{	// look for _Ch at or after _Off\012		return (find((const _Elem *)&_Ch, _Off, 1));\012		}\012\012	size_type find_last_of(const _Myt& _Right,\012		size_type _Off = npos) const\012		{	// look for one of _Right before _Off\012		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));\012		}\012\012	size_type find_last_of(const _Elem *_Ptr,\012		size_type _Off, size_type _Count) const\012		{	// look for one of [_Ptr, _Ptr + _Count) before _Off\012 #if _ITERATOR_DEBUG_LEVEL == 2\012		if (_Count != 0)\012			_DEBUG_POINTER(_Ptr);\012 #endif /* _ITERATOR_DEBUG_LEVEL == 2 */\012\012		if (0 < _Count && 0 < this->_Mysize)\012			{	// worth searching, do it\012			const _Elem *_Uptr = _Myptr()\012				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);\012			for (; ; --_Uptr)\012				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)\012					return (_Uptr - _Myptr());	// found a match\012				else if (_Uptr == _Myptr())\012					break;	// at beginning, no more chance for match\012			}\012\012		return (npos);	// no match\012		}\012\012	size_type find_last_of(const _Elem *_Ptr,\012		size_type _Off = npos) const\012		{	// look for one of [_Ptr, <null>) before _Off\012		_DEBUG_POINTER(_Ptr);\012		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));\012		}\012\012	size_type find_last_of(_Elem _Ch, size_type _Off = npos) const\012		{	// look for _Ch before _Off\012		return (rfind((const _Elem *)&_Ch, _Off, 1));\012		}\012\012	size_type find_first_not_of(const _Myt& _Right,\012		size_type _Off = 0) const\012		{	// look for none of _Right at or after _Off\012		return (find_first_not_of(_Right._Myptr(), _Off,\012			_Right.size()));\012		}\012\012	size_type find_first_not_of(const _Elem *_Ptr,\012		size_type _Off, size_type _Count) const\012		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off\012 #if _ITERATOR_DEBUG_LEVEL == 2\012		if (_Count != 0)\012			_DEBUG_POINTER(_Ptr);\012 #endif /* _ITERATOR_DEBUG_LEVEL == 2 */\012\012		if (_Off < this->_Mysize)\012			{	// room for match, look for it\012			const _Elem *const _Vptr = _Myptr() + this->_Mysize;\012			for (const _Elem *_Uptr = _Myptr() + _Off; _Uptr < _Vptr; ++_Uptr)\012				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)\012					return (_Uptr - _Myptr());\012			}\012		return (npos);\012		}\012\012	size_type find_first_not_of(const _Elem *_Ptr,\012		size_type _Off = 0) const\012		{	// look for one of [_Ptr, <null>) at or after _Off\012		_DEBUG_POINTER(_Ptr);\012		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));\012		}\012\012	size_type find_first_not_of(_Elem _Ch, size_type _Off = 0) const\012		{	// look for non _Ch at or after _Off\012		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));\012		}\012\012	size_type find_last_not_of(const _Myt& _Right,\012		size_type _Off = npos) const\012		{	// look for none of _Right before _Off\012		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));\012		}\012\012	size_type find_last_not_of(const _Elem *_Ptr,\012		size_type _Off, size_type _Count) const\012		{	// look for none of [_Ptr, _Ptr + _Count) before _Off\012 #if _ITERATOR_DEBUG_LEVEL == 2\012		if (_Count != 0)\012			_DEBUG_POINTER(_Ptr);\012 #endif /* _ITERATOR_DEBUG_LEVEL == 2 */\012\012		if (0 < this->_Mysize)\012			{	// worth searching, do it\012			const _Elem *_Uptr = _Myptr()\012				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);\012			for (; ; --_Uptr)\012				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)\012					return (_Uptr - _Myptr());\012				else if (_Uptr == _Myptr())\012					break;\012			}\012		return (npos);\012		}\012\012	size_type find_last_not_of(const _Elem *_Ptr,\012		size_type _Off = npos) const\012		{	// look for none of [_Ptr, <null>) before _Off\012		_DEBUG_POINTER(_Ptr);\012		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));\012		}\012\012	size_type find_last_not_of(_Elem _Ch, size_type _Off = npos) const\012		{	// look for non _Ch before _Off\012		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));\012		}\012\012	_Myt substr(size_type _Off = 0, size_type _Count = npos) const\012		{	// return [_Off, _Off + _Count) as new string\012		return (_Myt(*this, _Off, _Count, get_allocator()));\012		}\012\012	int compare(const _Myt& _Right) const\012		{	// compare [0, _Mysize) with _Right\012		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));\012		}\012\012	int compare(size_type _Off, size_type _N0,\012		const _Myt& _Right) const\012		{	// compare [_Off, _Off + _N0) with _Right\012		return (compare(_Off, _N0, _Right, 0, npos));\012		}\012\012	int compare(size_type _Off,\012		size_type _N0, const _Myt& _Right,\012		size_type _Roff, size_type _Count) const\012		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)\012		if (_Right.size() < _Roff)\012			_Xran();	// _Off off end\012		if (_Right._Mysize - _Roff < _Count)\012			_Count = _Right._Mysize - _Roff;	// trim _Count to size\012		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));\012		}\012\012	int compare(const _Elem *_Ptr) const\012		{	// compare [0, _Mysize) with [_Ptr, <null>)\012		_DEBUG_POINTER(_Ptr);\012		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));\012		}\012\012	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const\012		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)\012		_DEBUG_POINTER(_Ptr);\012		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));\012		}\012\012	int compare(size_type _Off,\012		size_type _N0, const _Elem *_Ptr, size_type _Count) const\012		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)\012 #if _ITERATOR_DEBUG_LEVEL == 2\012		if (_Count != 0)\012			_DEBUG_POINTER(_Ptr);\012 #endif /* _ITERATOR_DEBUG_LEVEL == 2 */\012\012		if (this->_Mysize < _Off)\012			_Xran();	// _Off off end\012		if (this->_Mysize - _Off < _N0)\012			_N0 = this->_Mysize - _Off;	// trim _N0 to size\012\012		size_type _Ans = _Traits::compare(_Myptr() + _Off, _Ptr,\012			_N0 < _Count ? _N0 : _Count);\012		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1\012			: _N0 == _Count ? 0 : +1);\012		}\012\012	allocator_type get_allocator() const\012		{	// return allocator object for values\012		return (this->_Alval);\012		}\012\012	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)\012		{	// assign _Count copies of _Ch beginning at _Off\012		if (_Count == 1)\012			_Traits::assign(*(_Myptr() + _Off), _Ch);\012		else\012			_Traits::assign(_Myptr() + _Off, _Count, _Ch);\012		}\012\012	void _Copy(size_type _Newsize, size_type _Oldlen)\012		{	// copy _Oldlen elements to newly allocated buffer\012		size_type _Newres = _Newsize | this->_ALLOC_MASK;\012		if (max_size() < _Newres)\012			_Newres = _Newsize;	// undo roundup if too big\012		else if (this->_Myres / 2 <= _Newres / 3)\012			;\012		else if (this->_Myres <= max_size() - this->_Myres / 2)\012			_Newres = this->_Myres\012				+ this->_Myres / 2;	// grow exponentially if possible\012		else\012			_Newres = max_size();	// settle for max_size()\012\012		_Elem *_Ptr;\012		_TRY_BEGIN\012			_Ptr = this->_Alval.allocate(_Newres + 1);\012		_CATCH_ALL\012			_Newres = _Newsize;	// allocation failed, undo roundup and retry\012			_TRY_BEGIN\012				_Ptr = this->_Alval.allocate(_Newres + 1);\012			_CATCH_ALL\012			_Tidy(true);	// failed again, discard storage and reraise\012			_RERAISE;\012			_CATCH_END\012		_CATCH_END\012\012		if (0 < _Oldlen)\012			_Traits::copy(_Ptr, _Myptr(), _Oldlen);	// copy existing elements\012		_Tidy(true);\012		this->_Bx._Ptr = _Ptr;\012		this->_Myres = _Newres;\012		_Eos(_Oldlen);\012		}\012\012	void _Eos(size_type _Newsize)\012		{	// set new length and null terminator\012		_Traits::assign(_Myptr()[this->_Mysize = _Newsize], _Elem());\012		}\012\012	bool _Grow(size_type _Newsize,\012		bool _Trim = false)\012		{	// ensure buffer is big enough, trim to size if _Trim is true\012		if (max_size() < _Newsize)\012			_Xlen();	// result too long\012		if (this->_Myres < _Newsize)\012			_Copy(_Newsize, this->_Mysize);	// reallocate to grow\012		else if (_Trim && _Newsize < this->_BUF_SIZE)\012			_Tidy(true,	// copy and deallocate if trimming to small string\012				_Newsize < this->_Mysize ? _Newsize : this->_Mysize);\012		else if (_Newsize == 0)\012			_Eos(0);	// new size is zero, just null terminate\012		return (0 < _Newsize);	// return true only if more work to do\012		}\012\012	bool _Inside(const _Elem *_Ptr)\012		{	// test if _Ptr points inside string\012		if (_Ptr == 0 || _Ptr < _Myptr() || _Myptr() + this->_Mysize <= _Ptr)\012			return (false);	// don't ask\012		else\012			return (true);\012		}\012\012	static size_type _Pdif(const_iterator _P2,\012		const_iterator _P1)\012		{	// compute safe iterator difference\012		return (_STRING_ITER_BASE(_P2) == 0 ? 0 : _P2 - _P1);\012		}\012\012	void _Tidy(bool _Built = false,\012		size_type _Newsize = 0)\012		{	// initialize buffer, deallocating any storage\012		if (!_Built)\012			;\012		else if (this->_BUF_SIZE <= this->_Myres)\012			{	// copy any leftovers to small buffer and deallocate\012			_Elem *_Ptr = this->_Bx._Ptr;\012			if (0 < _Newsize)\012				_Traits::copy(this->_Bx._Buf, _Ptr, _Newsize);\012			this->_Alval.deallocate(_Ptr, this->_Myres + 1);\012			}\012		this->_Myres = this->_BUF_SIZE - 1;\012		_Eos(_Newsize);\012		}\012\012	_Elem *_Myptr()\012		{	// determine current pointer to buffer for mutable string\012		return (this->_BUF_SIZE <= this->_Myres ? this->_Bx._Ptr\012			: this->_Bx._Buf);\012		}\012\012	const _Elem *_Myptr() const\012		{	// determine current pointer to buffer for nonmutable string\012		return (this->_BUF_SIZE <= this->_Myres ? this->_Bx._Ptr\012			: this->_Bx._Buf);\012		}\012\012	__declspec(noreturn) void _Xlen() const\012		{	// report a length_error\012		_Xlength_error(\"string too long\");\012		}\012\012	__declspec(noreturn) void _Xran() const\012		{	// report an out_of_range error\012		_Xout_of_range(\"invalid string position\");\012		}\012	};\012\012		// STATIC npos OBJECT\012template<class _Elem,\012	class _Traits,\012	class _Alloc>\012	_PGLOBAL const typename basic_string<_Elem, _Traits, _Alloc>::size_type\012		basic_string<_Elem, _Traits, _Alloc>::npos =\012			(typename basic_string<_Elem, _Traits, _Alloc>::size_type)(-1);\012\012		// basic_string TEMPLATE OPERATORS\012\012template<class _Elem,\012	class _Traits,\012	class _Alloc> inline\012	void swap(basic_string<_Elem, _Traits, _Alloc>& _Left,\012		basic_string<_Elem, _Traits, _Alloc>& _Right)\012	{	// swap _Left and _Right strings\012	_Left.swap(_Right);\012	}\012\012template<class _Elem,\012	class _Traits,\012	class _Alloc> inline\012	void swap(basic_string<_Elem, _Traits, _Alloc>& _Left,\012		basic_string<_Elem, _Traits, _Alloc>&& _Right)\012	{	// swap _Left and _Right strings\012	_Left.swap(_Right);\012	}\012\012template<class _Elem,\012	class _Traits,\012	class _Alloc> inline\012	void swap(basic_string<_Elem, _Traits, _Alloc>&& _Left,\012		basic_string<_Elem, _Traits, _Alloc>& _Right)\012	{	// swap _Left and _Right strings\012	_Right.swap(_Left);\012	}\012\012typedef basic_string<char, char_traits<char>, allocator<char> >\012	string;\012typedef basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >\012	wstring;\012\012 #if _HAS_CPP0X\012typedef basic_string<char16_t, char_traits<char16_t>, allocator<char16_t> >\012	u16string;\012typedef basic_string<char32_t, char_traits<char32_t>, allocator<char32_t> >\012	u32string;\012 #endif /* _HAS_CPP0X */\012_STD_END\012\012 #pragma warning(pop)\012 #pragma pack(pop)\012\012#endif /* RC_INVOKED */\012#endif /* _XSTRING */\012\012/*\012 * Copyright (c) 1992-2009 by P.J. Plauger.  ALL RIGHTS RESERVED.\012 * Consult your license regarding permissions and restrictions.\012V5.20:0009 */\012"}, {"path":"C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/xutility", "name":"xutility", "has_active_debug_locs":true, "absName":"c:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/xutility", "content":"// xutility internal header\012#pragma once\012#ifndef _XUTILITY_\012#define _XUTILITY_\012#ifndef RC_INVOKED\012#include <climits>\012#include <cstdlib>\012#include <utility>\012\012 #pragma pack(push,_CRT_PACKING)\012 #pragma warning(push,3)\012\012_STD_BEGIN\012		// MACRO DEBUG_ERROR\012\012 #if _ITERATOR_DEBUG_LEVEL == 2\012\012  #define _DEBUG_ERROR(mesg)	\\\012	_DEBUG_ERROR2(mesg, __FILEW__, __LINE__)\012  #define _DEBUG_ERROR2(mesg, file, line)	\\\012	_Debug_message(L ## mesg, file, line)\012\012typedef const wchar_t *_Dbfile_t;\012typedef unsigned int _Dbline_t;\012\012_CRTIMP2_PURE void __CLRCALL_PURE_OR_CDECL _Debug_message(const wchar_t *,\012	const wchar_t *, unsigned int);\012\012 #else /* _ITERATOR_DEBUG_LEVEL == 2 */\012  #define _DEBUG_ERROR(mesg)\012 #endif /* _ITERATOR_DEBUG_LEVEL == 2 */\012\012		// CLASSES _Container_base*, _Iterator_base*\012struct _CRTIMP2_PURE _Container_base0\012	{	// base of all containers\012	void _Orphan_all()\012		{	// orphan all iterators\012		}\012\012	void _Swap_all(_Container_base0&)\012		{	// swap all iterators\012		}\012	};\012\012struct _Iterator_base0\012	{	// base of all iterators\012	void _Adopt(const void *)\012		{	// adopt this iterator by parent\012		}\012\012	const _Container_base0 *_Getcont() const\012		{	// get owning container\012		return (0);\012		}\012	};\012\012struct _Container_base12;\012struct _Iterator_base12;\012\012		// CLASS _Container_proxy\012struct _Container_proxy\012	{	// store head of iterator chain and back pointer\012	_Container_proxy()\012		: _Mycont(0), _Myfirstiter(0)\012		{	// construct from pointers\012		}\012\012	const _Container_base12 *_Mycont;\012	_Iterator_base12 *_Myfirstiter;\012	};\012\012struct _CRTIMP2_PURE _Container_base12\012	{	// store pointer to _Container_proxy\012public:\012	_Container_base12()\012		: _Myproxy(0)\012		{	// construct childless container\012		}\012\012	_Container_base12(const _Container_base12&)\012		: _Myproxy(0)\012		{	// copy a container\012		}\012\012	_Container_base12& operator=(const _Container_base12&)\012		{	// assign a container\012		return (*this);\012		}\012\012	~_Container_base12()\012		{	// destroy the container\012		_Orphan_all();\012		}\012\012	_Iterator_base12 **_Getpfirst() const\012		{	// get address of iterator chain\012		return (_Myproxy == 0 ? 0 : &_Myproxy->_Myfirstiter);\012		}\012\012	void _Orphan_all();	// orphan all iterators\012	void _Swap_all(_Container_base12&);	// swap all iterators\012\012	_Container_proxy *_Myproxy;\012	};\012\012struct _Iterator_base12\012	{	// store links to container proxy, next iterator\012public:\012	_Iterator_base12()\012		: _Myproxy(0), _Mynextiter(0)\012		{	// construct orphaned iterator\012		}\012\012	_Iterator_base12(const _Iterator_base12& _Right)\012		: _Myproxy(0), _Mynextiter(0)\012		{	// copy an iterator\012		*this = _Right;\012		}\012\012	_Iterator_base12& operator=(const _Iterator_base12& _Right)\012		{	// assign an iterator\012		if (_Myproxy != _Right._Myproxy)\012			_Adopt(_Right._Myproxy->_Mycont);\012		return (*this);\012		}\012\012	~_Iterator_base12()\012		{	// destroy the iterator\012 #if _ITERATOR_DEBUG_LEVEL == 2\012		_Lockit _Lock(_LOCK_DEBUG);\012		_Orphan_me();\012 #endif /* _ITERATOR_DEBUG_LEVEL == 2 */\012		}\012\012	void _Adopt(const _Container_base12 *_Parent)\012		{	// adopt this iterator by parent\012		if (_Parent != 0)\012			{	// have a parent, do adoption\012			_Container_proxy *_Parent_proxy = _Parent->_Myproxy;\012\012 #if _ITERATOR_DEBUG_LEVEL == 2\012			if (_Myproxy != _Parent_proxy)\012				{	// change parentage\012				_Lockit _Lock(_LOCK_DEBUG);\012				_Orphan_me();\012				_Mynextiter = _Parent_proxy->_Myfirstiter;\012				_Parent_proxy->_Myfirstiter = this;\012				_Myproxy = _Parent_proxy;\012				}\012 #else /* _ITERATOR_DEBUG_LEVEL == 2 */\012			_Myproxy = _Parent_proxy;\012 #endif /* _ITERATOR_DEBUG_LEVEL == 2 */\012			}\012		}\012\012	void _Clrcont()\012		{	// disown owning container\012		_Myproxy = 0;\012		}\012\012	const _Container_base12 *_Getcont() const\012		{	// get owning container\012		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);\012		}\012\012	_Iterator_base12 **_Getpnext()\012		{	// get address of remaining iterator chain\012		return (&_Mynextiter);\012		}\012\012	void _Orphan_me()\012		{	// cut ties with parent\012 #if _ITERATOR_DEBUG_LEVEL == 2\012		if (_Myproxy != 0)\012			{	// adopted, remove self from list\012			_Iterator_base12 **_Pnext = &_Myproxy->_Myfirstiter;\012			while (*_Pnext != 0 && *_Pnext != this)\012				_Pnext = &(*_Pnext)->_Mynextiter;\012\012			if (*_Pnext == 0)\012				_DEBUG_ERROR(\"ITERATOR LIST CORRUPTED!\");\012			*_Pnext = _Mynextiter;\012			_Myproxy = 0;\012			}\012 #endif /* _ITERATOR_DEBUG_LEVEL == 2 */\012		}\012\012	_Container_proxy *_Myproxy;\012	_Iterator_base12 *_Mynextiter;\012	};\012\012		// MEMBER FUNCTIONS FOR _Container_base12\012inline void _Container_base12::_Orphan_all()\012	{	// orphan all iterators\012 #if _ITERATOR_DEBUG_LEVEL == 2\012	if (_Myproxy != 0)\012		{	// proxy allocated, drain it\012		_Lockit _Lock(_LOCK_DEBUG);\012\012		for (_Iterator_base12 **_Pnext = &_Myproxy->_Myfirstiter;\012			*_Pnext != 0; *_Pnext = (*_Pnext)->_Mynextiter)\012			(*_Pnext)->_Myproxy = 0;\012		_Myproxy->_Myfirstiter = 0;\012		}\012 #endif /* _ITERATOR_DEBUG_LEVEL == 2 */\012	}\012\012inline void _Container_base12::_Swap_all(_Container_base12& _Right)\012	{	// swap all iterators\012 #if _ITERATOR_DEBUG_LEVEL == 2\012	_Lockit _Lock(_LOCK_DEBUG);\012 #endif /* _ITERATOR_DEBUG_LEVEL == 2 */\012\012	_Container_proxy *_Temp = _Myproxy;\012	_Myproxy = _Right._Myproxy;\012	_Right._Myproxy = _Temp;\012\012	if (_Myproxy != 0)\012		_Myproxy->_Mycont = (_Container_base12 *)this;\012	if (_Right._Myproxy != 0)\012		_Right._Myproxy->_Mycont = (_Container_base12 *)&_Right;\012	}\012\012 #if _ITERATOR_DEBUG_LEVEL == 0\012typedef _Container_base0 _Container_base;\012typedef _Iterator_base0 _Iterator_base;\012 #else /* _ITERATOR_DEBUG_LEVEL == 0 */\012typedef _Container_base12 _Container_base;\012typedef _Iterator_base12 _Iterator_base;\012 #endif /* _ITERATOR_DEBUG_LEVEL == 0 */\012\012		// TEMPLATE FUNCTION _Has_unchecked_type AND FRIENDS\012\012 #define _UNCHECKED_TYPE(_Iter) \\\012	typename _Get_unchecked_type<_Iter>::type\012\012_STD tr1::_No _Has_unchecked_type(...);\012\012template<class _Ty>\012	_STD tr1::_Yes _Has_unchecked_type(_Ty *,\012		typename _Ty::_Unchecked_type * = 0);\012\012template<class _Iter,\012	bool>\012	struct _Unchecked_helper\012	{	// _Iter doesn't define _Unchecked_type\012	typedef _Iter type;\012	};\012\012template<class _Iter>\012	struct _Unchecked_helper<_Iter, true>\012	{	// _Iter defines _Unchecked_type\012	typedef typename _Iter::_Unchecked_type type;\012	};\012\012template<class _Iter>\012	struct _Get_unchecked_type\012	{	// wraps unchecked type\012	typedef typename _Unchecked_helper<_Iter,\012		_IS_YES(_Has_unchecked_type((_Iter *)0))>::type type;\012	};\012\012		// TEMPLATE FUNCTION _Unchecked\012template<class _Iter> inline\012	_Iter _Unchecked(_Iter _Src)\012	{	// construct unchecked from checked, generic\012	return (_Src);\012	}\012\012		// TEMPLATE FUNCTION _Rechecked\012template<class _Iter,\012	class _UIter> inline\012	_Iter& _Rechecked(_Iter& _Dest, _UIter _Src)\012	{	// reset checked from unchecked, generic\012	_Dest = _Src;\012	return (_Dest);\012	}\012\012		// TEMPLATE STRUCT _Is_checked_helper\012template<class _Iter>\012	struct _Is_checked_helper\012	: public _STD tr1::integral_constant<bool, _IS_YES(_Has_unchecked_type((_Iter *)0))>\012	{	// determine whether _Iter is checked\012	};\012\012		// TEMPLATE FUNCTION _Is_checked\012template<class _Iter> inline\012	_Is_checked_helper<_Iter> _Is_checked(_Iter)\012	{	// return type is derived from true_type if iterator is checked\012	return (_Is_checked_helper<_Iter>());\012	}\012\012		//	ITERATOR STUFF (from <iterator>)\012		// ITERATOR TAGS\012struct input_iterator_tag\012	{	// identifying tag for input iterators\012	};\012\012struct output_iterator_tag\012	{	// identifying tag for output iterators\012	};\012\012struct forward_iterator_tag\012	: public input_iterator_tag, output_iterator_tag\012	{	// identifying tag for forward iterators\012	};\012\012struct bidirectional_iterator_tag\012	: public forward_iterator_tag\012	{	// identifying tag for bidirectional iterators\012	};\012\012struct random_access_iterator_tag\012	: public bidirectional_iterator_tag\012	{	// identifying tag for random-access iterators\012	};\012\012struct _Int_iterator_tag\012	{	// identifying tag for integer types, not an iterator\012	};\012\012		// POINTER ITERATOR TAGS\012struct _Nonscalar_ptr_iterator_tag\012	{	// pointer to unknown type\012	};\012struct _Scalar_ptr_iterator_tag\012	{	// pointer to scalar type\012	};\012\012		// TEMPLATE CLASS iterator\012template<class _Category,\012	class _Ty,\012	class _Diff = ptrdiff_t,\012	class _Pointer = _Ty *,\012	class _Reference = _Ty&>\012	struct iterator\012	{	// base type for all iterator classes\012	typedef _Category iterator_category;\012	typedef _Ty value_type;\012	typedef _Diff difference_type;\012	typedef _Diff distance_type;	// retained\012	typedef _Pointer pointer;\012	typedef _Reference reference;\012	};\012\012template<class _Category,\012	class _Ty,\012	class _Diff,\012	class _Pointer,\012	class _Reference,\012	class _Base>\012	struct _Iterator012\012		: public _Base\012	{\012	typedef _Category iterator_category;\012	typedef _Ty value_type;\012	typedef _Diff difference_type;\012	typedef _Diff distance_type;	// retained\012	typedef _Pointer pointer;\012	typedef _Reference reference;\012	};\012\012struct _Outit\012	: public iterator<output_iterator_tag, void, void,\012		void, void>\012	{	// base for output iterators\012	};\012\012		// TEMPLATE CLASS iterator_traits\012template<class _Iter>\012	struct iterator_traits\012	{	// get traits from iterator _Iter\012	typedef typename _Iter::iterator_category iterator_category;\012	typedef typename _Iter::value_type value_type;\012	typedef typename _Iter::difference_type difference_type;\012	typedef difference_type distance_type;	// retained\012	typedef typename _Iter::pointer pointer;\012	typedef typename _Iter::reference reference;\012	};\012\012template<class _Ty>\012	struct iterator_traits<_Ty *>\012	{	// get traits from pointer\012	typedef random_access_iterator_tag iterator_category;\012	typedef _Ty value_type;\012	typedef ptrdiff_t difference_type;\012	typedef ptrdiff_t distance_type;	// retained\012	typedef _Ty *pointer;\012	typedef _Ty& reference;\012	};\012\012template<class _Ty>\012	struct iterator_traits<const _Ty *>\012	{	// get traits from const pointer\012	typedef random_access_iterator_tag iterator_category;\012	typedef _Ty value_type;\012	typedef ptrdiff_t difference_type;\012	typedef ptrdiff_t distance_type;	// retained\012	typedef const _Ty *pointer;\012	typedef const _Ty& reference;\012	};\012\012template<> struct iterator_traits<_Bool>\012	{	// get traits from integer type\012	typedef _Int_iterator_tag iterator_category;\012	};\012\012template<> struct iterator_traits<char>\012	{	// get traits from integer type\012	typedef _Int_iterator_tag iterator_category;\012	};\012\012template<> struct iterator_traits<signed char>\012	{	// get traits from integer type\012	typedef _Int_iterator_tag iterator_category;\012	};\012\012template<> struct iterator_traits<unsigned char>\012	{	// get traits from integer type\012	typedef _Int_iterator_tag iterator_category;\012	};\012\012 #ifdef _NATIVE_WCHAR_T_DEFINED\012template<> struct iterator_traits<wchar_t>\012	{	// get traits from integer type\012	typedef _Int_iterator_tag iterator_category;\012	};\012 #endif /* _NATIVE_WCHAR_T_DEFINED */\012\012template<> struct iterator_traits<short>\012	{	// get traits from integer type\012	typedef _Int_iterator_tag iterator_category;\012	};\012\012template<> struct iterator_traits<unsigned short>\012	{	// get traits from integer type\012	typedef _Int_iterator_tag iterator_category;\012	};\012\012template<> struct iterator_traits<int>\012	{	// get traits from integer type\012	typedef _Int_iterator_tag iterator_category;\012	};\012\012template<> struct iterator_traits<unsigned int>\012	{	// get traits from integer type\012	typedef _Int_iterator_tag iterator_category;\012	};\012\012template<> struct iterator_traits<long>\012	{	// get traits from integer type\012	typedef _Int_iterator_tag iterator_category;\012	};\012\012template<> struct iterator_traits<unsigned long>\012	{	// get traits from integer type\012	typedef _Int_iterator_tag iterator_category;\012	};\012\012 #ifdef _LONGLONG\012template<> struct iterator_traits<_LONGLONG>\012	{	// get traits from integer type\012	typedef _Int_iterator_tag iterator_category;\012	};\012\012template<> struct iterator_traits<_ULONGLONG>\012	{	// get traits from integer type\012	typedef _Int_iterator_tag iterator_category;\012	};\012 #endif /* _LONGLONG */\012\012		// TEMPLATE FUNCTION _Iter_cat\012template<class _Iter> inline\012	typename iterator_traits<_Iter>::iterator_category\012		_Iter_cat(const _Iter&)\012	{	// return category from iterator argument\012	typename iterator_traits<_Iter>::iterator_category _Cat;\012	return (_Cat);\012	}\012\012		// TEMPLATE FUNCTION _Ptr_cat\012template<class _Iter1,\012	class _Iter2> inline\012	_Nonscalar_ptr_iterator_tag _Ptr_cat(_Iter1&, _Iter2&)\012	{	// return pointer category from arbitrary arguments\012	_Nonscalar_ptr_iterator_tag _Cat;\012	return (_Cat);\012	}\012\012template<class _Elem1,\012	class _Elem2>\012	struct _Ptr_cat_helper\012	{	// determines pointer category, nonscalar by default\012	typedef _Nonscalar_ptr_iterator_tag _Type;\012	};\012\012template<class _Elem>\012	struct _Ptr_cat_helper<_Elem, _Elem>\012	{	// determines pointer category, common type\012	typedef typename _STD tr1::conditional<\012		_STD tr1::is_scalar<_Elem>::value,\012			_Scalar_ptr_iterator_tag,\012			_Nonscalar_ptr_iterator_tag>::type _Type;\012	};\012\012template<class _Anything>\012	struct _Ptr_cat_helper<_Anything *, const _Anything *>\012	{	// determines pointer category\012	typedef _Scalar_ptr_iterator_tag _Type;\012	};\012\012template<class _Elem1,\012	class _Elem2> inline\012	typename _Ptr_cat_helper<_Elem1, _Elem2>::_Type\012		_Ptr_cat(_Elem1 *, _Elem2 *)\012	{	// return pointer category from pointers\012	typename _Ptr_cat_helper<_Elem1, _Elem2>::_Type _Cat;\012	return (_Cat);\012	}\012\012template<class _Elem1,\012	class _Elem2> inline\012	typename _Ptr_cat_helper<_Elem1, _Elem2>::_Type\012		_Ptr_cat(const _Elem1 *, _Elem2 *)\012	{	// return pointer category from pointers\012	typename _Ptr_cat_helper<_Elem1, _Elem2>::_Type _Cat;\012	return (_Cat);\012	}\012\012		// DEBUG TESTING MACROS\012\012 #if _ITERATOR_DEBUG_LEVEL < 2\012  #define _DEBUG_LT(x, y)	((x) < (y))\012  #define _DEBUG_LT_PRED(pred, x, y)	pred(x, y)\012  #define _DEBUG_ORDER(first, last)\012  #define _DEBUG_ORDER_PRED(first, last, pred)\012  #define _DEBUG_POINTER(first)\012  #define _DEBUG_POINTER2(first, file, line)\012  #define _DEBUG_RANGE(first, last)\012  #define _DEBUG_RANGE2(first, last, file, line)\012\012 #else /* _ITERATOR_DEBUG_LEVEL < 2 */\012\012  #define _FILENAME	__FILEW__\012\012  #ifndef _DEBUG_LT_IMPL\012   #define _DEBUG_LT_IMPL	_Debug_lt\012  #endif /* _DEBUG_LT_IMPL */\012\012  #define _DEBUG_LT(x, y) \\\012	_DEBUG_LT_IMPL(x, y, _FILENAME, __LINE__)\012\012  #ifndef _DEBUG_LT_PRED_IMPL\012   #define _DEBUG_LT_PRED_IMPL	_Debug_lt_pred\012  #endif /* _DEBUG_LT_PRED_IMPL */\012\012  #define _DEBUG_LT_PRED(pred, x, y)	\\\012	_DEBUG_LT_PRED_IMPL(pred, x, y, _FILENAME, __LINE__)\012\012  #ifndef _DEBUG_ORDER_IMPL\012   #define _DEBUG_ORDER_IMPL	_Debug_order\012  #endif /* _DEBUG_ORDER_IMPL */\012\012  #define _DEBUG_ORDER(first, last)	\\\012	_DEBUG_ORDER_IMPL(first, last, _FILENAME, __LINE__)\012  #define _DEBUG_ORDER_PRED(first, last, pred)	\\\012	_DEBUG_ORDER_IMPL(first, last, pred, _FILENAME, __LINE__)\012\012  #ifndef _DEBUG_POINTER_IMPL\012   #define _DEBUG_POINTER_IMPL	_Debug_pointer\012  #endif /* _DEBUG_POINTER_IMPL */\012\012  #define _DEBUG_POINTER(first)	\\\012	_DEBUG_POINTER_IMPL(first, _FILENAME, __LINE__)\012  #define _DEBUG_POINTER2(first, file, line)	\\\012	_DEBUG_POINTER_IMPL(first, file, line)\012\012  #ifndef _DEBUG_RANGE_IMPL\012   #define _DEBUG_RANGE_IMPL	_Debug_range\012  #endif /* _DEBUG_RANGE_IMPL */\012\012  #define _DEBUG_RANGE(first, last)	\\\012	_DEBUG_RANGE_IMPL(first, last, _FILENAME, __LINE__)\012  #define _DEBUG_RANGE2(first, last, file, line)	\\\012	_DEBUG_RANGE_IMPL(first, last, file, line)\012\012		// TEMPLATE FUNCTION _Debug_lt\012template<class _Ty1, class _Ty2> inline\012	bool _Debug_lt(const _Ty1& _Left, const _Ty2& _Right,\012		_Dbfile_t _File, _Dbline_t _Line)\012	{	// test if _Left < _Right and operator< is strict weak ordering\012	if (!(_Left < _Right))\012		return (false);\012	else if (_Right < _Left)\012		_DEBUG_ERROR2(\"invalid operator<\", _File, _Line);\012	return (true);\012	}\012\012template<class _Ty1, class _Ty2> inline\012	bool _Debug_lt(const _Ty1& _Left, _Ty2& _Right,\012		_Dbfile_t _File, _Dbline_t _Line)\012	{	// test if _Left < _Right and operator< is strict weak ordering\012	if (!(_Left < _Right))\012		return (false);\012	else if (_Right < _Left)\012		_DEBUG_ERROR2(\"invalid operator<\", _File, _Line);\012	return (true);\012	}\012\012template<class _Ty1, class _Ty2> inline\012	bool _Debug_lt(_Ty1& _Left, const _Ty2& _Right,\012		_Dbfile_t _File, _Dbline_t _Line)\012	{	// test if _Left < _Right and operator< is strict weak ordering\012	if (!(_Left < _Right))\012		return (false);\012	else if (_Right < _Left)\012		_DEBUG_ERROR2(\"invalid operator<\", _File, _Line);\012	return (true);\012	}\012\012template<class _Ty1, class _Ty2> inline\012	bool _Debug_lt(_Ty1& _Left, _Ty2& _Right,\012		_Dbfile_t _File, _Dbline_t _Line)\012	{	// test if _Left < _Right and operator< is strict weak ordering\012	if (!(_Left < _Right))\012		return (false);\012	else if (_Right < _Left)\012		_DEBUG_ERROR2(\"invalid operator<\", _File, _Line);\012	return (true);\012	}\012\012		// TEMPLATE FUNCTION _Debug_lt_pred\012template<class _Pr, class _Ty1, class _Ty2> inline\012	bool _Debug_lt_pred(_Pr _Pred,\012		const _Ty1& _Left, const _Ty2& _Right,\012		_Dbfile_t _File, _Dbline_t _Line)\012	{	// test if _Pred(_Left, _Right) and _Pred is strict weak ordering\012	if (!_Pred(_Left, _Right))\012		return (false);\012	else if (_Pred(_Right, _Left))\012		_DEBUG_ERROR2(\"invalid operator<\", _File, _Line);\012	return (true);\012	}\012\012template<class _Pr, class _Ty1, class _Ty2> inline\012	bool _Debug_lt_pred(_Pr _Pred,\012		const _Ty1& _Left, _Ty2& _Right,\012		_Dbfile_t _File, _Dbline_t _Line)\012	{	// test if _Pred(_Left, _Right) and _Pred is strict weak ordering\012	if (!_Pred(_Left, _Right))\012		return (false);\012	else if (_Pred(_Right, _Left))\012		_DEBUG_ERROR2(\"invalid operator<\", _File, _Line);\012	return (true);\012	}\012\012template<class _Pr, class _Ty1, class _Ty2> inline\012	bool _Debug_lt_pred(_Pr _Pred,\012		_Ty1& _Left, const _Ty2& _Right,\012		_Dbfile_t _File, _Dbline_t _Line)\012	{	// test if _Pred(_Left, _Right) and _Pred is strict weak ordering\012	if (!_Pred(_Left, _Right))\012		return (false);\012	else if (_Pred(_Right, _Left))\012		_DEBUG_ERROR2(\"invalid operator<\", _File, _Line);\012	return (true);\012	}\012\012template<class _Pr, class _Ty1, class _Ty2> inline\012	bool _Debug_lt_pred(_Pr _Pred,\012		_Ty1& _Left, _Ty2& _Right,\012		_Dbfile_t _File, _Dbline_t _Line)\012	{	// test if _Pred(_Left, _Right) and _Pred is strict weak ordering\012	if (!_Pred(_Left, _Right))\012		return (false);\012	else if (_Pred(_Right, _Left))\012		_DEBUG_ERROR2(\"invalid operator<\", _File, _Line);\012	return (true);\012	}\012\012		// TEMPLATE FUNCTION _Debug_pointer\012template<class _InIt> inline\012	void _Debug_pointer(_InIt&, _Dbfile_t, _Dbline_t)\012	{	// test pointer for non-singularity, arbitrary type\012	}\012\012template<class _Ty> inline\012	void _Debug_pointer(const _Ty *_First, _Dbfile_t _File, _Dbline_t _Line)\012	{	// test iterator for non-singularity, const pointers\012	if (_First == 0)\012		_DEBUG_ERROR2(\"invalid null pointer\", _File, _Line);\012	}\012\012template<class _Ty> inline\012	void _Debug_pointer(_Ty *_First, _Dbfile_t _File, _Dbline_t _Line)\012	{	// test iterator for non-singularity, pointers\012	if (_First == 0)\012		_DEBUG_ERROR2(\"invalid null pointer\", _File, _Line);\012	}\012\012		// TEMPLATE FUNCTION _Debug_range\012template<class _InIt> inline\012	void _Debug_range2(_InIt _First, _InIt _Last, _Dbfile_t, _Dbline_t,\012		input_iterator_tag)\012	{	// test iterator pair for valid range, arbitrary iterators\012	bool _Ans = _First == _Last;	// make sure they're comparable\012	_Ans = _Ans;	// to quiet diagnostics\012	}\012\012template<class _RanIt> inline\012	void _Debug_range2(_RanIt _First, _RanIt _Last,\012		_Dbfile_t _File, _Dbline_t _Line,\012		random_access_iterator_tag)\012	{	// test iterator pair for valid range, random-access iterators\012	if (_First != _Last)\012		{	// check for non-null pointers, valid range\012		_DEBUG_POINTER2(_First, _File, _Line);\012		_DEBUG_POINTER2(_Last, _File, _Line);\012		if (_Last < _First)\012			_DEBUG_ERROR2(\"invalid iterator range\", _File, _Line);\012		}\012	}\012\012template<class _InIt> inline\012	void _Debug_range(_InIt _First, _InIt _Last,\012		_Dbfile_t _File, _Dbline_t _Line)\012	{	// test iterator pair for valid range\012	_Debug_range2(_First, _Last, _File, _Line, _Iter_cat(_First));\012	}\012\012		// TEMPLATE FUNCTION _Debug_order\012template<class _InIt> inline\012	void _Debug_order2(_InIt, _InIt,\012		_Dbfile_t, _Dbline_t, input_iterator_tag)\012	{	// test if range is ordered by operator<, input iterators\012	}\012\012template<class _FwdIt> inline\012	void _Debug_order2(_FwdIt _First, _FwdIt _Last,\012		_Dbfile_t _File, _Dbline_t _Line, forward_iterator_tag)\012	{	// test if range is ordered by operator<, forward iterators\012	for (_FwdIt _Next = _First; _First != _Last && ++_Next != _Last; ++_First)\012		if (_DEBUG_LT(*_Next, *_First))\012			_DEBUG_ERROR2(\"sequence not ordered\", _File, _Line);\012	}\012\012template<class _InIt> inline\012	void _Debug_order(_InIt _First, _InIt _Last,\012		_Dbfile_t _File, _Dbline_t _Line)\012	{	// test is range is ordered by operator<\012	_DEBUG_RANGE2(_First, _Last, _File, _Line);\012	_Debug_order2(_First, _Last, _File, _Line, _Iter_cat(_First));\012	}\012\012		// TEMPLATE FUNCTION _Debug_order_pred\012template<class _InIt,\012	class _Pr> inline\012	void _Debug_order2(_InIt, _InIt, _Pr,\012		_Dbfile_t, _Dbline_t, input_iterator_tag)\012	{	// test if range is ordered by predicate, input iterators\012	}\012\012template<class _FwdIt,\012	class _Pr> inline\012	void _Debug_order2(_FwdIt _First, _FwdIt _Last, _Pr _Pred,\012		_Dbfile_t _File, _Dbline_t _Line, forward_iterator_tag)\012	{	// test if range is ordered by predicate, forward iterators\012	for (_FwdIt _Next = _First; _First != _Last && ++_Next != _Last; ++_First)\012		if (_DEBUG_LT_PRED(_Pred, *_Next, *_First))\012			_DEBUG_ERROR2(\"sequence not ordered\", _File, _Line);\012	}\012\012template<class _InIt,\012	class _Pr> inline\012	void _Debug_order(_InIt _First, _InIt _Last, _Pr _Pred,\012		_Dbfile_t _File, _Dbline_t _Line)\012	{	// test if range is ordered by predicate\012	_DEBUG_RANGE2(_First, _Last, _File, _Line);\012	_DEBUG_POINTER2(_Pred, _File, _Line);\012	_Debug_order2(_First, _Last, _Pred, _File, _Line, _Iter_cat(_First));\012	}\012 #endif /* _ITERATOR_DEBUG_LEVEL < 2 */\012\012		// MORE ITERATOR STUFF (from <iterator>\012		// TEMPLATE FUNCTION _Val_type\012\012template<class _Iter> inline\012	typename iterator_traits<_Iter>::value_type *_Val_type(_Iter)\012	{	// return value type from arbitrary argument\012	return (0);\012	}\012\012		// TEMPLATE FUNCTION advance\012template<class _InIt,\012	class _Diff> inline\012	void advance(_InIt& _Where, _Diff _Off)\012	{	// increment iterator by offset, arbitrary iterators\012	_Advance(_Where, _Off, _Iter_cat(_Where));\012	}\012\012template<class _InIt,\012	class _Diff> inline\012	void _Advance(_InIt& _Where, _Diff _Off, input_iterator_tag)\012	{	// increment iterator by offset, input iterators\012 #if _ITERATOR_DEBUG_LEVEL == 2\012//	if (_Off < 0)\012//		_DEBUG_ERROR(\"negative offset in advance\");\012 #endif /* _ITERATOR_DEBUG_LEVEL == 2 */\012\012	for (; 0 < _Off; --_Off)\012		++_Where;\012	}\012\012template<class _FI,\012	class _Diff> inline\012	void _Advance(_FI& _Where, _Diff _Off, forward_iterator_tag)\012	{	// increment iterator by offset, forward iterators\012 #if _ITERATOR_DEBUG_LEVEL == 2\012//	if (_Off < 0)\012//		_DEBUG_ERROR(\"negative offset in advance\");\012 #endif /* _ITERATOR_DEBUG_LEVEL == 2 */\012\012	for (; 0 < _Off; --_Off)\012		++_Where;\012	}\012\012template<class _BI,\012	class _Diff> inline\012	void _Advance(_BI& _Where, _Diff _Off, bidirectional_iterator_tag)\012	{	// increment iterator by offset, bidirectional iterators\012	for (; 0 < _Off; --_Off)\012		++_Where;\012	for (; _Off < 0; ++_Off)\012		--_Where;\012	}\012\012template<class _RI,\012	class _Diff> inline\012	void _Advance(_RI& _Where, _Diff _Off, random_access_iterator_tag)\012	{	// increment iterator by offset, random-access iterators\012	_Where += _Off;\012	}\012\012		// TEMPLATE FUNCTION _Dist_type\012\012template<class _Iter> inline\012	typename iterator_traits<_Iter>::difference_type\012		*_Dist_type(_Iter)\012	{	// return distance type from arbitrary argument\012	return (0);\012	}\012\012		// TEMPLATE FUNCTIONS distance and _Distance\012template<class _InIt,\012	class _Diff> inline\012		void _Distance2(_InIt _First, _InIt _Last, _Diff& _Off,\012			input_iterator_tag)\012	{	// add to _Off distance between input iterators\012	for (; _First != _Last; ++_First)\012		++_Off;\012	}\012\012template<class _FwdIt,\012	class _Diff> inline\012		void _Distance2(_FwdIt _First, _FwdIt _Last, _Diff& _Off,\012			forward_iterator_tag)\012	{	// add to _Off distance between forward iterators (redundant)\012	for (; _First != _Last; ++_First)\012		++_Off;\012	}\012\012template<class _BidIt,\012	class _Diff> inline\012		void _Distance2(_BidIt _First, _BidIt _Last, _Diff& _Off,\012			bidirectional_iterator_tag)\012	{	// add to _Off distance between bidirectional iterators (redundant)\012	for (; _First != _Last; ++_First)\012		++_Off;\012	}\012\012template<class _RanIt,\012	class _Diff> inline\012		void _Distance2(_RanIt _First, _RanIt _Last, _Diff& _Off,\012			random_access_iterator_tag)\012	{	// add to _Off distance between random-access iterators\012 #if _ITERATOR_DEBUG_LEVEL == 2\012	if (_First != _Last)\012		{	// check for null pointers\012		_DEBUG_POINTER(_First);\012		_DEBUG_POINTER(_Last);\012		}\012 #endif /* _ITERATOR_DEBUG_LEVEL == 2 */\012\012	_Off += _Last - _First;\012	}\012\012template<class _InIt> inline\012	typename iterator_traits<_InIt>::difference_type\012		distance(_InIt _First, _InIt _Last)\012	{	// return distance between iterators\012	typename iterator_traits<_InIt>::difference_type _Off = 0;\012	_Distance2(_First, _Last, _Off, _Iter_cat(_First));\012	return (_Off);\012	}\012\012template<class _InIt,\012	class _Diff> inline\012		void _Distance(_InIt _First, _InIt _Last, _Diff& _Off)\012	{	// add to _Off distance between iterators\012	_Distance2(_First, _Last, _Off, _Iter_cat(_First));\012	}\012\012 #if _HAS_CPP0X\012		// TEMPLATE FUNCTIONS next and prev\012template<class _InIt,\012	class _Diff> inline\012		_InIt _Increment(_InIt _First, _Diff _Off,\012			input_iterator_tag)\012	{	// add _Off to input iterator\012	for (; 0 < _Off; --_Off)\012		++_First;\012	return (_First);\012	}\012\012template<class _FwdIt,\012	class _Diff> inline\012		_FwdIt _Increment(_FwdIt _First, _Diff _Off,\012			forward_iterator_tag)\012	{	// add _Off to forward iterator\012	for (; 0 < _Off; --_Off)\012		++_First;\012	return (_First);\012	}\012\012template<class _BidIt,\012	class _Diff> inline\012		_BidIt _Increment(_BidIt _First, _Diff _Off,\012			bidirectional_iterator_tag)\012	{	// add _Off to bidirectional iterator\012	for (; _Off < 0; ++_Off)\012		--_First;\012	for (; 0 < _Off; --_Off)\012		++_First;\012	return (_First);\012	}\012\012template<class _RanIt,\012	class _Diff> inline\012		_RanIt _Increment(_RanIt _First, _Diff _Off,\012			random_access_iterator_tag)\012	{	// add _Off to random-access iterator\012	return (_First + _Off);\012	}\012\012template<class _InIt> inline\012	_InIt next(_InIt _First,\012		typename iterator_traits<_InIt>::difference_type _Off = 1)\012	{	// increment iterator\012	return (_Increment(_First, _Off, _Iter_cat(_First)));\012	}\012\012template<class _InIt> inline\012	_InIt prev(_InIt _First,\012		typename iterator_traits<_InIt>::difference_type _Off = 1)\012	{	// decrement iterator\012	return (_Increment(_First, -_Off, _Iter_cat(_First)));\012	}\012\012template<class _Container> inline\012	typename _Container::iterator begin(_Container& _Cont)\012	{	// get beginning of sequence\012	return (_Cont.begin());\012	}\012\012template<class _Container> inline\012	typename _Container::const_iterator begin(const _Container& _Cont)\012	{	// get beginning of sequence\012	return (_Cont.begin());\012	}\012\012template<class _Container> inline\012	typename _Container::iterator end(_Container& _Cont)\012	{	// get end of sequence\012	return (_Cont.end());\012	}\012\012template<class _Container> inline\012	typename _Container::const_iterator end(const _Container& _Cont)\012	{	// get end of sequence\012	return (_Cont.end());\012	}\012\012template<class _Ty,\012	size_t _Size> inline\012	_Ty *begin(_Ty (&_Array)[_Size])\012	{	// get beginning of array\012	return (&_Array[0]);\012	}\012\012template<class _Ty,\012	size_t _Size> inline\012	_Ty *end(_Ty (&_Array)[_Size])\012	{	// get end of array\012	return (&_Array[0] + _Size);\012	}\012 #endif /* _HAS_CPP0X */\012\012		// TEMPLATE CLASS _Revranit\012template<class _RanIt,\012	class _Base>\012	class _Revranit\012		: public _Base\012	{	// wrap iterator to run it backwards\012public:\012	typedef _Revranit<_RanIt, _Base> _Myt;\012 	typedef typename _Base::difference_type difference_type;\012	typedef typename _Base::pointer pointer;\012	typedef typename _Base::reference reference;\012	typedef _RanIt iterator_type;\012\012	_Revranit()\012		{	// construct with default wrapped iterator\012		}\012\012	explicit _Revranit(_RanIt _Right)\012		: current(_Right)\012		{	// construct wrapped iterator from _Right\012		}\012\012	template<class _RanIt2,\012		class _Base2>\012		_Revranit(const _Revranit<_RanIt2, _Base2>& _Right)\012		: current(_Right.base())\012		{	// initialize with compatible base\012		}\012\012	_RanIt base() const\012		{	// return wrapped iterator\012		return (current);\012		}\012\012	reference operator*() const\012		{	// return designated value\012		_RanIt _Tmp = current;\012		return (*--_Tmp);\012		}\012\012	pointer operator->() const\012		{	// return pointer to class object\012		return (&**this);\012		}\012\012	_Myt& operator++()\012		{	// preincrement\012		--current;\012		return (*this);\012		}\012\012	_Myt operator++(int)\012		{	// postincrement\012		_Myt _Tmp = *this;\012		--current;\012		return (_Tmp);\012		}\012\012	_Myt& operator--()\012		{	// predecrement\012		++current;\012		return (*this);\012		}\012\012	_Myt operator--(int)\012		{	// postdecrement\012		_Myt _Tmp = *this;\012		++current;\012		return (_Tmp);\012		}\012\012	template<class _RanIt2,\012		class _Base2>\012		bool _Equal(const _Revranit<_RanIt2, _Base2>& _Right) const\012		{	// test for iterator equality\012		return (current == _Right.base());\012		}\012\012// N.B. functions valid for random-access iterators only beyond this point\012\012	_Myt& operator+=(difference_type _Off)\012		{	// increment by integer\012		current -= _Off;\012		return (*this);\012		}\012\012	_Myt operator+(difference_type _Off) const\012		{	// return this + integer\012		return (_Myt(current - _Off));\012		}\012\012	_Myt& operator-=(difference_type _Off)\012		{	// decrement by integer\012		current += _Off;\012		return (*this);\012		}\012\012	_Myt operator-(difference_type _Off) const\012		{	// return this - integer\012		return (_Myt(current + _Off));\012		}\012\012	reference operator[](difference_type _Off) const\012		{	// subscript\012		return (*(*this + _Off));\012		}\012\012	template<class _RanIt2,\012		class _Base2>\012		bool _Less(const _Revranit<_RanIt2, _Base2>& _Right) const\012		{	// test if this < _Right\012		return (_Right.base() < current);\012		}\012\012	difference_type operator-(const _Myt& _Right) const\012		{	// return difference of iterators\012		return (_Right.base() - current);\012		}\012\012protected:\012	_RanIt current;	// the wrapped iterator\012	};\012\012		// _Revranit TEMPLATE OPERATORS\012template<class _RanIt,\012	class _Base,\012	class _Diff> inline\012	_Revranit<_RanIt, _Base>\012		operator+(_Diff _Off,\012		const _Revranit<_RanIt, _Base>& _Right)\012	{	// return reverse_iterator + integer\012	return (_Right + _Off);\012	}\012\012template<class _RanIt1,\012	class _Base1,\012	class _RanIt2,\012	class _Base2> inline\012	typename _Base1::difference_type operator-(\012		const _Revranit<_RanIt1, _Base1>& _Left,\012		const _Revranit<_RanIt2, _Base2>& _Right)\012	{	// return difference of reverse_iterators\012	return (_Right.base() - _Left.base());\012	}\012\012template<class _RanIt1,\012	class _Base1,\012	class _RanIt2,\012	class _Base2> inline\012	bool operator==(\012		const _Revranit<_RanIt1, _Base1>& _Left,\012		const _Revranit<_RanIt2, _Base2>& _Right)\012	{	// test for reverse_iterator equality\012	return (_Left._Equal(_Right));\012	}\012\012template<class _RanIt1,\012	class _Base1,\012	class _RanIt2,\012	class _Base2> inline\012	bool operator!=(\012		const _Revranit<_RanIt1, _Base1>& _Left,\012		const _Revranit<_RanIt2, _Base2>& _Right)\012	{	// test for reverse_iterator inequality\012	return (!(_Left == _Right));\012	}\012\012template<class _RanIt1,\012	class _Base1,\012	class _RanIt2,\012	class _Base2> inline\012	bool operator<(\012		const _Revranit<_RanIt1, _Base1>& _Left,\012		const _Revranit<_RanIt2, _Base2>& _Right)\012	{	// test for reverse_iterator < reverse_iterator\012	return (_Left._Less(_Right));\012	}\012\012template<class _RanIt1,\012	class _Base1,\012	class _RanIt2,\012	class _Base2> inline\012	bool operator>(\012		const _Revranit<_RanIt1, _Base1>& _Left,\012		const _Revranit<_RanIt2, _Base2>& _Right)\012	{	// test for reverse_iterator > reverse_iterator\012	return (_Right < _Left);\012	}\012\012template<class _RanIt1,\012	class _Base1,\012	class _RanIt2,\012	class _Base2> inline\012	bool operator<=(\012		const _Revranit<_RanIt1, _Base1>& _Left,\012		const _Revranit<_RanIt2, _Base2>& _Right)\012	{	// test for reverse_iterator <= reverse_iterator\012	return (!(_Right < _Left));\012	}\012\012template<class _RanIt1,\012	class _Base1,\012	class _RanIt2,\012	class _Base2> inline\012	bool operator>=(\012		const _Revranit<_RanIt1, _Base1>& _Left,\012		const _Revranit<_RanIt2, _Base2>& _Right)\012	{	// test for reverse_iterator >= reverse_iterator\012	return (!(_Left < _Right));\012	}\012\012		// TEMPLATE CLASS reverse_iterator\012template<class _RanIt>\012	class reverse_iterator\012		: public _Revranit<_RanIt, iterator<\012			typename iterator_traits<_RanIt>::iterator_category,\012			typename iterator_traits<_RanIt>::value_type,\012			typename iterator_traits<_RanIt>::difference_type,\012			typename iterator_traits<_RanIt>::pointer,\012			typename iterator_traits<_RanIt>::reference> >\012	{	// wrap iterator to run it backwards\012	typedef reverse_iterator<_RanIt> _Myt;\012	typedef _Revranit<_RanIt, iterator<\012		typename iterator_traits<_RanIt>::iterator_category,\012		typename iterator_traits<_RanIt>::value_type,\012		typename iterator_traits<_RanIt>::difference_type,\012		typename iterator_traits<_RanIt>::pointer,\012		typename iterator_traits<_RanIt>::reference> > _Mybase;\012\012public:\012 	typedef typename iterator_traits<_RanIt>::difference_type difference_type;\012	typedef typename iterator_traits<_RanIt>::pointer pointer;\012	typedef typename iterator_traits<_RanIt>::reference reference;\012	typedef _RanIt iterator_type;\012\012	reverse_iterator()\012		{	// construct with default wrapped iterator\012		}\012\012	explicit reverse_iterator(_RanIt _Right)\012		: _Mybase(_Right)\012		{	// construct wrapped iterator from _Right\012		}\012\012	template<class _Other>\012		reverse_iterator(const reverse_iterator<_Other>& _Right)\012		: _Mybase(_Right.base())\012		{	// initialize with compatible base\012		}\012\012	reverse_iterator(_Mybase _Right)\012		: _Mybase(_Right)\012		{	// construct wrapped iterator from base object\012		}\012\012	_Myt& operator++()\012		{	// preincrement\012		++*((_Mybase *)this);\012		return (*this);\012		}\012\012	_Myt operator++(int)\012		{	// postincrement\012		_Myt _Tmp = *this;\012		++*this;\012		return (_Tmp);\012		}\012\012	_Myt& operator--()\012		{	// predecrement\012		--*((_Mybase *)this);\012		return (*this);\012		}\012\012	_Myt operator--(int)\012		{	// postdecrement\012		_Myt _Tmp = *this;\012		--*this;\012		return (_Tmp);\012		}\012\012	_Myt& operator+=(difference_type _Off)\012		{	// increment by integer\012		*((_Mybase *)this) += _Off;\012		return (*this);\012		}\012\012	_Myt operator+(difference_type _Off) const\012		{	// return this + integer\012		_Myt _Tmp = *this;\012		return (_Tmp += _Off);\012		}\012\012	_Myt& operator-=(difference_type _Off)\012		{	// decrement by integer\012		*((_Mybase *)this) -= _Off;\012		return (*this);\012		}\012\012	_Myt operator-(difference_type _Off) const\012		{	// return this - integer\012		_Myt _Tmp = *this;\012		return (_Tmp -= _Off);\012		}\012	};\012\012template<class _RanIt>\012	struct _Is_checked_helper<reverse_iterator<_RanIt> >\012	: public _Is_checked_helper<_RanIt>\012	{	// mark reverse_iterator as checked if its underlying iterator is checked\012	};\012\012		// reverse_iterator TEMPLATE OPERATORS\012template<class _RanIt,\012	class _Diff> inline\012	reverse_iterator<_RanIt> operator+(_Diff _Off,\012		const reverse_iterator<_RanIt>& _Right)\012	{	// return reverse_iterator + integer\012	return (_Right + _Off);\012	}\012\012template<class _RanIt1,\012	class _RanIt2> inline\012	typename reverse_iterator<_RanIt1>::difference_type\012		operator-(const reverse_iterator<_RanIt1>& _Left,\012			const reverse_iterator<_RanIt2>& _Right)\012	{	// return difference of reverse_iterators\012	return (_Right.base() - _Left.base());\012	}\012\012template<class _RanIt1,\012	class _RanIt2> inline\012	bool operator==(const reverse_iterator<_RanIt1>& _Left,\012		const reverse_iterator<_RanIt2>& _Right)\012	{	// test for reverse_iterator equality\012	return (_Left._Equal(_Right));\012	}\012\012template<class _RanIt1,\012	class _RanIt2> inline\012	bool operator!=(const reverse_iterator<_RanIt1>& _Left,\012		const reverse_iterator<_RanIt2>& _Right)\012	{	// test for reverse_iterator inequality\012	return (!(_Left == _Right));\012	}\012\012template<class _RanIt1,\012	class _RanIt2> inline\012	bool operator<(const reverse_iterator<_RanIt1>& _Left,\012		const reverse_iterator<_RanIt2>& _Right)\012	{	// test for reverse_iterator < reverse_iterator\012	return (_Left._Less(_Right));\012	}\012\012template<class _RanIt1,\012	class _RanIt2> inline\012	bool operator>(const reverse_iterator<_RanIt1>& _Left,\012		const reverse_iterator<_RanIt2>& _Right)\012	{	// test for reverse_iterator > reverse_iterator\012	return (_Right < _Left);\012	}\012\012template<class _RanIt1,\012	class _RanIt2> inline\012	bool operator<=(const reverse_iterator<_RanIt1>& _Left,\012		const reverse_iterator<_RanIt2>& _Right)\012	{	// test for reverse_iterator <= reverse_iterator\012	return (!(_Right < _Left));\012	}\012\012template<class _RanIt1,\012	class _RanIt2> inline\012	bool operator>=(const reverse_iterator<_RanIt1>& _Left,\012		const reverse_iterator<_RanIt2>& _Right)\012	{	// test for reverse_iterator >= reverse_iterator\012	return (!(_Left < _Right));\012	}\012\012		// TEMPLATE CLASS reverse_bidirectional_iterator (retained)\012template<class _BidIt,\012	class _Ty,\012	class _Reference = _Ty&,\012	class _Pointer = _Ty *,\012	class _Diff = ptrdiff_t>\012	class reverse_bidirectional_iterator\012		: public iterator<bidirectional_iterator_tag, _Ty, _Diff,\012			_Pointer, _Reference>\012	{	// wrap bidirectional iterator to run it backwards\012public:\012	typedef reverse_bidirectional_iterator<_BidIt, _Ty, _Reference,\012		_Pointer, _Diff> _Myt;\012	typedef _BidIt iterator_type;\012\012	reverse_bidirectional_iterator()\012		{	// construct with default wrapped iterator\012		}\012\012	explicit reverse_bidirectional_iterator(_BidIt _Right)\012		: current(_Right)\012		{	// construct wrapped iterator from _Right\012		}\012\012	_BidIt base() const\012		{	// return wrapped iterator\012		return (current);\012		}\012\012	_Reference operator*() const\012		{	// return designated value\012		_BidIt _Tmp = current;\012		return (*--_Tmp);\012		}\012\012	_Pointer operator->() const\012		{	// return pointer to class object\012		_Reference _Tmp = **this;\012		return (&_Tmp);\012		}\012\012	_Myt& operator++()\012		{	// preincrement\012		--current;\012		return (*this);\012		}\012\012	_Myt operator++(int)\012		{	// postincrement\012		_Myt _Tmp = *this;\012		--current;\012		return (_Tmp);\012		}\012\012	_Myt& operator--()\012		{	// predecrement\012		++current;\012		return (*this);\012		}\012\012	_Myt operator--(int)\012		{	// postdecrement\012		_Myt _Tmp = *this;\012		++current;\012		return (_Tmp);\012		}\012\012	bool operator==(const _Myt& _Right) const\012		{	// test for iterator equality\012		return (current == _Right.current);\012		}\012\012	bool operator!=(const _Myt& _Right) const\012		{	// test for iterator inequality\012		return (!(*this == _Right));\012		}\012\012protected:\012	_BidIt current;	// the wrapped iterator\012	};\012\012		// TEMPLATE CLASS _Revbidit\012template<class _BidIt,\012	class _BidIt2 = _BidIt>\012	class _Revbidit\012		: public iterator<\012			typename iterator_traits<_BidIt>::iterator_category,\012			typename iterator_traits<_BidIt>::value_type,\012			typename iterator_traits<_BidIt>::difference_type,\012			typename iterator_traits<_BidIt>::pointer,\012			typename iterator_traits<_BidIt>::reference>\012	{	// wrap bidirectional iterator to run it backwards\012public:\012	typedef _Revbidit<_BidIt, _BidIt2> _Myt;\012	typedef typename iterator_traits<_BidIt>::difference_type _Diff;\012	typedef typename iterator_traits<_BidIt>::pointer _Pointer;\012	typedef typename iterator_traits<_BidIt>::reference _Reference;\012	typedef _BidIt iterator_type;\012\012	_Revbidit()\012		{	// construct with default wrapped iterator\012		}\012\012	explicit _Revbidit(_BidIt _Right)\012		: current(_Right)\012		{	// construct wrapped iterator from _Right\012		}\012\012	_Revbidit(const _Revbidit<_BidIt2>& _Other)\012		: current (_Other.base())\012		{	// const converter or copy constructor\012		}\012\012	_BidIt base() const\012		{	// return wrapped iterator\012		return (current);\012		}\012\012	_Reference operator*() const\012		{	// return designated value\012		_BidIt _Tmp = current;\012		return (*--_Tmp);\012		}\012\012	_Pointer operator->() const\012		{	// return pointer to class object\012		_Reference _Tmp = **this;\012		return (&_Tmp);\012		}\012\012	_Myt& operator++()\012		{	// preincrement\012		--current;\012		return (*this);\012		}\012\012	_Myt operator++(int)\012		{	// postincrement\012		_Myt _Tmp = *this;\012		--current;\012		return (_Tmp);\012		}\012\012	_Myt& operator--()\012		{	// predecrement\012		++current;\012		return (*this);\012		}\012\012	_Myt operator--(int)\012		{	// postdecrement\012		_Myt _Tmp = *this;\012		++current;\012		return (_Tmp);\012		}\012\012	bool operator==(const _Myt& _Right) const\012		{	// test for iterator equality\012		return (current == _Right.current);\012		}\012\012	bool operator!=(const _Myt& _Right) const\012		{	// test for iterator inequality\012		return (!(*this == _Right));\012		}\012\012protected:\012	_BidIt current;\012	};\012\012		// TEMPLATE CLASS _Array_const_iterator\012template<class _Ty,\012	size_t _Size>\012	class _Array_const_iterator\012		: public _Iterator012<random_access_iterator_tag,\012			_Ty,\012			ptrdiff_t,\012			const _Ty *,\012			const _Ty&,\012			_Iterator_base>\012	{	// iterator for nonmutable array\012public:\012	typedef _Array_const_iterator<_Ty, _Size> _Myiter;\012	typedef random_access_iterator_tag iterator_category;\012\012	typedef _Ty value_type;\012	typedef size_t size_type;\012	typedef ptrdiff_t difference_type;\012	typedef const _Ty *pointer;\012	typedef const _Ty& reference;\012	enum {_EEN_SIZE = _Size};	// helper for expression evaluator\012	enum {_EEN_IDL =\012		_ITERATOR_DEBUG_LEVEL};	// helper for expression evaluator\012\012 #if _ITERATOR_DEBUG_LEVEL == 0\012	_Array_const_iterator()\012		{	// construct with null pointer\012		_Ptr = 0;\012		}\012\012	explicit _Array_const_iterator(pointer _Parg, size_t _Off = 0)\012		{	// construct with pointer and offset\012		_Ptr = _Parg + _Off;\012		}\012\012	typedef pointer _Unchecked_type;\012\012	_Myiter& _Rechecked(_Unchecked_type _Right)\012		{	// reset from unchecked iterator\012		_Ptr = _Right;\012		return (*this);\012		}\012\012	_Unchecked_type _Unchecked() const\012		{	// make an unchecked iterator\012		return (_Ptr);\012		}\012\012	reference operator*() const\012		{	// return designated object\012		return (*_Ptr);\012		}\012\012	pointer operator->() const\012		{	// return pointer to class object\012		return (&**this);\012		}\012\012	_Myiter& operator++()\012		{	// preincrement\012		++_Ptr;\012		return (*this);\012		}\012\012	_Myiter operator++(int)\012		{	// postincrement\012		_Myiter _Tmp = *this;\012		++*this;\012		return (_Tmp);\012		}\012\012	_Myiter& operator--()\012		{	// predecrement\012		--_Ptr;\012		return (*this);\012		}\012\012	_Myiter operator--(int)\012		{	// postdecrement\012		_Myiter _Tmp = *this;\012		--*this;\012		return (_Tmp);\012		}\012\012	_Myiter& operator+=(difference_type _Off)\012		{	// increment by integer\012		_Ptr += _Off;\012		return (*this);\012		}\012\012	_Myiter operator+(difference_type _Off) const\012		{	// return this + integer\012		_Myiter _Tmp = *this;\012		return (_Tmp += _Off);\012		}\012\012	_Myiter& operator-=(difference_type _Off)\012		{	// decrement by integer\012		return (*this += -_Off);\012		}\012\012	_Myiter operator-(difference_type _Off) const\012		{	// return this - integer\012		_Myiter _Tmp = *this;\012		return (_Tmp -= _Off);\012		}\012\012	difference_type operator-(const _Myiter& _Right) const\012		{	// return difference of iterators\012		return (_Ptr - _Right._Ptr);\012		}\012\012	reference operator[](difference_type _Off) const\012		{	// subscript\012		return (*(*this + _Off));\012		}\012\012	bool operator==(const _Myiter& _Right) const\012		{	// test for iterator equality\012		return (_Ptr == _Right._Ptr);\012		}\012\012	bool operator!=(const _Myiter& _Right) const\012		{	// test for iterator inequality\012		return (!(*this == _Right));\012		}\012\012	bool operator<(const _Myiter& _Right) const\012		{	// test if this < _Right\012		return (_Ptr < _Right._Ptr);\012		}\012\012	bool operator>(const _Myiter& _Right) const\012		{	// test if this > _Right\012		return (_Right < *this);\012		}\012\012	bool operator<=(const _Myiter& _Right) const\012		{	// test if this <= _Right\012		return (!(_Right < *this));\012		}\012\012	bool operator>=(const _Myiter& _Right) const\012		{	// test if this >= _Right\012		return (!(*this < _Right));\012		}\012\012	pointer _Ptr;	// beginning of array\012\012 #else /* _ITERATOR_DEBUG_LEVEL == 0 */\012	_Array_const_iterator()\012		{	// construct with null pointer\012		_Ptr = 0;\012		_Idx = 0;\012		}\012\012	explicit _Array_const_iterator(pointer _Parg, size_t _Off = 0)\012		{	// construct with pointer and offset\012		_Ptr = _Parg;\012		_Idx = _Off;\012		}\012\012	typedef pointer _Unchecked_type;\012\012	_Myiter& _Rechecked(_Unchecked_type _Right)\012		{	// reset from unchecked iterator\012		_Idx = _Right - _Ptr;\012		return (*this);\012		}\012\012	_Unchecked_type _Unchecked() const\012		{	// make an unchecked iterator\012		return (_Ptr + _Idx);\012		}\012\012	reference operator*() const\012		{	// return designated object\012 #if _ITERATOR_DEBUG_LEVEL == 2\012		if (_Ptr == 0\012			|| _Size <= _Idx)\012			{	// report error\012			_DEBUG_ERROR(\"array iterator not dereferencable\");\012			_SCL_SECURE_OUT_OF_RANGE;\012			}\012\012 #elif _ITERATOR_DEBUG_LEVEL == 1\012		_SCL_SECURE_VALIDATE(_Ptr != 0);\012		_SCL_SECURE_VALIDATE_RANGE(_Idx < _Size);\012 #endif /* _ITERATOR_DEBUG_LEVEL */\012\012		__analysis_assume(_Ptr != 0);\012\012		return (_Ptr[_Idx]);\012		}\012\012	pointer operator->() const\012		{	// return pointer to class object\012		return (&**this);\012		}\012\012	_Myiter& operator++()\012		{	// preincrement\012 #if _ITERATOR_DEBUG_LEVEL == 2\012		if (_Ptr == 0\012			|| _Size <= _Idx)\012			{	// report error\012			_DEBUG_ERROR(\"array iterator not incrementable\");\012			_SCL_SECURE_OUT_OF_RANGE;\012			}\012\012 #elif _ITERATOR_DEBUG_LEVEL == 1\012		_SCL_SECURE_VALIDATE(_Ptr != 0);\012		_SCL_SECURE_VALIDATE_RANGE(_Idx < _Size);\012 #endif /* _ITERATOR_DEBUG_LEVEL */\012\012		++_Idx;\012		return (*this);\012		}\012\012	_Myiter operator++(int)\012		{	// postincrement\012		_Myiter _Tmp = *this;\012		++*this;\012		return (_Tmp);\012		}\012\012	_Myiter& operator--()\012		{	// predecrement\012 #if _ITERATOR_DEBUG_LEVEL == 2\012		if (_Ptr == 0\012			|| _Idx <= 0)\012			{	// report error\012			_DEBUG_ERROR(\"array iterator not decrementable\");\012			_SCL_SECURE_OUT_OF_RANGE;\012			}\012\012 #elif _ITERATOR_DEBUG_LEVEL == 1\012		_SCL_SECURE_VALIDATE(_Ptr != 0);\012		_SCL_SECURE_VALIDATE_RANGE(0 < _Idx);\012 #endif /* _ITERATOR_DEBUG_LEVEL */\012\012		--_Idx;\012		return (*this);\012		}\012\012	_Myiter operator--(int)\012		{	// postdecrement\012		_Myiter _Tmp = *this;\012		--*this;\012		return (_Tmp);\012		}\012\012	_Myiter& operator+=(difference_type _Off)\012		{	// increment by integer\012 #if _ITERATOR_DEBUG_LEVEL == 2\012		if (_Size < _Idx + _Off)\012			{	// report error\012			_DEBUG_ERROR(\"array iterator + offset out of range\");\012			_SCL_SECURE_OUT_OF_RANGE;\012			}\012\012 #elif _ITERATOR_DEBUG_LEVEL == 1\012		_SCL_SECURE_VALIDATE_RANGE(_Idx + _Off <= _Size);\012 #endif /* _ITERATOR_DEBUG_LEVEL */\012\012		_Idx += _Off;\012		return (*this);\012		}\012\012	_Myiter operator+(difference_type _Off) const\012		{	// return this + integer\012		_Myiter _Tmp = *this;\012		return (_Tmp += _Off);\012		}\012\012	_Myiter& operator-=(difference_type _Off)\012		{	// decrement by integer\012		return (*this += -_Off);\012		}\012\012	_Myiter operator-(difference_type _Off) const\012		{	// return this - integer\012		_Myiter _Tmp = *this;\012		return (_Tmp -= _Off);\012		}\012\012	difference_type operator-(const _Myiter& _Right) const\012		{	// return difference of iterators\012		_Compat(_Right);\012		return (_Idx < _Right._Idx\012			? -(difference_type)(_Right._Idx - _Idx)\012			: (difference_type)_Idx - _Right._Idx);\012		}\012\012	reference operator[](difference_type _Off) const\012		{	// subscript\012		return (*(*this + _Off));\012		}\012\012	bool operator==(const _Myiter& _Right) const\012		{	// test for iterator equality\012		_Compat(_Right);\012		return (_Idx == _Right._Idx);\012		}\012\012	bool operator!=(const _Myiter& _Right) const\012		{	// test for iterator inequality\012		return (!(*this == _Right));\012		}\012\012	bool operator<(const _Myiter& _Right) const\012		{	// test if this < _Right\012		_Compat(_Right);\012		return (_Idx < _Right._Idx);\012		}\012\012	bool operator>(const _Myiter& _Right) const\012		{	// test if this > _Right\012		return (_Right < *this);\012		}\012\012	bool operator<=(const _Myiter& _Right) const\012		{	// test if this <= _Right\012		return (!(_Right < *this));\012		}\012\012	bool operator>=(const _Myiter& _Right) const\012		{	// test if this >= _Right\012		return (!(*this < _Right));\012		}\012\012 #if _ITERATOR_DEBUG_LEVEL == 2\012	void _Compat(const _Myiter& _Right) const\012		{	// test for compatible iterator pair\012		if (_Ptr != _Right._Ptr)\012			{	// report error\012			_DEBUG_ERROR(\"array iterators incompatible\");\012			_SCL_SECURE_INVALID_ARGUMENT;\012			}\012		}\012\012 #elif _ITERATOR_DEBUG_LEVEL == 1\012	void _Compat(const _Myiter& _Right) const\012		{	// test for compatible iterator pair\012		_SCL_SECURE_VALIDATE_RANGE(_Ptr == _Right._Ptr);\012		}\012 #endif /* _ITERATOR_DEBUG_LEVEL */\012\012	pointer _Ptr;	// beginning of array\012	size_t _Idx;	// offset into array\012 #endif /* _ITERATOR_DEBUG_LEVEL == 0 */\012	};\012\012template<class _Ty,\012	size_t _Size> inline\012	typename _Array_const_iterator<_Ty, _Size>::_Unchecked_type\012		_Unchecked(_Array_const_iterator<_Ty, _Size> _Iter)\012	{	// convert to unchecked\012	return (_Iter._Unchecked());\012	}\012\012template<class _Ty,\012	size_t _Size> inline\012	_Array_const_iterator<_Ty, _Size>&\012		_Rechecked(_Array_const_iterator<_Ty, _Size>& _Iter,\012			typename _Array_const_iterator<_Ty, _Size>\012				::_Unchecked_type _Right)\012	{	// convert to checked\012	return (_Iter._Rechecked(_Right));\012	}\012\012template<class _Ty,\012	size_t _Size> inline\012	_Array_const_iterator<_Ty, _Size> operator+(\012		typename _Array_const_iterator<_Ty, _Size>::difference_type _Off,\012		_Array_const_iterator<_Ty, _Size> _Next)\012	{	// add offset to iterator\012	return (_Next += _Off);\012	}\012\012		// TEMPLATE CLASS _Array_iterator\012template<class _Ty,\012	size_t _Size>\012	class _Array_iterator\012		: public _Array_const_iterator<_Ty, _Size>\012	{	// iterator for mutable array\012public:\012	typedef _Array_iterator<_Ty, _Size> _Myiter;\012	typedef _Array_const_iterator<_Ty, _Size> _Mybase;\012	typedef random_access_iterator_tag iterator_category;\012\012	typedef _Ty value_type;\012	typedef size_t size_type;\012	typedef ptrdiff_t difference_type;\012	typedef _Ty *pointer;\012	typedef _Ty& reference;\012\012	_Array_iterator()\012		{	// construct with null pointer\012		}\012\012	explicit _Array_iterator(pointer _Parg, size_t _Off = 0)\012		: _Mybase(_Parg, _Off)\012		{	// construct with pointer and offset\012		}\012	enum {_EEN_SIZE = _Size};	// helper for expression evaluator\012	enum {_EEN_IDL =\012		_ITERATOR_DEBUG_LEVEL};	// helper for expression evaluator\012\012	typedef pointer _Unchecked_type;\012\012	_Myiter& _Rechecked(_Unchecked_type _Right)\012		{	// reset from unchecked iterator\012		((_Mybase *)this)->_Rechecked(_Right);\012		return (*this);\012		}\012\012	_Unchecked_type _Unchecked() const\012		{	// make an unchecked iterator\012		return ((pointer)((_Mybase *)this)->_Unchecked());\012		}\012\012	reference operator*() const\012		{	// return designated object\012		return ((reference)**(_Mybase *)this);\012		}\012\012	pointer operator->() const\012		{	// return pointer to class object\012		return (&**this);\012		}\012\012	_Myiter& operator++()\012		{	// preincrement\012		++*(_Mybase *)this;\012		return (*this);\012		}\012\012	_Myiter operator++(int)\012		{	// postincrement\012		_Myiter _Tmp = *this;\012		++*this;\012		return (_Tmp);\012		}\012\012	_Myiter& operator--()\012		{	// predecrement\012		--*(_Mybase *)this;\012		return (*this);\012		}\012\012	_Myiter operator--(int)\012		{	// postdecrement\012		_Myiter _Tmp = *this;\012		--*this;\012		return (_Tmp);\012		}\012\012	_Myiter& operator+=(difference_type _Off)\012		{	// increment by integer\012		*(_Mybase *)this += _Off;\012		return (*this);\012		}\012\012	_Myiter operator+(difference_type _Off) const\012		{	// return this + integer\012		_Myiter _Tmp = *this;\012		return (_Tmp += _Off);\012		}\012\012	_Myiter& operator-=(difference_type _Off)\012		{	// decrement by integer\012		return (*this += -_Off);\012		}\012\012	_Myiter operator-(difference_type _Off) const\012		{	// return this - integer\012		_Myiter _Tmp = *this;\012		return (_Tmp -= _Off);\012		}\012\012	difference_type operator-(const _Mybase& _Right) const\012		{	// return difference of iterators\012		return (*(_Mybase *)this - _Right);\012		}\012\012	reference operator[](difference_type _Off) const\012		{	// subscript\012		return (*(*this + _Off));\012		}\012	};\012\012template<class _Ty,\012	size_t _Size> inline\012	typename _Array_iterator<_Ty, _Size>::_Unchecked_type\012		_Unchecked(_Array_iterator<_Ty, _Size> _Iter)\012	{	// convert to unchecked\012	return (_Iter._Unchecked());\012	}\012\012template<class _Ty,\012	size_t _Size> inline\012	_Array_iterator<_Ty, _Size>&\012		_Rechecked(_Array_iterator<_Ty, _Size>& _Iter,\012			typename _Array_iterator<_Ty, _Size>\012				::_Unchecked_type _Right)\012	{	// convert to checked\012	return (_Iter._Rechecked(_Right));\012	}\012\012template<class _Ty,\012	size_t _Size> inline\012	_Array_iterator<_Ty, _Size> operator+(\012		typename _Array_iterator<_Ty, _Size>::difference_type _Off,\012		_Array_iterator<_Ty, _Size> _Next)\012	{	// add offset to iterator\012	return (_Next += _Off);\012	}\012\012		//	ALGORITHM STUFF (from <algorithm>)\012		// TEMPLATE FUNCTION max\012template<class _Ty> inline\012	const _Ty& (max)(const _Ty& _Left, const _Ty& _Right)\012	{	// return larger of _Left and _Right\012	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);\012	}\012\012		// TEMPLATE FUNCTION max WITH PRED\012template<class _Ty,\012	class _Pr> inline\012	const _Ty& (max)(const _Ty& _Left, const _Ty& _Right, _Pr _Pred)\012	{	// return larger of _Left and _Right using _Pred\012	return (_DEBUG_LT_PRED(_Pred, _Left, _Right) ? _Right : _Left);\012	}\012\012		// TEMPLATE FUNCTION min\012template<class _Ty> inline\012	const _Ty& (min)(const _Ty& _Left, const _Ty& _Right)\012	{	// return smaller of _Left and _Right\012	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);\012	}\012\012		// TEMPLATE FUNCTION min WITH PRED\012template<class _Ty,\012	class _Pr> inline\012	const _Ty& (min)(const _Ty& _Left, const _Ty& _Right, _Pr _Pred)\012	{	// return smaller of _Left and _Right using _Pred\012	return (_DEBUG_LT_PRED(_Pred, _Right, _Left) ? _Right : _Left);\012	}\012\012		// TEMPLATE FUNCTION minmax\012  #define _MINMAX_PAIR(ty)	pair<const ty, const ty>\012\012template<class _Ty> inline\012	_MINMAX_PAIR(_Ty)\012		minmax(const _Ty& _Left, const _Ty& _Right)\012	{	// return pair(leftmost/smaller, rightmost/larger) of _Left and _Right\012	return (_Right < _Left\012		? _MINMAX_PAIR(_Ty)(_Right, _Left)\012		: _MINMAX_PAIR(_Ty)(_Left, _Right));\012	}\012\012		// TEMPLATE FUNCTION minmax WITH PRED\012template<class _Ty,\012	class _Pr> inline\012	_MINMAX_PAIR(_Ty)\012		minmax(const _Ty& _Left, const _Ty& _Right, _Pr _Pred)\012	{	// return pair(leftmost/smaller, rightmost/larger) of _Left and _Right\012	return (_Pred(_Right, _Left)\012		? _MINMAX_PAIR(_Ty)(_Right, _Left)\012		: _MINMAX_PAIR(_Ty)(_Left, _Right));\012	}\012\012		// TEMPLATE FUNCTION iter_swap\012template<class _FwdIt1,\012	class _FwdIt2> inline\012	void iter_swap(_FwdIt1 _Left, _FwdIt2 _Right)\012	{	// swap *_Left and *_Right\012	swap(*_Left, *_Right);\012	}\012\012		// TEMPLATE FUNCTION copy\012template<class _InIt,\012	class _OutIt> inline\012	_OutIt _Copy_impl(_InIt _First, _InIt _Last,\012		_OutIt _Dest, _Nonscalar_ptr_iterator_tag)\012	{	// copy [_First, _Last) to [_Dest, ...), arbitrary iterators\012	for (; _First != _Last; ++_Dest, ++_First)\012		*_Dest = *_First;\012	return (_Dest);\012	}\012\012template<class _InIt,\012	class _OutIt> inline\012	_OutIt _Copy_impl(_InIt _First, _InIt _Last,\012		_OutIt _Dest, _Scalar_ptr_iterator_tag)\012	{	// copy [_First, _Last) to [_Dest, ...), pointers to scalars\012	ptrdiff_t _Count = _Last - _First;\012	_CSTD memmove(&*_Dest, &*_First,\012		_Count * sizeof (*_First));\012	return (_Dest + _Count);\012	}\012\012template<class _InIt,\012	class _OutIt> inline\012	_OutIt _Copy_impl(_InIt _First, _InIt _Last,\012		_OutIt _Dest)\012	{	// copy [_First, _Last) to [_Dest, ...)\012	return (_Copy_impl(_First, _Last,\012		_Dest, _Ptr_cat(_First, _Dest)));\012	}\012\012 #if _ITERATOR_DEBUG_LEVEL == 0\012template<class _InIt,\012	class _OutIt> inline\012	_OutIt copy(_InIt _First, _InIt _Last,\012		_OutIt _Dest)\012	{	// copy [_First, _Last) to [_Dest, ...)\012	return (_Rechecked(_Dest,\012		_Copy_impl(_Unchecked(_First), _Unchecked(_Last),\012			_Unchecked(_Dest))));\012	}\012\012 #else /* _ITERATOR_DEBUG_LEVEL == 0 */\012template<class _InIt,\012	class _OutIt> inline\012	_OutIt _Copy_impl(_InIt _First, _InIt _Last,\012		_OutIt _Dest, input_iterator_tag, output_iterator_tag)\012	{	// copy [_First, _Last) to [_Dest, ...), arbitrary iterators\012	return (_Copy_impl(_First, _Last,\012		_Dest));\012	}\012\012template<class _InIt,\012	class _OutIt> inline\012	_OutIt _Copy_impl(_InIt _First, _InIt _Last,\012		_OutIt _Dest, random_access_iterator_tag, random_access_iterator_tag)\012	{	// copy [_First, _Last) to [_Dest, ...), random-access iterators\012	_OutIt _Ans = _Dest + (_Last - _First);	// also checks range\012	_Copy_impl(_First, _Last,\012		_Unchecked(_Dest));\012	return (_Ans);\012	}\012\012template<class _InIt,\012	class _OutIt> inline\012	_OutIt _Copy_impl(_InIt _First, _InIt _Last,\012		_OutIt _Dest, _STD tr1::true_type)\012	{	// copy [_First, _Last) to [_Dest, ...), checked dest\012	return (_Copy_impl(_First, _Last,\012		_Dest, _Iter_cat(_First), _Iter_cat(_Dest)));\012	}\012\012template<class _InIt,\012	class _OutIt> inline\012_SCL_INSECURE_DEPRECATE\012	_OutIt _Copy_impl(_InIt _First, _InIt _Last,\012		_OutIt _Dest, _STD tr1::false_type)\012	{	// copy [_First, _Last) to [_Dest, ...), unchecked dest\012	return (_Copy_impl(_First, _Last,\012		_Dest, _Iter_cat(_First), _Iter_cat(_Dest)));\012	}\012\012template<class _InIt,\012	class _OutIt> inline\012	_OutIt copy(_InIt _First, _InIt _Last,\012		_OutIt _Dest)\012	{	// copy [_First, _Last) to [_Dest, ...)\012	_DEBUG_RANGE(_First, _Last);\012	_DEBUG_POINTER(_Dest);\012	return (_Copy_impl(_Unchecked(_First), _Unchecked(_Last),\012		_Dest, _Is_checked(_Dest)));\012	}\012\012template<class _InIt,\012	class _OutTy,\012	size_t _OutSize> inline\012	_OutTy *copy(_InIt _First, _InIt _Last,\012		_OutTy (&_Dest)[_OutSize])\012	{	// copy [_First, _Last) to [_Dest, ...)\012	return (_Unchecked(\012		_STD copy(_First, _Last,\012			_Array_iterator<_OutTy, _OutSize>(_Dest))));\012	}\012 #endif /* _ITERATOR_DEBUG_LEVEL == 0 */\012\012 #if _HAS_CPP0X\012		// TEMPLATE FUNCTION copy_n\012template<class _InIt,\012	class _Diff,\012	class _OutIt> inline\012	_OutIt _Copy_n(_InIt _First, _Diff _Count,\012		_OutIt _Dest, input_iterator_tag)\012	{	// copy [_First, _First + _Count) to [_Dest, ...), arbitrary input\012	*_Dest = *_First;	// 0 < _Count has been guaranteed\012	while (0 < --_Count)\012		*++_Dest = *++_First;\012	return (++_Dest);\012	}\012\012template<class _InIt,\012	class _Diff,\012	class _OutIt> inline\012	_OutIt _Copy_n(_InIt _First, _Diff _Count,\012		_OutIt _Dest, forward_iterator_tag)\012	{	// copy [_First, _First + _Count) to [_Dest, ...), forward input\012	for (; 0 < _Count; --_Count, ++_Dest, ++_First)\012		*_Dest = *_First;\012	return (_Dest);\012	}\012\012template<class _InIt,\012	class _Diff,\012	class _OutIt> inline\012	_OutIt _Copy_n(_InIt _First, _Diff _Count,\012		_OutIt _Dest, _Nonscalar_ptr_iterator_tag)\012	{	// copy [_First, _First + _Count) to [_Dest, ...), arbitrary iterators\012	return (_Copy_n(_First, _Count,\012		_Dest, _Iter_cat(_First)));\012	}\012\012template<class _InIt,\012	class _Diff,\012	class _OutIt> inline\012	_OutIt _Copy_n(_InIt _First, _Diff _Count,\012		_OutIt _Dest, _Scalar_ptr_iterator_tag)\012	{	// copy [_First, _First + _Count) to [_Dest, ...), pointers to scalars\012	_CSTD memmove(&*_Dest, &*_First,\012		_Count * sizeof (*_First));\012	return (_Dest + _Count);\012	}\012\012template<class _InIt,\012	class _Diff,\012	class _OutIt> inline\012	_OutIt _Copy_n(_InIt _First, _Diff _Count,\012		_OutIt _Dest)\012	{	// copy [_First, _First + _Count) to [_Dest, ...), unchecked\012	return (_Copy_n(_First, _Count,\012		_Dest, _Ptr_cat(_First, _Dest)));\012	}\012\012 #if _ITERATOR_DEBUG_LEVEL == 0\012template<class _InIt,\012	class _Diff,\012	class _OutIt> inline\012	_OutIt copy_n(_InIt _First, _Diff _Count,\012		_OutIt _Dest)\012	{	// copy [_First, _First + _Count) to [_Dest, ...)\012	if (_Count <= 0)\012		return (_Dest);\012	else\012		return (_Rechecked(_Dest,\012			_Copy_n(_Unchecked(_First), _Count,\012				_Unchecked(_Dest))));\012	}\012\012 #else /* _ITERATOR_DEBUG_LEVEL == 0 */\012template<class _InIt,\012	class _Diff,\012	class _OutIt> inline\012	_OutIt _Copy_n2(_InIt _First, _Diff _Count,\012		_OutIt _Dest, output_iterator_tag)\012	{	// copy [_First, _First + _Count) to [_Dest, ...), arbitrary dest\012	return (_Copy_n(_First, _Count,\012		_Dest));\012	}\012\012template<class _InIt,\012	class _Diff,\012	class _OutIt> inline\012	_OutIt _Copy_n2(_InIt _First, _Diff _Count,\012		_OutIt _Dest, random_access_iterator_tag)\012	{	// copy [_First, _First + _Count) to [_Dest, ...), random-access dest\012	_OutIt _Ans = _Dest + _Count;	// also checks range\012	_Copy_n(_First, _Count,\012		_Unchecked(_Dest));\012	return (_Ans);\012	}\012\012template<class _InIt,\012	class _Diff,\012	class _OutIt> inline\012	_OutIt _Copy_n1(_InIt _First, _Diff _Count,\012		_OutIt _Dest, input_iterator_tag)\012	{	// copy [_First, _First + _Count) to [_Dest, ...), arbitrary input\012	return (_Copy_n2(_First, _Count,\012		_Dest, _Iter_cat(_Dest)));\012	}\012\012template<class _InIt,\012	class _Diff,\012	class _OutIt> inline\012	_OutIt _Copy_n1(_InIt _First, _Diff _Count,\012		_OutIt _Dest, random_access_iterator_tag)\012	{	// copy [_First, _First + _Count) to [_Dest, ...), random-access input\012	_InIt _Last = _First + _Count;	// also checks range\012	_Last = _Last;	// to quiet diagnostics\012	return (_Copy_n2(_Unchecked(_First), _Count,\012		_Dest, _Iter_cat(_Dest)));\012	}\012\012template<class _InIt,\012	class _Diff,\012	class _OutIt> inline\012	_OutIt _Copy_n(_InIt _First, _Diff _Count,\012		_OutIt _Dest, _STD tr1::true_type)\012	{	// copy [_First, _First + _Count) to [_Dest, ...), checked dest\012	return (_Copy_n1(_First, _Count,\012		_Dest, _Iter_cat(_First)));\012	}\012\012template<class _InIt,\012	class _Diff,\012	class _OutIt> inline\012_SCL_INSECURE_DEPRECATE\012	_OutIt _Copy_n(_InIt _First, _Diff _Count,\012		_OutIt _Dest, _STD tr1::false_type)\012	{	// copy [_First, _First + _Count) to [_Dest, ...), unchecked dest\012	return (_Copy_n1(_First, _Count,\012		_Dest, _Iter_cat(_First)));\012	}\012\012template<class _InIt,\012	class _Diff,\012	class _OutIt> inline\012	_OutIt copy_n(_InIt _First, _Diff _Count,\012		_OutIt _Dest)\012	{	// copy [_First, _First + _Count) to [_Dest, ...)\012	_DEBUG_POINTER(_First);\012	_DEBUG_POINTER(_Dest);\012	if (_Count <= 0)\012		return (_Dest);\012	else\012		return (_Copy_n(_First, _Count,\012			_Dest, _Is_checked(_Dest)));\012	}\012\012template<class _InTy,\012	size_t _InSize,\012	class _Diff,\012	class _OutIt> inline\012	_OutIt copy_n(_InTy (&_First)[_InSize], _Diff _Count,\012		_OutIt _Dest)\012	{	// copy [_First, _First + _Count) to [_Dest, ...), array input\012	return (_STD copy_n(_Array_iterator<_InTy, _InSize>(_First), _Count,\012		_Dest));\012	}\012\012template<class _InIt,\012	class _Diff,\012	class _OutTy,\012	size_t _OutSize> inline\012	_OutTy *copy_n(_InIt _First, _Diff _Count,\012		_OutTy (&_Dest)[_OutSize])\012	{	// copy [_First, _First + _Count) to [_Dest, ...), array dest\012	return (_Unchecked(\012		_STD copy_n(_First, _Count,\012			_Array_iterator<_OutTy, _OutSize>(_Dest))));\012	}\012\012template<class _InTy,\012	size_t _InSize,\012	class _Diff,\012	class _OutTy,\012	size_t _OutSize> inline\012	_OutTy *copy_n(_InTy (&_First)[_InSize], _Diff _Count,\012		_OutTy (&_Dest)[_OutSize])\012	{	// copy [_First, _First + _Count) to [_Dest, ...), array input/dest\012	return (_Unchecked(\012		_STD copy_n(_Array_iterator<_InTy, _InSize>(_First), _Count,\012			_Array_iterator<_OutTy, _OutSize>(_Dest))));\012	}\012\012 #endif /* _ITERATOR_DEBUG_LEVEL == 0 */\012 #endif /* _HAS_CPP0X */\012\012		// TEMPLATE FUNCTION copy_backward\012template<class _BidIt1,\012	class _BidIt2> inline\012	_BidIt2 _Copy_backward(_BidIt1 _First, _BidIt1 _Last,\012		_BidIt2 _Dest, _Nonscalar_ptr_iterator_tag)\012	{	// copy [_First, _Last) backwards to [..., _Dest), arbitrary iterators\012	while (_First != _Last)\012		*--_Dest = *--_Last;\012	return (_Dest);\012	}\012\012template<class _InIt,\012	class _OutIt> inline\012	_OutIt _Copy_backward(_InIt _First, _InIt _Last,\012		_OutIt _Dest, _Scalar_ptr_iterator_tag)\012	{	// copy [_First, _Last) backwards to [..., _Dest), pointers to scalars\012	ptrdiff_t _Count = _Last - _First;\012	_CSTD memmove(&*_Dest - _Count, &*_First,\012		_Count * sizeof (*_First));\012	return (_Dest - _Count);\012	}\012\012template<class _BidIt1,\012	class _BidIt2> inline\012	_BidIt2 _Copy_backward(_BidIt1 _First, _BidIt1 _Last,\012		_BidIt2 _Dest)\012	{	// copy [_First, _Last) backwards to [..., _Dest), unchecked\012	return (_Copy_backward(_First, _Last,\012		_Dest, _Ptr_cat(_First, _Dest)));\012	}\012\012 #if _ITERATOR_DEBUG_LEVEL == 0\012template<class _BidIt1,\012	class _BidIt2> inline\012	_BidIt2 copy_backward(_BidIt1 _First, _BidIt1 _Last,\012		_BidIt2 _Dest)\012	{	// copy [_First, _Last) backwards to [..., _Dest)\012	return (_Rechecked(_Dest,\012		_Copy_backward(_Unchecked(_First), _Unchecked(_Last),\012			_Unchecked(_Dest))));\012	}\012\012 #else /* _ITERATOR_DEBUG_LEVEL == 0 */\012template<class _BidIt1,\012	class _BidIt2> inline\012	_BidIt2 _Copy_backward(_BidIt1 _First, _BidIt1 _Last,\012		_BidIt2 _Dest, _STD tr1::true_type)\012	{	// copy [_First, _Last) backwards to [..., _Dest), checked dest\012	return (_Copy_backward(_Unchecked(_First), _Unchecked(_Last),\012		_Dest));\012	}\012\012template<class _BidIt1,\012	class _BidIt2> inline\012_SCL_INSECURE_DEPRECATE\012	_BidIt2 _Copy_backward(_BidIt1 _First, _BidIt1 _Last,\012		_BidIt2 _Dest, _STD tr1::false_type)\012	{	// copy [_First, _Last) backwards to [..., _Dest), unchecked dest\012	return (_Copy_backward(_Unchecked(_First), _Unchecked(_Last),\012		_Dest));\012	}\012\012template<class _BidIt1,\012	class _BidIt2> inline\012	_BidIt2 copy_backward(_BidIt1 _First, _BidIt1 _Last,\012		_BidIt2 _Dest)\012	{	// copy [_First, _Last) backwards to [..., _Dest)\012	_DEBUG_RANGE(_First, _Last);\012	_DEBUG_POINTER(_Dest);\012	return (_Copy_backward(_Unchecked(_First), _Unchecked(_Last),\012		_Dest, _Is_checked(_Dest)));\012	}\012 #endif /* _ITERATOR_DEBUG_LEVEL == 0 */\012\012		// TEMPLATE FUNCTION move\012template<class _InIt,\012	class _OutIt> inline\012	_OutIt _Move(_InIt _First, _InIt _Last,\012		_OutIt _Dest, _Nonscalar_ptr_iterator_tag)\012	{	// move [_First, _Last) to [_Dest, ...), arbitrary iterators\012	for (; _First != _Last; ++_Dest, ++_First)\012		*_Dest = _STD move(*_First);\012	return (_Dest);\012	}\012\012template<class _InIt,\012	class _OutIt> inline\012	_OutIt _Move(_InIt _First, _InIt _Last,\012		_OutIt _Dest, _Scalar_ptr_iterator_tag)\012	{	// move [_First, _Last) to [_Dest, ...), pointers to scalars\012	ptrdiff_t _Count = _Last - _First;\012	_CSTD memmove(&*_Dest, &*_First,\012		_Count * sizeof (*_First));\012	return (_Dest + _Count);\012	}\012\012template<class _InIt,\012	class _OutIt> inline\012	_OutIt _Move(_InIt _First, _InIt _Last,\012		_OutIt _Dest)\012	{	// move [_First, _Last) to [_Dest, ...), unchecked\012	return (_Move(_First, _Last,\012		_Dest, _Ptr_cat(_First, _Dest)));\012	}\012\012 #if _ITERATOR_DEBUG_LEVEL == 0\012template<class _InIt,\012	class _OutIt> inline\012	_OutIt move(_InIt _First, _InIt _Last,\012		_OutIt _Dest)\012	{	// move [_First, _Last) to [_Dest, ...)\012	return (_Rechecked(_Dest,\012		_Move(_Unchecked(_First), _Unchecked(_Last),\012			_Unchecked(_Dest))));\012	}\012\012 #else /* _ITERATOR_DEBUG_LEVEL == 0 */\012template<class _InIt,\012	class _OutIt> inline\012	_OutIt _Move(_InIt _First, _InIt _Last,\012		_OutIt _Dest, input_iterator_tag, output_iterator_tag)\012	{	// move [_First, _Last) to [_Dest, ...), arbitrary iterators\012	return (_Move(_First, _Last,\012		_Dest));\012	}\012\012template<class _InIt,\012	class _OutIt> inline\012	_OutIt _Move(_InIt _First, _InIt _Last,\012		_OutIt _Dest, random_access_iterator_tag, random_access_iterator_tag)\012	{	// move [_First, _Last) to [_Dest, ...), random-access iterators\012	_OutIt _Ans = _Dest + (_Last - _First);	// also checks range\012	_Move(_First, _Last,\012		_Unchecked(_Dest));\012	return (_Ans);\012	}\012\012template<class _InIt,\012	class _OutIt> inline\012	_OutIt _Move(_InIt _First, _InIt _Last,\012		_OutIt _Dest, _STD tr1::true_type)\012	{	// move [_First, _Last) to [_Dest, ...), checked dest\012	return (_Move(_First, _Last,\012		_Dest, _Iter_cat(_First), _Iter_cat(_Dest)));\012	}\012\012template<class _InIt,\012	class _OutIt> inline\012_SCL_INSECURE_DEPRECATE\012	_OutIt _Move(_InIt _First, _InIt _Last,\012		_OutIt _Dest, _STD tr1::false_type)\012	{	// move [_First, _Last) to [_Dest, ...), unchecked dest\012	return (_Move(_First, _Last,\012		_Dest, _Iter_cat(_First), _Iter_cat(_Dest)));\012	}\012\012template<class _InIt,\012	class _OutIt> inline\012	_OutIt move(_InIt _First, _InIt _Last,\012		_OutIt _Dest)\012	{	// move [_First, _Last) to [_Dest, ...)\012	_DEBUG_RANGE(_First, _Last);\012	_DEBUG_POINTER(_Dest);\012	return (_Move(_Unchecked(_First), _Unchecked(_Last),\012		_Dest, _Is_checked(_Dest)));\012	}\012\012template<class _InIt,\012	class _OutTy,\012	size_t _OutSize> inline\012	_OutTy *move(_InIt _First, _InIt _Last,\012		_OutTy (&_Dest)[_OutSize])\012	{	// move [_First, _Last) to [_Dest, ...)\012	return (_Unchecked(\012		_STD move(_First, _Last,\012			_Array_iterator<_OutTy, _OutSize>(_Dest))));\012	}\012 #endif /* _ITERATOR_DEBUG_LEVEL == 0 */\012\012		// TEMPLATE FUNCTION move_backward\012template<class _BidIt1,\012	class _BidIt2> inline\012	_BidIt2 _Move_backward(_BidIt1 _First, _BidIt1 _Last,\012		_BidIt2 _Dest, _Nonscalar_ptr_iterator_tag)\012	{	// move [_First, _Last) backwards to [..., _Dest), arbitrary iterators\012	while (_First != _Last)\012		*--_Dest = _STD move(*--_Last);\012	return (_Dest);\012	}\012\012template<class _InIt,\012	class _OutIt> inline\012	_OutIt _Move_backward(_InIt _First, _InIt _Last,\012		_OutIt _Dest, _Scalar_ptr_iterator_tag)\012	{	// move [_First, _Last) backwards to [..., _Dest), pointers to scalars\012	ptrdiff_t _Count = _Last - _First;\012	_CSTD memmove(&*_Dest - _Count, &*_First,\012		_Count * sizeof (*_First));\012	return (_Dest - _Count);\012	}\012\012template<class _BidIt1,\012	class _BidIt2> inline\012	_BidIt2 _Move_backward(_BidIt1 _First, _BidIt1 _Last,\012		_BidIt2 _Dest)\012	{	// move [_First, _Last) backwards to [..., _Dest), unchecked\012	return (_Move_backward(_First, _Last,\012		_Dest, _Ptr_cat(_First, _Dest)));\012	}\012\012 #if _ITERATOR_DEBUG_LEVEL == 0\012template<class _BidIt1,\012	class _BidIt2> inline\012	_BidIt2 move_backward(_BidIt1 _First, _BidIt1 _Last,\012		_BidIt2 _Dest)\012	{	// move [_First, _Last) backwards to [..., _Dest)\012	return (_Rechecked(_Dest,\012		_Move_backward(_Unchecked(_First), _Unchecked(_Last),\012			_Unchecked(_Dest))));\012	}\012\012 #else /* _ITERATOR_DEBUG_LEVEL == 0 */\012template<class _BidIt1,\012	class _BidIt2> inline\012	_BidIt2 _Move_backward(_BidIt1 _First, _BidIt1 _Last,\012		_BidIt2 _Dest, _STD tr1::true_type)\012	{	// move [_First, _Last) backwards to [..., _Dest), checked dest\012	return (_Move_backward(_Unchecked(_First), _Unchecked(_Last),\012		_Dest));\012	}\012\012template<class _BidIt1,\012	class _BidIt2> inline\012_SCL_INSECURE_DEPRECATE\012	_BidIt2 _Move_backward(_BidIt1 _First, _BidIt1 _Last,\012		_BidIt2 _Dest, _STD tr1::false_type)\012	{	// move [_First, _Last) backwards to [..., _Dest), unchecked dest\012	return (_Move_backward(_Unchecked(_First), _Unchecked(_Last),\012		_Dest));\012	}\012\012template<class _BidIt1,\012	class _BidIt2> inline\012	_BidIt2 move_backward(_BidIt1 _First, _BidIt1 _Last,\012		_BidIt2 _Dest)\012	{	// move [_First, _Last) backwards to [..., _Dest)\012	_DEBUG_RANGE(_First, _Last);\012	_DEBUG_POINTER(_Dest);\012	return (_Move_backward(_Unchecked(_First), _Unchecked(_Last),\012		_Dest, _Is_checked(_Dest)));\012	}\012 #endif /* _ITERATOR_DEBUG_LEVEL == 0 */\012\012		// TEMPLATE FUNCTION fill\012template<class _FwdIt,\012	class _Ty> inline\012	void _Fill(_FwdIt _First, _FwdIt _Last, const _Ty& _Val)\012	{	// copy _Val through [_First, _Last)\012	for (; _First != _Last; ++_First)\012		*_First = _Val;\012	}\012\012inline void _Fill(char *_First, char *_Last, int _Val)\012	{	// copy char _Val through [_First, _Last)\012	_CSTD memset(_First, _Val, _Last - _First);\012	}\012\012inline void _Fill(signed char *_First, signed char *_Last, int _Val)\012	{	// copy signed char _Val through [_First, _Last)\012	_CSTD memset(_First, _Val, _Last - _First);\012	}\012\012inline void _Fill(unsigned char *_First, unsigned char *_Last, int _Val)\012	{	// copy unsigned char _Val through [_First, _Last)\012	_CSTD memset(_First, _Val, _Last - _First);\012	}\012\012template<class _FwdIt,\012	class _Ty> inline\012	void fill(_FwdIt _First, _FwdIt _Last, const _Ty& _Val)\012	{	// copy _Val through [_First, _Last)\012	_DEBUG_RANGE(_First, _Last);\012	_Fill(_Unchecked(_First), _Unchecked(_Last), _Val);\012	}\012\012		// TEMPLATE FUNCTION fill_n\012template<class _OutIt,\012	class _Diff,\012	class _Ty> inline\012	void _Fill_n(_OutIt _Dest, _Diff _Count, const _Ty& _Val)\012	{	// copy _Val _Count times through [_Dest, ...)\012	for (; 0 < _Count; --_Count, ++_Dest)\012		*_Dest = _Val;\012	}\012\012inline void _Fill_n(char *_Dest, size_t _Count, int _Val)\012	{	// copy char _Val _Count times through [_Dest, ...)\012	_CSTD memset(_Dest, _Val, _Count);\012	}\012\012inline void _Fill_n(signed char *_Dest, size_t _Count, int _Val)\012	{	// copy signed char _Val _Count times through [_Dest, ...)\012	_CSTD memset(_Dest, _Val, _Count);\012	}\012\012inline void _Fill_n(unsigned char *_Dest, size_t _Count, int _Val)\012	{	// copy unsigned char _Val _Count times through [_Dest, ...)\012	_CSTD memset(_Dest, _Val, _Count);\012	}\012\012 #if _ITERATOR_DEBUG_LEVEL == 0\012template<class _OutIt,\012	class _Diff,\012	class _Ty> inline\012	void fill_n(_OutIt _Dest, _Diff _Count, const _Ty& _Val)\012	{	// copy _Val _Count times through [_Dest, ...)\012	_Fill_n(_Unchecked(_Dest), _Count, _Val);\012	}\012\012 #else /* _ITERATOR_DEBUG_LEVEL == 0 */\012template<class _OutIt,\012	class _Diff,\012	class _Ty> inline\012	void _Fill_n1(_OutIt _Dest, _Diff _Count, const _Ty& _Val,\012		output_iterator_tag)\012	{	// copy _Val _Count times through [_Dest, ...), arbitrary iterator\012	_Fill_n(_Dest, _Count, _Val);\012	}\012\012template<class _OutIt,\012	class _Diff,\012	class _Ty> inline\012	void _Fill_n1(_OutIt _Dest, _Diff _Count, const _Ty& _Val,\012		random_access_iterator_tag)\012	{	// copy _Val _Count times through [_Dest, ...), random-access iterator\012	_OutIt _Ans = _Dest + _Count;	// also checks range\012	_Ans = _Ans;	// to quiet diagnostics\012	_Fill_n(_Unchecked(_Dest), _Count, _Val);\012	}\012\012template<class _OutIt,\012	class _Diff,\012	class _Ty> inline\012	void _Fill_n(_OutIt _Dest, _Diff _Count, const _Ty& _Val,\012		_STD tr1::true_type)\012	{	// copy _Val _Count times through [_Dest, ...), checked dest\012	_Fill_n1(_Dest, _Count, _Val,\012		_Iter_cat(_Dest));\012	}\012\012template<class _OutIt,\012	class _Diff,\012	class _Ty> inline\012_SCL_INSECURE_DEPRECATE\012	void _Fill_n(_OutIt _Dest, _Diff _Count, const _Ty& _Val,\012		_STD tr1::false_type)\012	{	// copy _Val _Count times through [_Dest, ...), unchecked dest\012	_Fill_n1(_Dest, _Count, _Val,\012		_Iter_cat(_Dest));\012	}\012\012template<class _OutIt,\012	class _Diff,\012	class _Ty> inline\012	void fill_n(_OutIt _Dest, _Diff _Count, const _Ty& _Val)\012	{	// copy _Val _Count times through [_Dest, ...)\012	_DEBUG_POINTER(_Dest);\012	_Fill_n(_Dest, _Count, _Val,\012		_Is_checked(_Dest));\012	}\012\012template<class _OutTy,\012	size_t _OutSize,\012	class _Diff,\012	class _Ty> inline\012	void fill_n(_OutTy (&_Dest)[_OutSize], _Diff _Count, const _Ty& _Val)\012	{	// copy _Val _Count times through [_Dest, ...)\012	_STD fill_n(_Array_iterator<_OutTy, _OutSize>(_Dest), _Count, _Val);\012	}\012 #endif /* _ITERATOR_DEBUG_LEVEL == 0 */\012\012		// TEMPLATE FUNCTION mismatch\012template<class _InIt1,\012	class _InIt2> inline\012	pair<_InIt1, _InIt2>\012		_Mismatch(_InIt1 _First1, _InIt1 _Last1,\012			_InIt2 _First2)\012	{	// return [_First1, _Last1)/[_First2, ...) mismatch\012	for (; _First1 != _Last1 && *_First1 == *_First2; )\012		++_First1, ++_First2;\012	return (pair<_InIt1, _InIt2>(_First1, _First2));\012	}\012\012 #if _ITERATOR_DEBUG_LEVEL == 0\012template<class _InIt1,\012	class _InIt2> inline\012	pair<_InIt1, _InIt2>\012		mismatch(_InIt1 _First1, _InIt1 _Last1,\012			_InIt2 _First2)\012	{	// return [_First1, _Last1)/[_First2, ...) mismatch\012	_STD pair<_UNCHECKED_TYPE(_InIt1), _InIt2> _Ans(\012		_STD _Mismatch(_Unchecked(_First1), _Unchecked(_Last1),\012			_First2));\012	return (_STD pair<_InIt1, _InIt2>(\012		_Rechecked(_First1, _Ans.first),\012		_Ans.second));\012	}\012\012 #else /* _ITERATOR_DEBUG_LEVEL == 0 */\012template<class _InIt1,\012	class _InIt2> inline\012	pair<_InIt1, _InIt2>\012		_Mismatch1(_InIt1 _First1, _InIt1 _Last1,\012			_InIt2 _First2, _STD tr1::true_type)\012	{	// return [_First1, _Last1)/[_First2, ...) mismatch, checked input\012	return (_STD _Mismatch(_First1, _Last1,\012		_First2));\012	}\012\012template<class _InIt1,\012	class _InIt2> inline\012_SCL_INSECURE_DEPRECATE\012	pair<_InIt1, _InIt2>\012		_Mismatch1(_InIt1 _First1, _InIt1 _Last1,\012			_InIt2 _First2, _STD tr1::false_type)\012	{	// return [_First1, _Last1)/[_First2, ...) mismatch, unchecked input\012	return (_STD _Mismatch(_First1, _Last1,\012		_First2));\012	}\012\012template<class _InIt1,\012	class _InIt2> inline\012	pair<_InIt1, _InIt2>\012		mismatch(_InIt1 _First1, _InIt1 _Last1,\012			_InIt2 _First2)\012	{	// return [_First1, _Last1)/[_First2, ...) mismatch\012	_DEBUG_RANGE(_First1, _Last1);\012	_DEBUG_POINTER(_First2);\012	_STD pair<_UNCHECKED_TYPE(_InIt1), _InIt2> _Ans(\012		_STD _Mismatch1(_Unchecked(_First1), _Unchecked(_Last1),\012			_First2, _Is_checked(_First2)));\012	return (_STD pair<_InIt1, _InIt2>(\012		_Rechecked(_First1, _Ans.first),\012		_Ans.second));\012	}\012\012template<class _InIt1,\012	class _InTy,\012	size_t _InSize> inline\012	pair<_InIt1, _InTy *>\012		mismatch(_InIt1 _First1, _InIt1 _Last1,\012			_InTy (&_First2)[_InSize])\012	{	// return [_First1, _Last1)/[_First2, ...) mismatch, array input\012	_STD pair<_InIt1, _Array_iterator<_InTy, _InSize> > _Ans(\012		_STD mismatch(_First1, _Last1,\012			_Array_iterator<_InTy, _InSize>(_First2)));\012	return (_STD pair<_InIt1, _InTy *>(\012		_Ans.first,\012		_Unchecked(_Ans.second)));\012	}\012\012 #endif /* _ITERATOR_DEBUG_LEVEL == 0 */\012\012		// TEMPLATE FUNCTION mismatch WITH PRED\012template<class _InIt1,\012	class _InIt2,\012	class _Pr> inline\012	pair<_InIt1, _InIt2>\012		_Mismatch(_InIt1 _First1, _InIt1 _Last1,\012			_InIt2 _First2, _Pr _Pred)\012	{	// return [_First1, _Last1)/[_First2, ...) mismatch using _Pred\012	for (; _First1 != _Last1 && _Pred(*_First1, *_First2); )\012		++_First1, ++_First2;\012	return (pair<_InIt1, _InIt2>(_First1, _First2));\012	}\012\012 #if _ITERATOR_DEBUG_LEVEL == 0\012template<class _InIt1,\012	class _InIt2,\012	class _Pr> inline\012	pair<_InIt1, _InIt2>\012		mismatch(_InIt1 _First1, _InIt1 _Last1,\012			_InIt2 _First2, _Pr _Pred)\012	{	// return [_First1, _Last1)/[_First2, ...) mismatch using _Pred\012	_STD pair<_UNCHECKED_TYPE(_InIt1), _InIt2> _Ans(\012		_STD _Mismatch(_Unchecked(_First1), _Unchecked(_Last1),\012			_First2, _Pred));\012	return (_STD pair<_InIt1, _InIt2>(\012		_Rechecked(_First1, _Ans.first),\012		_Ans.second));\012	}\012\012 #else /* _ITERATOR_DEBUG_LEVEL == 0 */\012template<class _InIt1,\012	class _InIt2,\012	class _Pr> inline\012	pair<_InIt1, _InIt2>\012		_Mismatch2(_InIt1 _First1, _InIt1 _Last1,\012			_InIt2 _First2, _Pr _Pred, _STD tr1::true_type)\012	{	// return [_First1, _Last1)/[_First2, ...) mismatch, checked input\012	return (_STD _Mismatch(_First1, _Last1,\012		_First2, _Pred));\012	}\012\012template<class _InIt1,\012	class _InIt2,\012	class _Pr> inline\012_SCL_INSECURE_DEPRECATE\012	pair<_InIt1, _InIt2>\012		_Mismatch2(_InIt1 _First1, _InIt1 _Last1,\012			_InIt2 _First2, _Pr _Pred, _STD tr1::false_type)\012	{	// return [_First1, _Last1)/[_First2, ...) mismatch, unchecked input\012	return (_STD _Mismatch(_First1, _Last1,\012		_First2, _Pred));\012	}\012\012template<class _InIt1,\012	class _InIt2,\012	class _Pr> inline\012	pair<_InIt1, _InIt2>\012		mismatch(_InIt1 _First1, _InIt1 _Last1,\012			_InIt2 _First2, _Pr _Pred)\012	{	// return [_First1, _Last1)/[_First2, ...) mismatch using _Pred\012	_DEBUG_RANGE(_First1, _Last1);\012	_DEBUG_POINTER(_First2);\012	_DEBUG_POINTER(_Pred);\012	_STD pair<_UNCHECKED_TYPE(_InIt1), _InIt2> _Ans(\012		_STD _Mismatch2(_Unchecked(_First1), _Unchecked(_Last1),\012			_First2, _Pred, _Is_checked(_First2)));\012	return (_STD pair<_InIt1, _InIt2>(\012		_Rechecked(_First1, _Ans.first),\012		_Ans.second));\012	}\012\012template<class _InIt1,\012	class _InTy,\012	size_t _InSize,\012	class _Pr> inline\012	pair<_InIt1, _InTy *>\012		mismatch(_InIt1 _First1, _InIt1 _Last1,\012			_InTy (&_First2)[_InSize], _Pr _Pred)\012	{	// return [_First1, _Last1)/[_First2, ...) mismatch using _Pred\012	_STD pair<_InIt1, _Array_iterator<_InTy, _InSize> > _Ans(\012		_STD mismatch(_First1, _Last1,\012			_Array_iterator<_InTy, _InSize>(_First2), _Pred));\012	return (_STD pair<_InIt1, _InTy *>(\012		_Ans.first,\012		_Unchecked(_Ans.second)));\012	}\012 #endif /* _ITERATOR_DEBUG_LEVEL == 0 */\012\012		// TEMPLATE FUNCTION equal\012template<class _InIt1,\012	class _InIt2> inline\012	bool _Equal(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2)\012	{	// compare [_First1, _Last1) to [First2, ...)\012	for (; _First1 != _Last1; ++_First1, ++_First2)\012		if (!(*_First1 == *_First2))\012			return (false);\012	return (true);\012	}\012\012inline bool _Equal(const char *_First1, const char *_Last1,\012	const char *_First2)\012	{	// compare [_First1, _Last1) to [First2, ...), for chars\012	return (_CSTD memcmp(_First1, _First2, _Last1 - _First1) == 0);\012	}\012\012inline bool _Equal(const signed char *_First1, const signed char *_Last1,\012	const signed char *_First2)\012	{	// compare [_First1, _Last1) to [First2, ...), for signed chars\012	return (_CSTD memcmp(_First1, _First2, _Last1 - _First1) == 0);\012	}\012\012inline bool _Equal(const unsigned char *_First1, const unsigned char *_Last1,\012	const unsigned char *_First2)\012	{	// compare [_First1, _Last1) to [First2, ...), for unsigned chars\012	return (_CSTD memcmp(_First1, _First2, _Last1 - _First1) == 0);\012	}\012\012 #if _ITERATOR_DEBUG_LEVEL == 0\012template<class _InIt1,\012	class _InIt2> inline\012	bool equal(_InIt1 _First1, _InIt1 _Last1,\012		_InIt2 _First2)\012	{	// compare [_First1, _Last1) to [First2, ...)\012	return (_Equal(_Unchecked(_First1), _Unchecked(_Last1),\012		_Unchecked(_First2)));\012	}\012\012 #else /* _ITERATOR_DEBUG_LEVEL == 0 */\012template<class _InIt1,\012	class _InIt2> inline\012	bool _Equal1(_InIt1 _First1, _InIt1 _Last1,\012		_InIt2 _First2, _STD tr1::true_type)\012	{	// compare [_First1, _Last1) to [First2, ...), checked dest\012	return (_Equal(_First1, _Last1,\012		_First2));\012	}\012\012template<class _InIt1,\012	class _InIt2> inline\012_SCL_INSECURE_DEPRECATE\012	bool _Equal1(_InIt1 _First1, _InIt1 _Last1,\012		_InIt2 _First2, _STD tr1::false_type)\012	{	// compare [_First1, _Last1) to [First2, ...), unchecked dest\012	return (_Equal(_First1, _Last1,\012		_First2));\012	}\012\012template<class _InIt1,\012	class _InIt2> inline\012	bool equal(_InIt1 _First1, _InIt1 _Last1,\012		_InIt2 _First2)\012	{	// compare [_First1, _Last1) to [First2, ...)\012	_DEBUG_RANGE(_First1, _Last1);\012	_DEBUG_POINTER(_First2);\012	return (_Equal1(_Unchecked(_First1), _Unchecked(_Last1),\012		_First2, _Is_checked(_First2)));\012	}\012\012template<class _InIt1,\012	class _InTy,\012	size_t _InSize> inline\012	bool equal(_InIt1 _First1, _InIt1 _Last1,\012		_InTy (&_First2)[_InSize])\012	{	// compare [_First1, _Last1) to [First2, ...)\012	return (_STD equal(_First1, _Last1,\012		_Array_iterator<_InTy, _InSize>(_First2)));\012	}\012 #endif /* _ITERATOR_DEBUG_LEVEL == 0 */\012\012		// TEMPLATE FUNCTION equal WITH PRED\012template<class _InIt1,\012	class _InIt2,\012	class _Pr> inline\012	bool _Equal(_InIt1 _First1, _InIt1 _Last1,\012		_InIt2 _First2, _Pr _Pred)\012	{	// compare [_First1, _Last1) to [First2, ...) using _Pred\012	for (; _First1 != _Last1; ++_First1, ++_First2)\012		if (!_Pred(*_First1, *_First2))\012			return (false);\012	return (true);\012	}\012\012 #if _ITERATOR_DEBUG_LEVEL == 0\012template<class _InIt1,\012	class _InIt2,\012	class _Pr> inline\012	bool equal(_InIt1 _First1, _InIt1 _Last1,\012		_InIt2 _First2, _Pr _Pred)\012	{	// compare [_First1, _Last1) to [First2, ...)\012	return (_Equal(_Unchecked(_First1), _Unchecked(_Last1),\012		_Unchecked(_First2), _Pred));\012	}\012\012 #else /* _ITERATOR_DEBUG_LEVEL == 0 */\012template<class _InIt1,\012	class _InIt2,\012	class _Pr> inline\012	bool _Equal2(_InIt1 _First1, _InIt1 _Last1,\012		_InIt2 _First2, _Pr _Pred, _STD tr1::true_type)\012	{	// compare [_First1, _Last1) to [First2, ...), checked input\012	return (_Equal(_First1, _Last1,\012		_First2, _Pred));\012	}\012\012template<class _InIt1,\012	class _InIt2,\012	class _Pr> inline\012_SCL_INSECURE_DEPRECATE\012	bool _Equal2(_InIt1 _First1, _InIt1 _Last1,\012		_InIt2 _First2, _Pr _Pred, _STD tr1::false_type)\012	{	// compare [_First1, _Last1) to [First2, ...), unchecked input\012	return (_Equal(_First1, _Last1,\012		_First2, _Pred));\012	}\012\012template<class _InIt1,\012	class _InIt2,\012	class _Pr> inline\012	bool equal(_InIt1 _First1, _InIt1 _Last1,\012		_InIt2 _First2, _Pr _Pred)\012	{	// compare [_First1, _Last1) to [First2, ...)\012	_DEBUG_RANGE(_First1, _Last1);\012	_DEBUG_POINTER(_First2);\012	return (_Equal2(_Unchecked(_First1), _Unchecked(_Last1),\012		_First2, _Pred, _Is_checked(_First2)));\012	}\012\012template<class _InIt1,\012	class _InTy,\012	size_t _InSize,\012	class _Pr> inline\012	bool equal(_InIt1 _First1, _InIt1 _Last1,\012		_InTy (&_First2)[_InSize], _Pr _Pred)\012	{	// compare [_First1, _Last1) to [First2, ...)\012	return (_STD equal(_First1, _Last1,\012		_Array_iterator<_InTy, _InSize>(_First2), _Pred));\012	}\012 #endif /* _ITERATOR_DEBUG_LEVEL == 0 */\012\012		// TEMPLATE FUNCTION lexicographical_compare\012template<class _InIt1,\012	class _InIt2> inline\012	bool _Lexicographical_compare(_InIt1 _First1, _InIt1 _Last1,\012		_InIt2 _First2, _InIt2 _Last2)\012	{	// order [_First1, _Last1) vs. [First2, Last2)\012	for (; _First1 != _Last1 && _First2 != _Last2; ++_First1, ++_First2)\012		if (_DEBUG_LT(*_First1, *_First2))\012			return (true);\012		else if (*_First2 < *_First1)\012			return (false);\012	return (_First1 == _Last1 && _First2 != _Last2);\012	}\012\012inline bool _Lexicographical_compare(\012	const unsigned char *_First1, const unsigned char *_Last1,\012	const unsigned char *_First2, const unsigned char *_Last2)\012	{	// order [_First1, _Last1) vs. [First2, Last2), for unsigned char\012	ptrdiff_t _Num1 = _Last1 - _First1;\012	ptrdiff_t _Num2 = _Last2 - _First2;\012	int _Ans = _CSTD memcmp(_First1, _First2, _Num1 < _Num2 ? _Num1 : _Num2);\012	return (_Ans < 0 || _Ans == 0 && _Num1 < _Num2);\012	}\012\012 #if CHAR_MAX == UCHAR_MAX\012inline bool _Lexicographical_compare(\012	const char *_First1, const char *_Last1,\012	const char *_First2, const char *_Last2)\012	{	// order [_First1, _Last1) vs. [First2, Last2), for nonnegative char\012	ptrdiff_t _Num1 = _Last1 - _First1;\012	ptrdiff_t _Num2 = _Last2 - _First2;\012	int _Ans = _CSTD memcmp(_First1, _First2, _Num1 < _Num2 ? _Num1 : _Num2);\012	return (_Ans < 0 || _Ans == 0 && _Num1 < _Num2);\012	}\012 #endif /* CHAR_MAX == UCHAR_MAX */\012\012template<class _InIt1,\012	class _InIt2> inline\012	bool lexicographical_compare(_InIt1 _First1, _InIt1 _Last1,\012		_InIt2 _First2, _InIt2 _Last2)\012	{	// order [_First1, _Last1) vs. [First2, Last2)\012	_DEBUG_RANGE(_First1, _Last1);\012	_DEBUG_RANGE(_First2, _Last2);\012	return (_Lexicographical_compare(_Unchecked(_First1), _Unchecked(_Last1),\012		_Unchecked(_First2), _Unchecked(_Last2)));\012	}\012\012		// TEMPLATE FUNCTION lexicographical_compare WITH PRED\012template<class _InIt1,\012	class _InIt2,\012	class _Pr> inline\012	bool _Lexicographical_compare(_InIt1 _First1, _InIt1 _Last1,\012		_InIt2 _First2, _InIt2 _Last2, _Pr _Pred)\012	{	// order [_First1, _Last1) vs. [First2, Last2) using _Pred\012	for (; _First1 != _Last1 && _First2 != _Last2; ++_First1, ++_First2)\012		if (_DEBUG_LT_PRED(_Pred, *_First1, *_First2))\012			return (true);\012		else if (_Pred(*_First2, *_First1))\012			return (false);\012	return (_First1 == _Last1 && _First2 != _Last2);\012	}\012\012template<class _InIt1,\012	class _InIt2,\012	class _Pr> inline\012	bool lexicographical_compare(_InIt1 _First1, _InIt1 _Last1,\012		_InIt2 _First2, _InIt2 _Last2, _Pr _Pred)\012	{	// order [_First1, _Last1) vs. [First2, Last2) using _Pred\012	_DEBUG_RANGE(_First1, _Last1);\012	_DEBUG_RANGE(_First2, _Last2);\012	_DEBUG_POINTER(_Pred);\012	return (_Lexicographical_compare(_Unchecked(_First1), _Unchecked(_Last1),\012		_Unchecked(_First2), _Unchecked(_Last2), _Pred));\012	}\012\012		// TEMPLATE FUNCTION reverse\012template<class _BidIt> inline\012	void _Reverse(_BidIt _First, _BidIt _Last, bidirectional_iterator_tag)\012	{	// reverse elements in [_First, _Last), bidirectional iterators\012	for (; _First != _Last && _First != --_Last; ++_First)\012		_STD iter_swap(_First, _Last);\012	}\012\012template<class _BidIt> inline\012	void reverse(_BidIt _First, _BidIt _Last)\012	{	// reverse elements in [_First, _Last)\012	_DEBUG_RANGE(_First, _Last);\012	_Reverse(_Unchecked(_First), _Unchecked(_Last), _Iter_cat(_First));\012	}\012\012		// TEMPLATE FUNCTION rotate\012template<class _FwdIt> inline\012	void _Rotate(_FwdIt _First, _FwdIt _Mid, _FwdIt _Last,\012		forward_iterator_tag)\012	{	// rotate [_First, _Last), forward iterators\012	for (_FwdIt _Next = _Mid; ; )\012		{	// swap [_First, ...) into place\012		_STD iter_swap(_First, _Next);\012		if (++_First == _Mid)\012			if (++_Next == _Last)\012				break;	// done, quit\012			else\012				_Mid = _Next;	// mark end of next interval\012		else if (++_Next == _Last)\012			_Next = _Mid;	// wrap to last end\012		}\012	}\012\012template<class _BidIt> inline\012	void _Rotate(_BidIt _First, _BidIt _Mid, _BidIt _Last,\012		bidirectional_iterator_tag)\012	{	// rotate [_First, _Last), bidirectional iterators\012	_STD reverse(_First, _Mid);\012	_STD reverse(_Mid, _Last);\012	_STD reverse(_First, _Last);\012	}\012\012template<class _RanIt,\012	class _Diff,\012	class _Ty> inline\012	void _Rotate(_RanIt _First, _RanIt _Mid, _RanIt _Last, _Diff *, _Ty *)\012	{	// rotate [_First, _Last), random-access iterators\012	_Diff _Shift = _Mid - _First;\012	_Diff _Count = _Last - _First;\012\012	for (_Diff _Factor = _Shift; _Factor != 0; )\012		{	// find subcycle count as GCD of shift count and length\012		_Diff _Tmp = _Count % _Factor;\012		_Count = _Factor;\012		_Factor = _Tmp;\012		}\012\012	if (_Count < _Last - _First)\012		for (; 0 < _Count; --_Count)\012			{	// rotate each subcycle\012			_RanIt _Hole = _First + _Count;\012			_RanIt _Next = _Hole;\012			_RanIt _Next1 = _Next + _Shift == _Last ? _First : _Next + _Shift;\012			for (; ; )\012				{	// percolate elements back around subcycle\012				iter_swap(_Next, _Next1);\012				_Next = _Next1;\012				_Next1 = _Shift < _Last - _Next1 ? _Next1 + _Shift\012					: _First + (_Shift - (_Last - _Next1));\012				if (_Next1 == _Hole)\012					break;\012				}\012			}\012	}\012\012template<class _RanIt> inline\012	void _Rotate(_RanIt _First, _RanIt _Mid, _RanIt _Last,\012		random_access_iterator_tag)\012	{	// rotate [_First, _Last), random-access iterators\012	_Rotate(_First, _Mid, _Last, _Dist_type(_First), _Val_type(_First));\012	}\012\012template<class _FwdIt> inline\012	_FwdIt rotate(_FwdIt _First, _FwdIt _Mid, _FwdIt _Last)\012	{	// rotate [_First, _Last)\012	_DEBUG_RANGE(_First, _Mid);\012	_DEBUG_RANGE(_Mid, _Last);\012	if (_First != _Mid && _Mid != _Last)\012		{	// rotate and compute new first iterator\012		_Rotate(_Unchecked(_First), _Unchecked(_Mid), _Unchecked(_Last),\012			_Iter_cat(_First));\012		_STD advance(_First, _STD distance(_Mid, _Last));\012		}\012	return (_First);\012	}\012\012		// TEMPLATE CLASS _Yarn\012template<class _Elem>\012	class _CRTIMP2_PURE _Yarn\012	{	// wrap a NTBS\012public:\012	typedef _Yarn<_Elem> _Myt;\012\012	__CLR_OR_THIS_CALL _Yarn()\012		: _Myptr(0), _Nul(0)\012		{	// default construct\012		}\012\012	__CLR_OR_THIS_CALL _Yarn(const _Myt& _Right)\012		: _Myptr(0), _Nul(0)\012		{	// construct from _Yarn\012		*this = _Right;\012		}\012\012	__CLR_OR_THIS_CALL _Yarn(const _Elem *_Right)\012		: _Myptr(0), _Nul(0)\012		{	// construct from NTBS\012		*this = _Right;\012		}\012\012	_Myt& __CLR_OR_THIS_CALL operator=(const _Myt& _Right)\012		{	// assign from _Yarn\012		return (*this = _Right._Myptr);\012		}\012\012	_Myt& __CLR_OR_THIS_CALL operator=(const _Elem *_Right)\012		{	// assign from NTBS\012		if (_Myptr != _Right)\012			{	// new value, discard old and copy new\012			_Tidy();\012\012			if (_Right != 0)\012				{	// new is not empty, copy it\012				const _Elem *_Ptr = _Right;\012				while (*_Ptr != (_Elem)0)\012					++_Ptr;\012				size_t _Count = ((const char *)++_Ptr - (const char *)_Right)\012					* sizeof (_Elem);\012\012 #ifdef _DEBUG\012				_Myptr = (_Elem *)_malloc_dbg(_Count, _CRT_BLOCK,\012					__FILE__, __LINE__);\012\012 #else /* _DEBUG */\012				_Myptr = (_Elem *)_CSTD malloc(_Count);\012 #endif /* _DEBUG */\012\012				if (_Myptr != 0)\012					_CSTD memcpy(_Myptr, _Right, _Count);\012				}\012			}\012		return (*this);\012		}\012\012	__CLR_OR_THIS_CALL ~_Yarn()\012		{	// destroy the object\012		_Tidy();\012		}\012\012	bool __CLR_OR_THIS_CALL empty() const\012		{	// test if empty string\012		return (_Myptr == 0);\012		}\012\012	const _Elem *__CLR_OR_THIS_CALL c_str() const\012		{	// return NTBS\012		return (_Myptr != 0 ? _Myptr : &_Nul);\012		}\012\012	bool __CLR_OR_THIS_CALL _Empty() const\012		{	// test if empty string\012		return (_Myptr == 0);\012		}\012\012	const _Elem *__CLR_OR_THIS_CALL _C_str() const\012		{	// return NTBS\012		return (_Myptr != 0 ? _Myptr : &_Nul);\012		}\012\012private:\012	void __CLR_OR_THIS_CALL _Tidy()\012		{	// discard any string\012		if (_Myptr != 0)\012\012 #ifdef _DEBUG\012			_free_dbg(_Myptr, _CRT_BLOCK);\012\012 #else /* _DEBUG */\012			_CSTD free(_Myptr);\012 #endif /* _DEBUG */\012\012		_Myptr = 0;\012		}\012\012	_Elem *_Myptr;	// pointer to allocated string\012	_Elem _Nul;		// nul terminator for unallocated string\012	};\012\012_CRTIMP2_PURE __declspec(noreturn) void __CLRCALL_PURE_OR_CDECL _Xinvalid_argument(_In_z_ const char *);\012_CRTIMP2_PURE __declspec(noreturn) void __CLRCALL_PURE_OR_CDECL _Xlength_error(_In_z_ const char *);\012_CRTIMP2_PURE __declspec(noreturn) void __CLRCALL_PURE_OR_CDECL _Xout_of_range(_In_z_ const char *);\012_CRTIMP2_PURE __declspec(noreturn) void __CLRCALL_PURE_OR_CDECL _Xoverflow_error(_In_z_ const char *);\012_CRTIMP2_PURE __declspec(noreturn) void __CLRCALL_PURE_OR_CDECL _Xruntime_error(_In_z_ const char *);\012_STD_END\012 #pragma warning(pop)\012 #pragma pack(pop)\012\012#endif /* RC_INVOKED */\012#endif /* _XUTILITY_ */\012\012/*\012 * This file is derived from software bearing the following\012 * restrictions:\012 *\012 * Copyright (c) 1994\012 * Hewlett-Packard Company\012 *\012 * Permission to use, copy, modify, distribute and sell this\012 * software and its documentation for any purpose is hereby\012 * granted without fee, provided that the above copyright notice\012 * appear in all copies and that both that copyright notice and\012 * this permission notice appear in supporting documentation.\012 * Hewlett-Packard Company makes no representations about the\012 * suitability of this software for any purpose. It is provided\012 * \"as is\" without express or implied warranty.\012 */\012\012/*\012 * Copyright (c) 1992-2009 by P.J. Plauger.  ALL RIGHTS RESERVED.\012 * Consult your license regarding permissions and restrictions.\012V5.20:0009 */\012"}];
